<html>
  <head>
    <script>
    <!-- chessground Copyright (c) GNU GENERAL PUBLIC LICENSE Version 3, 29 June 2007 -->
    <!-- chess.js Copyright (c) 2023, Jeff Hlywa (jhlywa@gmail.com) -->
    <!-- mliebelt Copyright (c) GNU GENERAL PUBLIC LICENSE Version 3 -->
      (function() {
        function r(e, n, t) {
          function o(i, f) {
            if (!n[i]) {
              if (!e[i]) {
                var c = "function" == typeof require && require;
                if (!f && c) return c(i, !0);
                if (u) return u(i, !0);
                var a = new Error("Cannot find module '" + i + "'");
                throw a.code = "MODULE_NOT_FOUND", a
              }
              var p = n[i] = {
                exports: {}
              };
              e[i][0].call(p.exports, function(r) {
                var n = e[i][1][r];
                return o(n || r)
              }, p, p.exports, r, e, n, t)
            }
            return n[i].exports
          }
          for (var u = "function" == typeof require && require, i = 0; i < t.length; i++) o(t[i]);
          return o
        }
        return r
      })()({
        1: [function(require, module, exports) {
          /*
           * Generated by PEG.js 0.10.0.
           *
           * http://pegjs.org/
           */

          /*
           * Generated by PEG.js 0.10.0.
           *
           * http://pegjs.org/
           */

          "use strict";

          function peg$subclass(child, parent) {
            function ctor() {
              this.constructor = child;
            }
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
          }

          function peg$SyntaxError(message, expected, found, location) {
            this.message = message;
            this.expected = expected;
            this.found = found;
            this.location = location;
            this.name = "SyntaxError";

            if (typeof Error.captureStackTrace === "function") {
              Error.captureStackTrace(this, peg$SyntaxError);
            }
          }

          peg$subclass(peg$SyntaxError, Error);

          peg$SyntaxError.buildMessage = function(expected, found) {
            var DESCRIBE_EXPECTATION_FNS = {
              literal: function(expectation) {
                return "\"" + literalEscape(expectation.text) + "\"";
              },

              "class": function(expectation) {
                var escapedParts = "",
                  i;

                for (i = 0; i < expectation.parts.length; i++) {
                  escapedParts += expectation.parts[i] instanceof Array ?
                    classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) :
                    classEscape(expectation.parts[i]);
                }

                return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
              },

              any: function(expectation) {
                return "any character";
              },

              end: function(expectation) {
                return "end of input";
              },

              other: function(expectation) {
                return expectation.description;
              }
            };

            function hex(ch) {
              return ch.charCodeAt(0).toString(16).toUpperCase();
            }

            function literalEscape(s) {
              return s
                .replace(/\\/g, '\\\\')
                .replace(/"/g, '\\"')
                .replace(/\0/g, '\\0')
                .replace(/\t/g, '\\t')
                .replace(/\n/g, '\\n')
                .replace(/\r/g, '\\r')
                .replace(/[\x00-\x0F]/g, function(ch) {
                  return '\\x0' + hex(ch);
                })
                .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
                  return '\\x' + hex(ch);
                });
            }

            function classEscape(s) {
              return s
                .replace(/\\/g, '\\\\')
                .replace(/\]/g, '\\]')
                .replace(/\^/g, '\\^')
                .replace(/-/g, '\\-')
                .replace(/\0/g, '\\0')
                .replace(/\t/g, '\\t')
                .replace(/\n/g, '\\n')
                .replace(/\r/g, '\\r')
                .replace(/[\x00-\x0F]/g, function(ch) {
                  return '\\x0' + hex(ch);
                })
                .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
                  return '\\x' + hex(ch);
                });
            }

            function describeExpectation(expectation) {
              return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
            }

            function describeExpected(expected) {
              var descriptions = new Array(expected.length),
                i, j;

              for (i = 0; i < expected.length; i++) {
                descriptions[i] = describeExpectation(expected[i]);
              }

              descriptions.sort();

              if (descriptions.length > 0) {
                for (i = 1, j = 1; i < descriptions.length; i++) {
                  if (descriptions[i - 1] !== descriptions[i]) {
                    descriptions[j] = descriptions[i];
                    j++;
                  }
                }
                descriptions.length = j;
              }

              switch (descriptions.length) {
                case 1:
                  return descriptions[0];

                case 2:
                  return descriptions[0] + " or " + descriptions[1];

                default:
                  return descriptions.slice(0, -1).join(", ") +
                    ", or " +
                    descriptions[descriptions.length - 1];
              }
            }

            function describeFound(found) {
              return found ? "\"" + literalEscape(found) + "\"" : "end of input";
            }

            return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
          };

          function peg$parse(input, options) {
            options = options !== void 0 ? options : {};

            var peg$FAILED = {},

              peg$startRuleFunctions = {
                pgn: peg$parsepgn,
                tags: peg$parsetags,
                game: peg$parsegame,
                games: peg$parsegames
              },
              peg$startRuleFunction = peg$parsepgn,

              peg$c0 = function(head, m) {
                return m;
              },
              peg$c1 = function(head, tail) {
                return [head].concat(tail)
              },
              peg$c2 = function(games) {
                return games
              },
              peg$c3 = function(t, c, p) {
                return {
                  tags: t,
                  gameComment: c,
                  moves: p[0]
                };
              },
              peg$c4 = function(head, tail) {
                var result = {};
                [head].concat(tail).forEach(function(element) {
                  result[element.name] = element.value;
                });
                return result;
              },
              peg$c5 = function(members) {
                return members !== null ? members : {};
              },
              peg$c6 = function(tag) {
                return tag;
              },
              peg$c7 = function(value) {
                return {
                  name: 'Event',
                  value: value
                };
              },
              peg$c8 = function(value) {
                return {
                  name: 'Site',
                  value: value
                };
              },
              peg$c9 = function(value) {
                return {
                  name: 'Date',
                  value: value
                };
              },
              peg$c10 = function(value) {
                return {
                  name: 'Round',
                  value: value
                };
              },
              peg$c11 = function(value) {
                return {
                  name: 'WhiteTitle',
                  value: value
                };
              },
              peg$c12 = function(value) {
                return {
                  name: 'BlackTitle',
                  value: value
                };
              },
              peg$c13 = function(value) {
                return {
                  name: 'WhiteELO',
                  value: value
                };
              },
              peg$c14 = function(value) {
                return {
                  name: 'BlackELO',
                  value: value
                };
              },
              peg$c15 = function(value) {
                return {
                  name: 'WhiteUSCF',
                  value: value
                };
              },
              peg$c16 = function(value) {
                return {
                  name: 'BlackUSCF',
                  value: value
                };
              },
              peg$c17 = function(value) {
                return {
                  name: 'WhiteNA',
                  value: value
                };
              },
              peg$c18 = function(value) {
                return {
                  name: 'BlackNA',
                  value: value
                };
              },
              peg$c19 = function(value) {
                return {
                  name: 'WhiteType',
                  value: value
                };
              },
              peg$c20 = function(value) {
                return {
                  name: 'BlackType',
                  value: value
                };
              },
              peg$c21 = function(value) {
                return {
                  name: 'White',
                  value: value
                };
              },
              peg$c22 = function(value) {
                return {
                  name: 'Black',
                  value: value
                };
              },
              peg$c23 = function(value) {
                return {
                  name: 'Result',
                  value: value
                };
              },
              peg$c24 = function(value) {
                return {
                  name: 'EventDate',
                  value: value
                };
              },
              peg$c25 = function(value) {
                return {
                  name: 'EventSponsor',
                  value: value
                };
              },
              peg$c26 = function(value) {
                return {
                  name: 'Section',
                  value: value
                };
              },
              peg$c27 = function(value) {
                return {
                  name: 'Stage',
                  value: value
                };
              },
              peg$c28 = function(value) {
                return {
                  name: 'Board',
                  value: value
                };
              },
              peg$c29 = function(value) {
                return {
                  name: 'Opening',
                  value: value
                };
              },
              peg$c30 = function(value) {
                return {
                  name: 'Variation',
                  value: value
                };
              },
              peg$c31 = function(value) {
                return {
                  name: 'SubVariation',
                  value: value
                };
              },
              peg$c32 = function(value) {
                return {
                  name: 'ECO',
                  value: value
                };
              },
              peg$c33 = function(value) {
                return {
                  name: 'NIC',
                  value: value
                };
              },
              peg$c34 = function(value) {
                return {
                  name: 'Time',
                  value: value
                };
              },
              peg$c35 = function(value) {
                return {
                  name: 'UTCTime',
                  value: value
                };
              },
              peg$c36 = function(value) {
                return {
                  name: 'UTCDate',
                  value: value
                };
              },
              peg$c37 = function(value) {
                return {
                  name: 'TimeControl',
                  value: value
                };
              },
              peg$c38 = function(value) {
                return {
                  name: 'SetUp',
                  value: value
                };
              },
              peg$c39 = function(value) {
                return {
                  name: 'FEN',
                  value: value
                };
              },
              peg$c40 = function(value) {
                return {
                  name: 'Termination',
                  value: value
                };
              },
              peg$c41 = function(value) {
                return {
                  name: 'Annotator',
                  value: value
                };
              },
              peg$c42 = function(value) {
                return {
                  name: 'Mode',
                  value: value
                };
              },
              peg$c43 = function(value) {
                return {
                  name: 'PlyCount',
                  value: value
                };
              },
              peg$c44 = function(any, value) {
                return {
                  name: any,
                  value: value
                };
              },
              peg$c45 = "Event",
              peg$c46 = peg$literalExpectation("Event", false),
              peg$c47 = "event",
              peg$c48 = peg$literalExpectation("event", false),
              peg$c49 = "Site",
              peg$c50 = peg$literalExpectation("Site", false),
              peg$c51 = "site",
              peg$c52 = peg$literalExpectation("site", false),
              peg$c53 = "Date",
              peg$c54 = peg$literalExpectation("Date", false),
              peg$c55 = "date",
              peg$c56 = peg$literalExpectation("date", false),
              peg$c57 = "Round",
              peg$c58 = peg$literalExpectation("Round", false),
              peg$c59 = "round",
              peg$c60 = peg$literalExpectation("round", false),
              peg$c61 = "White",
              peg$c62 = peg$literalExpectation("White", false),
              peg$c63 = "Black",
              peg$c64 = peg$literalExpectation("Black", false),
              peg$c65 = "black",
              peg$c66 = peg$literalExpectation("black", false),
              peg$c67 = "Result",
              peg$c68 = peg$literalExpectation("Result", false),
              peg$c69 = "result",
              peg$c70 = peg$literalExpectation("result", false),
              peg$c71 = "WhiteTitle",
              peg$c72 = peg$literalExpectation("WhiteTitle", false),
              peg$c73 = "Whitetitle",
              peg$c74 = peg$literalExpectation("Whitetitle", false),
              peg$c75 = "whitetitle",
              peg$c76 = peg$literalExpectation("whitetitle", false),
              peg$c77 = "BlackTitle",
              peg$c78 = peg$literalExpectation("BlackTitle", false),
              peg$c79 = "Blacktitle",
              peg$c80 = peg$literalExpectation("Blacktitle", false),
              peg$c81 = "blacktitle",
              peg$c82 = peg$literalExpectation("blacktitle", false),
              peg$c83 = "WhiteELO",
              peg$c84 = peg$literalExpectation("WhiteELO", false),
              peg$c85 = "WhiteElo",
              peg$c86 = peg$literalExpectation("WhiteElo", false),
              peg$c87 = "Whiteelo",
              peg$c88 = peg$literalExpectation("Whiteelo", false),
              peg$c89 = "whiteelo",
              peg$c90 = peg$literalExpectation("whiteelo", false),
              peg$c91 = "BlackELO",
              peg$c92 = peg$literalExpectation("BlackELO", false),
              peg$c93 = "BlackElo",
              peg$c94 = peg$literalExpectation("BlackElo", false),
              peg$c95 = "Blackelo",
              peg$c96 = peg$literalExpectation("Blackelo", false),
              peg$c97 = "blackelo",
              peg$c98 = peg$literalExpectation("blackelo", false),
              peg$c99 = "WhiteUSCF",
              peg$c100 = peg$literalExpectation("WhiteUSCF", false),
              peg$c101 = "WhiteUscf",
              peg$c102 = peg$literalExpectation("WhiteUscf", false),
              peg$c103 = "Whiteuscf",
              peg$c104 = peg$literalExpectation("Whiteuscf", false),
              peg$c105 = "whiteuscf",
              peg$c106 = peg$literalExpectation("whiteuscf", false),
              peg$c107 = "BlackUSCF",
              peg$c108 = peg$literalExpectation("BlackUSCF", false),
              peg$c109 = "BlackUscf",
              peg$c110 = peg$literalExpectation("BlackUscf", false),
              peg$c111 = "Blackuscf",
              peg$c112 = peg$literalExpectation("Blackuscf", false),
              peg$c113 = "blackuscf",
              peg$c114 = peg$literalExpectation("blackuscf", false),
              peg$c115 = "WhiteNA",
              peg$c116 = peg$literalExpectation("WhiteNA", false),
              peg$c117 = "WhiteNa",
              peg$c118 = peg$literalExpectation("WhiteNa", false),
              peg$c119 = "Whitena",
              peg$c120 = peg$literalExpectation("Whitena", false),
              peg$c121 = "whitena",
              peg$c122 = peg$literalExpectation("whitena", false),
              peg$c123 = "BlackNA",
              peg$c124 = peg$literalExpectation("BlackNA", false),
              peg$c125 = "BlackNa",
              peg$c126 = peg$literalExpectation("BlackNa", false),
              peg$c127 = "Blackna",
              peg$c128 = peg$literalExpectation("Blackna", false),
              peg$c129 = "blackna",
              peg$c130 = peg$literalExpectation("blackna", false),
              peg$c131 = "WhiteType",
              peg$c132 = peg$literalExpectation("WhiteType", false),
              peg$c133 = "Whitetype",
              peg$c134 = peg$literalExpectation("Whitetype", false),
              peg$c135 = "whitetype",
              peg$c136 = peg$literalExpectation("whitetype", false),
              peg$c137 = "BlackType",
              peg$c138 = peg$literalExpectation("BlackType", false),
              peg$c139 = "Blacktype",
              peg$c140 = peg$literalExpectation("Blacktype", false),
              peg$c141 = "blacktype",
              peg$c142 = peg$literalExpectation("blacktype", false),
              peg$c143 = "EventDate",
              peg$c144 = peg$literalExpectation("EventDate", false),
              peg$c145 = "Eventdate",
              peg$c146 = peg$literalExpectation("Eventdate", false),
              peg$c147 = "eventdate",
              peg$c148 = peg$literalExpectation("eventdate", false),
              peg$c149 = "EventSponsor",
              peg$c150 = peg$literalExpectation("EventSponsor", false),
              peg$c151 = "Eventsponsor",
              peg$c152 = peg$literalExpectation("Eventsponsor", false),
              peg$c153 = "eventsponsor",
              peg$c154 = peg$literalExpectation("eventsponsor", false),
              peg$c155 = "Section",
              peg$c156 = peg$literalExpectation("Section", false),
              peg$c157 = "section",
              peg$c158 = peg$literalExpectation("section", false),
              peg$c159 = "Stage",
              peg$c160 = peg$literalExpectation("Stage", false),
              peg$c161 = "stage",
              peg$c162 = peg$literalExpectation("stage", false),
              peg$c163 = "Board",
              peg$c164 = peg$literalExpectation("Board", false),
              peg$c165 = "board",
              peg$c166 = peg$literalExpectation("board", false),
              peg$c167 = "Opening",
              peg$c168 = peg$literalExpectation("Opening", false),
              peg$c169 = "opening",
              peg$c170 = peg$literalExpectation("opening", false),
              peg$c171 = "Variation",
              peg$c172 = peg$literalExpectation("Variation", false),
              peg$c173 = "variation",
              peg$c174 = peg$literalExpectation("variation", false),
              peg$c175 = "SubVariation",
              peg$c176 = peg$literalExpectation("SubVariation", false),
              peg$c177 = "Subvariation",
              peg$c178 = peg$literalExpectation("Subvariation", false),
              peg$c179 = "subvariation",
              peg$c180 = peg$literalExpectation("subvariation", false),
              peg$c181 = "ECO",
              peg$c182 = peg$literalExpectation("ECO", false),
              peg$c183 = "Eco",
              peg$c184 = peg$literalExpectation("Eco", false),
              peg$c185 = "eco",
              peg$c186 = peg$literalExpectation("eco", false),
              peg$c187 = "NIC",
              peg$c188 = peg$literalExpectation("NIC", false),
              peg$c189 = "Nic",
              peg$c190 = peg$literalExpectation("Nic", false),
              peg$c191 = "nic",
              peg$c192 = peg$literalExpectation("nic", false),
              peg$c193 = "Time",
              peg$c194 = peg$literalExpectation("Time", false),
              peg$c195 = "time",
              peg$c196 = peg$literalExpectation("time", false),
              peg$c197 = "UTCTime",
              peg$c198 = peg$literalExpectation("UTCTime", false),
              peg$c199 = "UTCtime",
              peg$c200 = peg$literalExpectation("UTCtime", false),
              peg$c201 = "UtcTime",
              peg$c202 = peg$literalExpectation("UtcTime", false),
              peg$c203 = "Utctime",
              peg$c204 = peg$literalExpectation("Utctime", false),
              peg$c205 = "utctime",
              peg$c206 = peg$literalExpectation("utctime", false),
              peg$c207 = "UTCDate",
              peg$c208 = peg$literalExpectation("UTCDate", false),
              peg$c209 = "UTCdate",
              peg$c210 = peg$literalExpectation("UTCdate", false),
              peg$c211 = "UtcDate",
              peg$c212 = peg$literalExpectation("UtcDate", false),
              peg$c213 = "Utcdate",
              peg$c214 = peg$literalExpectation("Utcdate", false),
              peg$c215 = "utcdate",
              peg$c216 = peg$literalExpectation("utcdate", false),
              peg$c217 = "TimeControl",
              peg$c218 = peg$literalExpectation("TimeControl", false),
              peg$c219 = "Timecontrol",
              peg$c220 = peg$literalExpectation("Timecontrol", false),
              peg$c221 = "timecontrol",
              peg$c222 = peg$literalExpectation("timecontrol", false),
              peg$c223 = "SetUp",
              peg$c224 = peg$literalExpectation("SetUp", false),
              peg$c225 = "Setup",
              peg$c226 = peg$literalExpectation("Setup", false),
              peg$c227 = "setup",
              peg$c228 = peg$literalExpectation("setup", false),
              peg$c229 = "FEN",
              peg$c230 = peg$literalExpectation("FEN", false),
              peg$c231 = "Fen",
              peg$c232 = peg$literalExpectation("Fen", false),
              peg$c233 = "fen",
              peg$c234 = peg$literalExpectation("fen", false),
              peg$c235 = "Termination",
              peg$c236 = peg$literalExpectation("Termination", false),
              peg$c237 = "termination",
              peg$c238 = peg$literalExpectation("termination", false),
              peg$c239 = "Annotator",
              peg$c240 = peg$literalExpectation("Annotator", false),
              peg$c241 = "annotator",
              peg$c242 = peg$literalExpectation("annotator", false),
              peg$c243 = "Mode",
              peg$c244 = peg$literalExpectation("Mode", false),
              peg$c245 = "mode",
              peg$c246 = peg$literalExpectation("mode", false),
              peg$c247 = "PlyCount",
              peg$c248 = peg$literalExpectation("PlyCount", false),
              peg$c249 = "Plycount",
              peg$c250 = peg$literalExpectation("Plycount", false),
              peg$c251 = "plycount",
              peg$c252 = peg$literalExpectation("plycount", false),
              peg$c253 = peg$otherExpectation("whitespace"),
              peg$c254 = /^[ \t\n\r]/,
              peg$c255 = peg$classExpectation([" ", "\t", "\n", "\r"], false, false),
              peg$c256 = /^[\n\r]/,
              peg$c257 = peg$classExpectation(["\n", "\r"], false, false),
              peg$c258 = peg$otherExpectation("string"),
              peg$c259 = function(chars) {
                return chars.join("");
              },
              peg$c260 = /^[\-a-zA-Z0-9.]/,
              peg$c261 = peg$classExpectation(["-", ["a", "z"],
                ["A", "Z"],
                ["0", "9"], "."
              ], false, false),
              peg$c262 = "\"",
              peg$c263 = peg$literalExpectation("\"", false),
              peg$c264 = /^[^\0-\x1F"\\]/,
              peg$c265 = peg$classExpectation([
                ["\0", "\x1F"], "\"", "\\"
              ], true, false),
              peg$c266 = /^[0-9?]/,
              peg$c267 = peg$classExpectation([
                ["0", "9"], "?"
              ], false, false),
              peg$c268 = ".",
              peg$c269 = peg$literalExpectation(".", false),
              peg$c270 = function(year, month, day) {
                return "" + year.join("") + '.' + month.join("") + '.' + day.join("");
              },
              peg$c271 = function(res) {
                return res;
              },
              peg$c272 = "1-0",
              peg$c273 = peg$literalExpectation("1-0", false),
              peg$c274 = function(res) {
                return res;
              },
              peg$c275 = "1:0",
              peg$c276 = peg$literalExpectation("1:0", false),
              peg$c277 = "0-1",
              peg$c278 = peg$literalExpectation("0-1", false),
              peg$c279 = "0:1",
              peg$c280 = peg$literalExpectation("0:1", false),
              peg$c281 = "1/2-1/2",
              peg$c282 = peg$literalExpectation("1/2-1/2", false),
              peg$c283 = "*",
              peg$c284 = peg$literalExpectation("*", false),
              peg$c285 = "-",
              peg$c286 = peg$literalExpectation("-", false),
              peg$c287 = /^[0-9]/,
              peg$c288 = peg$classExpectation([
                ["0", "9"]
              ], false, false),
              peg$c289 = function(digits) {
                return makeInteger(digits);
              },
              peg$c290 = function(pw, all) {
                var arr = (all ? all : []);
                arr.unshift(pw);
                return arr;
              },
              peg$c291 = function(pb, all) {
                var arr = (all ? all : []);
                arr.unshift(pb);
                return arr;
              },
              peg$c292 = function() {
                return [
                  []
                ];
              },
              peg$c293 = function(pw) {
                return pw;
              },
              peg$c294 = function(pb) {
                return pb;
              },
              peg$c295 = function(cm, mn, hm, nag, ca, vari, all) {
                var arr = (all ? all : []);
                var move = {};
                move.turn = 'w';
                move.moveNumber = mn;
                move.notation = hm;
                if (ca) {
                  move.commentAfter = ca.comment
                };
                if (cm) {
                  move.commentMove = cm.comment
                };
                move.variations = (vari ? vari : []);
                move.nag = (nag ? nag : null);
                arr.unshift(move);
                move.commentDiag = ca;
                return arr;
              },
              peg$c296 = function(cm, me, hm, nag, ca, vari, all) {
                var arr = (all ? all : []);
                var move = {};
                move.turn = 'b';
                move.moveNumber = me;
                move.notation = hm;
                if (ca) {
                  move.commentAfter = ca.comment
                };
                if (cm) {
                  move.commentMove = cm.comment
                };
                move.variations = (vari ? vari : []);
                arr.unshift(move);
                move.nag = (nag ? nag : null);
                move.commentDiag = ca;
                return arr;
              },
              peg$c297 = function() {
                return ["1:0"];
              },
              peg$c298 = function() {
                return ["0:1"];
              },
              peg$c299 = function() {
                return ["1-0"];
              },
              peg$c300 = function() {
                return ["0-1"];
              },
              peg$c301 = function() {
                return ["1/2-1/2"];
              },
              peg$c302 = function() {
                return ["*"];
              },
              peg$c303 = function(cf, c) {
                return c
              },
              peg$c304 = function(cf, cfl) {
                return merge([cf].concat(cfl))
              },
              peg$c305 = function(cm) {
                return cm;
              },
              peg$c306 = function(cm) {
                return {
                  comment: cm
                };
              },
              peg$c307 = "%csl",
              peg$c308 = peg$literalExpectation("%csl", false),
              peg$c309 = function(cf, ic) {
                return ic
              },
              peg$c310 = function(cf, tail) {
                return merge([{
                  colorFields: cf
                }].concat(tail[0]))
              },
              peg$c311 = "%cal",
              peg$c312 = peg$literalExpectation("%cal", false),
              peg$c313 = function(ca, ic) {
                return ic
              },
              peg$c314 = function(ca, tail) {
                return merge([{
                  colorArrows: ca
                }].concat(tail[0]))
              },
              peg$c315 = "%",
              peg$c316 = peg$literalExpectation("%", false),
              peg$c317 = function(cc, cv, ic) {
                return ic
              },
              peg$c318 = function(cc, cv, tail) {
                var ret = {};
                ret[cc] = cv;
                return merge([ret].concat(tail[0]))
              },
              peg$c319 = "%eval",
              peg$c320 = peg$literalExpectation("%eval", false),
              peg$c321 = function(ev, ic) {
                return ic
              },
              peg$c322 = function(ev, tail) {
                var ret = {};
                ret["eval"] = ev;
                return merge([ret].concat(tail[0]))
              },
              peg$c323 = function(ac, ic) {
                return ic
              },
              peg$c324 = function(ac, tail) {
                return tail[0]
              },
              peg$c325 = function(c, ic) {
                return ic
              },
              peg$c326 = function(c, tail) {
                if (tail.length > 0) {
                  return merge([{
                    comment: trimEnd(c.join(""))
                  }].concat(trimStart(tail[0])))
                } else {
                  return {
                    comment: c.join("")
                  }
                }
              },
              peg$c327 = "[%",
              peg$c328 = peg$literalExpectation("[%", false),
              peg$c329 = "}",
              peg$c330 = peg$literalExpectation("}", false),
              peg$c331 = peg$anyExpectation(),
              peg$c332 = function(char) {
                return char;
              },
              peg$c333 = /^[^\n\r]/,
              peg$c334 = peg$classExpectation(["\n", "\r"], true, false),
              peg$c335 = function(cm) {
                return cm.join("");
              },
              peg$c336 = ",",
              peg$c337 = peg$literalExpectation(",", false),
              peg$c338 = function(cf, cfl) {
                var arr = [];
                arr.push(cf);
                for (var i = 0; i < cfl.length; i++) {
                  arr.push(cfl[i][2])
                };
                return arr;
              },
              peg$c339 = function(col, f) {
                return col + f;
              },
              peg$c340 = function(col, ff, ft) {
                return col + ff + ft;
              },
              peg$c341 = "Y",
              peg$c342 = peg$literalExpectation("Y", false),
              peg$c343 = function() {
                return "Y";
              },
              peg$c344 = "G",
              peg$c345 = peg$literalExpectation("G", false),
              peg$c346 = function() {
                return "G";
              },
              peg$c347 = "R",
              peg$c348 = peg$literalExpectation("R", false),
              peg$c349 = function() {
                return "R";
              },
              peg$c350 = "B",
              peg$c351 = peg$literalExpectation("B", false),
              peg$c352 = function() {
                return "B";
              },
              peg$c353 = function(col, row) {
                return col + row;
              },
              peg$c354 = "{",
              peg$c355 = peg$literalExpectation("{", false),
              peg$c356 = "[",
              peg$c357 = peg$literalExpectation("[", false),
              peg$c358 = "]",
              peg$c359 = peg$literalExpectation("]", false),
              peg$c360 = ";",
              peg$c361 = peg$literalExpectation(";", false),
              peg$c362 = "clk",
              peg$c363 = peg$literalExpectation("clk", false),
              peg$c364 = function() {
                return "clk";
              },
              peg$c365 = "egt",
              peg$c366 = peg$literalExpectation("egt", false),
              peg$c367 = function() {
                return "egt";
              },
              peg$c368 = "emt",
              peg$c369 = peg$literalExpectation("emt", false),
              peg$c370 = function() {
                return "emt";
              },
              peg$c371 = "mct",
              peg$c372 = peg$literalExpectation("mct", false),
              peg$c373 = function() {
                return "mct";
              },
              peg$c374 = ":",
              peg$c375 = peg$literalExpectation(":", false),
              peg$c376 = function(h1, h2, m1, m2, s1, s2) {
                var ret = h1;
                if (h2) {
                  ret += h2
                };
                ret += ":" + m1 + m2 + ":" + s1 + s2;
                return ret;
              },
              peg$c377 = function(d) {
                return d;
              },
              peg$c378 = function(vari, all) {
                var arr = (all ? all : []);
                arr.unshift(vari);
                return arr;
              },
              peg$c379 = "(",
              peg$c380 = peg$literalExpectation("(", false),
              peg$c381 = ")",
              peg$c382 = peg$literalExpectation(")", false),
              peg$c383 = function(num) {
                return num;
              },
              peg$c384 = peg$otherExpectation("integer"),
              peg$c385 = " ",
              peg$c386 = peg$literalExpectation(" ", false),
              peg$c387 = function() {
                return '';
              },
              peg$c388 = function(fig, disc, str, col, row, pr, ch) {
                var hm = {};
                hm.fig = (fig ? fig : null);
                hm.disc = (disc ? disc : null);
                hm.strike = (str ? str : null);
                hm.col = col;
                hm.row = row;
                hm.check = (ch ? ch : null);
                hm.promotion = pr;
                hm.notation = (fig ? fig : "") + (disc ? disc : "") + (str ? str : "") + col + row + (pr ? pr : "") + (ch ? ch : "");
                return hm;
              },
              peg$c389 = function(fig, cols, rows, str, col, row, pr, ch) {
                var hm = {};
                hm.fig = (fig ? fig : null);
                hm.strike = (str == 'x' ? str : null);
                hm.col = col;
                hm.row = row;
                hm.check = (ch ? ch : null);
                hm.notation = (fig && (fig !== 'P') ? fig : "") + cols + rows + (str == 'x' ? str : "-") + col + row + (pr ? pr : "") + (ch ? ch : "");
                hm.promotion = pr;
                return hm;
              },
              peg$c390 = function(fig, str, col, row, pr, ch) {
                var hm = {};
                hm.fig = (fig ? fig : null);
                hm.strike = (str ? str : null);
                hm.col = col;
                hm.row = row;
                hm.check = (ch ? ch : null);
                hm.notation = (fig ? fig : "") + (str ? str : "") + col + row + (pr ? pr : "") + (ch ? ch : "");
                hm.promotion = pr;
                return hm;
              },
              peg$c391 = "O-O-O",
              peg$c392 = peg$literalExpectation("O-O-O", false),
              peg$c393 = function(ch) {
                var hm = {};
                hm.notation = 'O-O-O' + (ch ? ch : "");
                hm.check = (ch ? ch : null);
                return hm;
              },
              peg$c394 = "O-O",
              peg$c395 = peg$literalExpectation("O-O", false),
              peg$c396 = function(ch) {
                var hm = {};
                hm.notation = 'O-O' + (ch ? ch : "");
                hm.check = (ch ? ch : null);
                return hm;
              },
              peg$c397 = "+-",
              peg$c398 = peg$literalExpectation("+-", false),
              peg$c399 = "+",
              peg$c400 = peg$literalExpectation("+", false),
              peg$c401 = function(ch) {
                return ch[1];
              },
              peg$c402 = "$$$",
              peg$c403 = peg$literalExpectation("$$$", false),
              peg$c404 = "#",
              peg$c405 = peg$literalExpectation("#", false),
              peg$c406 = "=",
              peg$c407 = peg$literalExpectation("=", false),
              peg$c408 = function(f) {
                return '=' + f;
              },
              peg$c409 = function(nag, nags) {
                var arr = (nags ? nags : []);
                arr.unshift(nag);
                return arr;
              },
              peg$c410 = "$",
              peg$c411 = peg$literalExpectation("$", false),
              peg$c412 = function(num) {
                return '$' + num;
              },
              peg$c413 = "!!",
              peg$c414 = peg$literalExpectation("!!", false),
              peg$c415 = function() {
                return '$3';
              },
              peg$c416 = "??",
              peg$c417 = peg$literalExpectation("??", false),
              peg$c418 = function() {
                return '$4';
              },
              peg$c419 = "!?",
              peg$c420 = peg$literalExpectation("!?", false),
              peg$c421 = function() {
                return '$5';
              },
              peg$c422 = "?!",
              peg$c423 = peg$literalExpectation("?!", false),
              peg$c424 = function() {
                return '$6';
              },
              peg$c425 = "!",
              peg$c426 = peg$literalExpectation("!", false),
              peg$c427 = function() {
                return '$1';
              },
              peg$c428 = "?",
              peg$c429 = peg$literalExpectation("?", false),
              peg$c430 = function() {
                return '$2';
              },
              peg$c431 = "\u203C",
              peg$c432 = peg$literalExpectation("\u203C", false),
              peg$c433 = "\u2047",
              peg$c434 = peg$literalExpectation("\u2047", false),
              peg$c435 = "\u2049",
              peg$c436 = peg$literalExpectation("\u2049", false),
              peg$c437 = "\u2048",
              peg$c438 = peg$literalExpectation("\u2048", false),
              peg$c439 = "\u25A1",
              peg$c440 = peg$literalExpectation("\u25A1", false),
              peg$c441 = function() {
                return '$7';
              },
              peg$c442 = function() {
                return '$10';
              },
              peg$c443 = "\u221E",
              peg$c444 = peg$literalExpectation("\u221E", false),
              peg$c445 = function() {
                return '$13';
              },
              peg$c446 = "\u2A72",
              peg$c447 = peg$literalExpectation("\u2A72", false),
              peg$c448 = function() {
                return '$14';
              },
              peg$c449 = "\u2A71",
              peg$c450 = peg$literalExpectation("\u2A71", false),
              peg$c451 = function() {
                return '$15';
              },
              peg$c452 = "\xB1",
              peg$c453 = peg$literalExpectation("\xB1", false),
              peg$c454 = function() {
                return '$16';
              },
              peg$c455 = "\u2213",
              peg$c456 = peg$literalExpectation("\u2213", false),
              peg$c457 = function() {
                return '$17';
              },
              peg$c458 = function() {
                return '$18';
              },
              peg$c459 = "-+",
              peg$c460 = peg$literalExpectation("-+", false),
              peg$c461 = function() {
                return '$19';
              },
              peg$c462 = "\u2A00",
              peg$c463 = peg$literalExpectation("\u2A00", false),
              peg$c464 = function() {
                return '$22';
              },
              peg$c465 = "\u27F3",
              peg$c466 = peg$literalExpectation("\u27F3", false),
              peg$c467 = function() {
                return '$32';
              },
              peg$c468 = "\u2192",
              peg$c469 = peg$literalExpectation("\u2192", false),
              peg$c470 = function() {
                return '$36';
              },
              peg$c471 = "\u2191",
              peg$c472 = peg$literalExpectation("\u2191", false),
              peg$c473 = function() {
                return '$40';
              },
              peg$c474 = "\u21C6",
              peg$c475 = peg$literalExpectation("\u21C6", false),
              peg$c476 = function() {
                return '$132';
              },
              peg$c477 = "D",
              peg$c478 = peg$literalExpectation("D", false),
              peg$c479 = function() {
                return '$220';
              },
              peg$c480 = /^[RNBQKP]/,
              peg$c481 = peg$classExpectation(["R", "N", "B", "Q", "K", "P"], false, false),
              peg$c482 = /^[RNBQ]/,
              peg$c483 = peg$classExpectation(["R", "N", "B", "Q"], false, false),
              peg$c484 = /^[a-h]/,
              peg$c485 = peg$classExpectation([
                ["a", "h"]
              ], false, false),
              peg$c486 = /^[1-8]/,
              peg$c487 = peg$classExpectation([
                ["1", "8"]
              ], false, false),
              peg$c488 = "x",
              peg$c489 = peg$literalExpectation("x", false),

              peg$currPos = 0,
              peg$savedPos = 0,
              peg$posDetailsCache = [{
                line: 1,
                column: 1
              }],
              peg$maxFailPos = 0,
              peg$maxFailExpected = [],
              peg$silentFails = 0,

              peg$result;

            if ("startRule" in options) {
              if (!(options.startRule in peg$startRuleFunctions)) {
                throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
              }

              peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
            }

            function text() {
              return input.substring(peg$savedPos, peg$currPos);
            }

            function location() {
              return peg$computeLocation(peg$savedPos, peg$currPos);
            }

            function expected(description, location) {
              location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

              throw peg$buildStructuredError(
                [peg$otherExpectation(description)],
                input.substring(peg$savedPos, peg$currPos),
                location
              );
            }

            function error(message, location) {
              location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

              throw peg$buildSimpleError(message, location);
            }

            function peg$literalExpectation(text, ignoreCase) {
              return {
                type: "literal",
                text: text,
                ignoreCase: ignoreCase
              };
            }

            function peg$classExpectation(parts, inverted, ignoreCase) {
              return {
                type: "class",
                parts: parts,
                inverted: inverted,
                ignoreCase: ignoreCase
              };
            }

            function peg$anyExpectation() {
              return {
                type: "any"
              };
            }

            function peg$endExpectation() {
              return {
                type: "end"
              };
            }

            function peg$otherExpectation(description) {
              return {
                type: "other",
                description: description
              };
            }

            function peg$computePosDetails(pos) {
              var details = peg$posDetailsCache[pos],
                p;

              if (details) {
                return details;
              } else {
                p = pos - 1;
                while (!peg$posDetailsCache[p]) {
                  p--;
                }

                details = peg$posDetailsCache[p];
                details = {
                  line: details.line,
                  column: details.column
                };

                while (p < pos) {
                  if (input.charCodeAt(p) === 10) {
                    details.line++;
                    details.column = 1;
                  } else {
                    details.column++;
                  }

                  p++;
                }

                peg$posDetailsCache[pos] = details;
                return details;
              }
            }

            function peg$computeLocation(startPos, endPos) {
              var startPosDetails = peg$computePosDetails(startPos),
                endPosDetails = peg$computePosDetails(endPos);

              return {
                start: {
                  offset: startPos,
                  line: startPosDetails.line,
                  column: startPosDetails.column
                },
                end: {
                  offset: endPos,
                  line: endPosDetails.line,
                  column: endPosDetails.column
                }
              };
            }

            function peg$fail(expected) {
              if (peg$currPos < peg$maxFailPos) {
                return;
              }

              if (peg$currPos > peg$maxFailPos) {
                peg$maxFailPos = peg$currPos;
                peg$maxFailExpected = [];
              }

              peg$maxFailExpected.push(expected);
            }

            function peg$buildSimpleError(message, location) {
              return new peg$SyntaxError(message, null, null, location);
            }

            function peg$buildStructuredError(expected, found, location) {
              return new peg$SyntaxError(
                peg$SyntaxError.buildMessage(expected, found),
                expected,
                found,
                location
              );
            }

            function peg$parsegames() {
              var s0, s1, s2, s3, s4, s5, s6, s7;

              s0 = peg$currPos;
              s1 = peg$parsews();
              if (s1 !== peg$FAILED) {
                s2 = peg$currPos;
                s3 = peg$parsegame();
                if (s3 !== peg$FAILED) {
                  s4 = [];
                  s5 = peg$currPos;
                  s6 = peg$parsewsp();
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parsegame();
                    if (s7 !== peg$FAILED) {
                      peg$savedPos = s5;
                      s6 = peg$c0(s3, s7);
                      s5 = s6;
                    } else {
                      peg$currPos = s5;
                      s5 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                  while (s5 !== peg$FAILED) {
                    s4.push(s5);
                    s5 = peg$currPos;
                    s6 = peg$parsewsp();
                    if (s6 !== peg$FAILED) {
                      s7 = peg$parsegame();
                      if (s7 !== peg$FAILED) {
                        peg$savedPos = s5;
                        s6 = peg$c0(s3, s7);
                        s5 = s6;
                      } else {
                        peg$currPos = s5;
                        s5 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s5;
                      s5 = peg$FAILED;
                    }
                  }
                  if (s4 !== peg$FAILED) {
                    peg$savedPos = s2;
                    s3 = peg$c1(s3, s4);
                    s2 = s3;
                  } else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
                if (s2 === peg$FAILED) {
                  s2 = null;
                }
                if (s2 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c2(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }

              return s0;
            }

            function peg$parsegame() {
              var s0, s1, s2, s3;

              s0 = peg$currPos;
              s1 = peg$parsetags();
              if (s1 === peg$FAILED) {
                s1 = null;
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$parsecomments();
                if (s2 === peg$FAILED) {
                  s2 = null;
                }
                if (s2 !== peg$FAILED) {
                  s3 = peg$parsepgn();
                  if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c3(s1, s2, s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }

              return s0;
            }

            function peg$parsetags() {
              var s0, s1, s2, s3, s4, s5, s6, s7;

              s0 = peg$currPos;
              s1 = peg$parsews();
              if (s1 !== peg$FAILED) {
                s2 = peg$currPos;
                s3 = peg$parsetag();
                if (s3 !== peg$FAILED) {
                  s4 = [];
                  s5 = peg$currPos;
                  s6 = peg$parsews();
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parsetag();
                    if (s7 !== peg$FAILED) {
                      peg$savedPos = s5;
                      s6 = peg$c0(s3, s7);
                      s5 = s6;
                    } else {
                      peg$currPos = s5;
                      s5 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                  while (s5 !== peg$FAILED) {
                    s4.push(s5);
                    s5 = peg$currPos;
                    s6 = peg$parsews();
                    if (s6 !== peg$FAILED) {
                      s7 = peg$parsetag();
                      if (s7 !== peg$FAILED) {
                        peg$savedPos = s5;
                        s6 = peg$c0(s3, s7);
                        s5 = s6;
                      } else {
                        peg$currPos = s5;
                        s5 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s5;
                      s5 = peg$FAILED;
                    }
                  }
                  if (s4 !== peg$FAILED) {
                    peg$savedPos = s2;
                    s3 = peg$c4(s3, s4);
                    s2 = s3;
                  } else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
                if (s2 === peg$FAILED) {
                  s2 = null;
                }
                if (s2 !== peg$FAILED) {
                  s3 = peg$parsews();
                  if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c5(s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }

              return s0;
            }

            function peg$parsetag() {
              var s0, s1, s2, s3;

              s0 = peg$currPos;
              s1 = peg$parsebl();
              if (s1 !== peg$FAILED) {
                s2 = peg$parsetagKeyValue();
                if (s2 !== peg$FAILED) {
                  s3 = peg$parsebr();
                  if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c6(s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }

              return s0;
            }

            function peg$parsetagKeyValue() {
              var s0, s1, s2, s3;

              s0 = peg$currPos;
              s1 = peg$parseeventKey();
              if (s1 !== peg$FAILED) {
                s2 = peg$parsews();
                if (s2 !== peg$FAILED) {
                  s3 = peg$parsestring();
                  if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c7(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parsesiteKey();
                if (s1 !== peg$FAILED) {
                  s2 = peg$parsews();
                  if (s2 !== peg$FAILED) {
                    s3 = peg$parsestring();
                    if (s3 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c8(s3);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  s1 = peg$parsedateKey();
                  if (s1 !== peg$FAILED) {
                    s2 = peg$parsews();
                    if (s2 !== peg$FAILED) {
                      s3 = peg$parsedate();
                      if (s3 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c9(s3);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    s1 = peg$parseroundKey();
                    if (s1 !== peg$FAILED) {
                      s2 = peg$parsews();
                      if (s2 !== peg$FAILED) {
                        s3 = peg$parsestring();
                        if (s3 !== peg$FAILED) {
                          peg$savedPos = s0;
                          s1 = peg$c10(s3);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                    if (s0 === peg$FAILED) {
                      s0 = peg$currPos;
                      s1 = peg$parsewhiteTitleKey();
                      if (s1 !== peg$FAILED) {
                        s2 = peg$parsews();
                        if (s2 !== peg$FAILED) {
                          s3 = peg$parsestring();
                          if (s3 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c11(s3);
                            s0 = s1;
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                      if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        s1 = peg$parseblackTitleKey();
                        if (s1 !== peg$FAILED) {
                          s2 = peg$parsews();
                          if (s2 !== peg$FAILED) {
                            s3 = peg$parsestring();
                            if (s3 !== peg$FAILED) {
                              peg$savedPos = s0;
                              s1 = peg$c12(s3);
                              s0 = s1;
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                        if (s0 === peg$FAILED) {
                          s0 = peg$currPos;
                          s1 = peg$parsewhiteEloKey();
                          if (s1 !== peg$FAILED) {
                            s2 = peg$parsews();
                            if (s2 !== peg$FAILED) {
                              s3 = peg$parseintegerOrDash();
                              if (s3 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s1 = peg$c13(s3);
                                s0 = s1;
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                          if (s0 === peg$FAILED) {
                            s0 = peg$currPos;
                            s1 = peg$parseblackEloKey();
                            if (s1 !== peg$FAILED) {
                              s2 = peg$parsews();
                              if (s2 !== peg$FAILED) {
                                s3 = peg$parseintegerOrDash();
                                if (s3 !== peg$FAILED) {
                                  peg$savedPos = s0;
                                  s1 = peg$c14(s3);
                                  s0 = s1;
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                            if (s0 === peg$FAILED) {
                              s0 = peg$currPos;
                              s1 = peg$parsewhiteUSCFKey();
                              if (s1 !== peg$FAILED) {
                                s2 = peg$parsews();
                                if (s2 !== peg$FAILED) {
                                  s3 = peg$parseintegerString();
                                  if (s3 !== peg$FAILED) {
                                    peg$savedPos = s0;
                                    s1 = peg$c15(s3);
                                    s0 = s1;
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                              if (s0 === peg$FAILED) {
                                s0 = peg$currPos;
                                s1 = peg$parseblackUSCFKey();
                                if (s1 !== peg$FAILED) {
                                  s2 = peg$parsews();
                                  if (s2 !== peg$FAILED) {
                                    s3 = peg$parseintegerString();
                                    if (s3 !== peg$FAILED) {
                                      peg$savedPos = s0;
                                      s1 = peg$c16(s3);
                                      s0 = s1;
                                    } else {
                                      peg$currPos = s0;
                                      s0 = peg$FAILED;
                                    }
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                                if (s0 === peg$FAILED) {
                                  s0 = peg$currPos;
                                  s1 = peg$parsewhiteNAKey();
                                  if (s1 !== peg$FAILED) {
                                    s2 = peg$parsews();
                                    if (s2 !== peg$FAILED) {
                                      s3 = peg$parsestring();
                                      if (s3 !== peg$FAILED) {
                                        peg$savedPos = s0;
                                        s1 = peg$c17(s3);
                                        s0 = s1;
                                      } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                      }
                                    } else {
                                      peg$currPos = s0;
                                      s0 = peg$FAILED;
                                    }
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                  }
                                  if (s0 === peg$FAILED) {
                                    s0 = peg$currPos;
                                    s1 = peg$parseblackNAKey();
                                    if (s1 !== peg$FAILED) {
                                      s2 = peg$parsews();
                                      if (s2 !== peg$FAILED) {
                                        s3 = peg$parsestring();
                                        if (s3 !== peg$FAILED) {
                                          peg$savedPos = s0;
                                          s1 = peg$c18(s3);
                                          s0 = s1;
                                        } else {
                                          peg$currPos = s0;
                                          s0 = peg$FAILED;
                                        }
                                      } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                      }
                                    } else {
                                      peg$currPos = s0;
                                      s0 = peg$FAILED;
                                    }
                                    if (s0 === peg$FAILED) {
                                      s0 = peg$currPos;
                                      s1 = peg$parsewhiteTypeKey();
                                      if (s1 !== peg$FAILED) {
                                        s2 = peg$parsews();
                                        if (s2 !== peg$FAILED) {
                                          s3 = peg$parsestring();
                                          if (s3 !== peg$FAILED) {
                                            peg$savedPos = s0;
                                            s1 = peg$c19(s3);
                                            s0 = s1;
                                          } else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                          }
                                        } else {
                                          peg$currPos = s0;
                                          s0 = peg$FAILED;
                                        }
                                      } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                      }
                                      if (s0 === peg$FAILED) {
                                        s0 = peg$currPos;
                                        s1 = peg$parseblackTypeKey();
                                        if (s1 !== peg$FAILED) {
                                          s2 = peg$parsews();
                                          if (s2 !== peg$FAILED) {
                                            s3 = peg$parsestring();
                                            if (s3 !== peg$FAILED) {
                                              peg$savedPos = s0;
                                              s1 = peg$c20(s3);
                                              s0 = s1;
                                            } else {
                                              peg$currPos = s0;
                                              s0 = peg$FAILED;
                                            }
                                          } else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                          }
                                        } else {
                                          peg$currPos = s0;
                                          s0 = peg$FAILED;
                                        }
                                        if (s0 === peg$FAILED) {
                                          s0 = peg$currPos;
                                          s1 = peg$parsewhiteKey();
                                          if (s1 !== peg$FAILED) {
                                            s2 = peg$parsews();
                                            if (s2 !== peg$FAILED) {
                                              s3 = peg$parsestring();
                                              if (s3 !== peg$FAILED) {
                                                peg$savedPos = s0;
                                                s1 = peg$c21(s3);
                                                s0 = s1;
                                              } else {
                                                peg$currPos = s0;
                                                s0 = peg$FAILED;
                                              }
                                            } else {
                                              peg$currPos = s0;
                                              s0 = peg$FAILED;
                                            }
                                          } else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                          }
                                          if (s0 === peg$FAILED) {
                                            s0 = peg$currPos;
                                            s1 = peg$parseblackKey();
                                            if (s1 !== peg$FAILED) {
                                              s2 = peg$parsews();
                                              if (s2 !== peg$FAILED) {
                                                s3 = peg$parsestring();
                                                if (s3 !== peg$FAILED) {
                                                  peg$savedPos = s0;
                                                  s1 = peg$c22(s3);
                                                  s0 = s1;
                                                } else {
                                                  peg$currPos = s0;
                                                  s0 = peg$FAILED;
                                                }
                                              } else {
                                                peg$currPos = s0;
                                                s0 = peg$FAILED;
                                              }
                                            } else {
                                              peg$currPos = s0;
                                              s0 = peg$FAILED;
                                            }
                                            if (s0 === peg$FAILED) {
                                              s0 = peg$currPos;
                                              s1 = peg$parseresultKey();
                                              if (s1 !== peg$FAILED) {
                                                s2 = peg$parsews();
                                                if (s2 !== peg$FAILED) {
                                                  s3 = peg$parseresult();
                                                  if (s3 !== peg$FAILED) {
                                                    peg$savedPos = s0;
                                                    s1 = peg$c23(s3);
                                                    s0 = s1;
                                                  } else {
                                                    peg$currPos = s0;
                                                    s0 = peg$FAILED;
                                                  }
                                                } else {
                                                  peg$currPos = s0;
                                                  s0 = peg$FAILED;
                                                }
                                              } else {
                                                peg$currPos = s0;
                                                s0 = peg$FAILED;
                                              }
                                              if (s0 === peg$FAILED) {
                                                s0 = peg$currPos;
                                                s1 = peg$parseeventDateKey();
                                                if (s1 !== peg$FAILED) {
                                                  s2 = peg$parsews();
                                                  if (s2 !== peg$FAILED) {
                                                    s3 = peg$parsedate();
                                                    if (s3 !== peg$FAILED) {
                                                      peg$savedPos = s0;
                                                      s1 = peg$c24(s3);
                                                      s0 = s1;
                                                    } else {
                                                      peg$currPos = s0;
                                                      s0 = peg$FAILED;
                                                    }
                                                  } else {
                                                    peg$currPos = s0;
                                                    s0 = peg$FAILED;
                                                  }
                                                } else {
                                                  peg$currPos = s0;
                                                  s0 = peg$FAILED;
                                                }
                                                if (s0 === peg$FAILED) {
                                                  s0 = peg$currPos;
                                                  s1 = peg$parseeventSponsorKey();
                                                  if (s1 !== peg$FAILED) {
                                                    s2 = peg$parsews();
                                                    if (s2 !== peg$FAILED) {
                                                      s3 = peg$parsestring();
                                                      if (s3 !== peg$FAILED) {
                                                        peg$savedPos = s0;
                                                        s1 = peg$c25(s3);
                                                        s0 = s1;
                                                      } else {
                                                        peg$currPos = s0;
                                                        s0 = peg$FAILED;
                                                      }
                                                    } else {
                                                      peg$currPos = s0;
                                                      s0 = peg$FAILED;
                                                    }
                                                  } else {
                                                    peg$currPos = s0;
                                                    s0 = peg$FAILED;
                                                  }
                                                  if (s0 === peg$FAILED) {
                                                    s0 = peg$currPos;
                                                    s1 = peg$parsesectionKey();
                                                    if (s1 !== peg$FAILED) {
                                                      s2 = peg$parsews();
                                                      if (s2 !== peg$FAILED) {
                                                        s3 = peg$parsestring();
                                                        if (s3 !== peg$FAILED) {
                                                          peg$savedPos = s0;
                                                          s1 = peg$c26(s3);
                                                          s0 = s1;
                                                        } else {
                                                          peg$currPos = s0;
                                                          s0 = peg$FAILED;
                                                        }
                                                      } else {
                                                        peg$currPos = s0;
                                                        s0 = peg$FAILED;
                                                      }
                                                    } else {
                                                      peg$currPos = s0;
                                                      s0 = peg$FAILED;
                                                    }
                                                    if (s0 === peg$FAILED) {
                                                      s0 = peg$currPos;
                                                      s1 = peg$parsestageKey();
                                                      if (s1 !== peg$FAILED) {
                                                        s2 = peg$parsews();
                                                        if (s2 !== peg$FAILED) {
                                                          s3 = peg$parsestring();
                                                          if (s3 !== peg$FAILED) {
                                                            peg$savedPos = s0;
                                                            s1 = peg$c27(s3);
                                                            s0 = s1;
                                                          } else {
                                                            peg$currPos = s0;
                                                            s0 = peg$FAILED;
                                                          }
                                                        } else {
                                                          peg$currPos = s0;
                                                          s0 = peg$FAILED;
                                                        }
                                                      } else {
                                                        peg$currPos = s0;
                                                        s0 = peg$FAILED;
                                                      }
                                                      if (s0 === peg$FAILED) {
                                                        s0 = peg$currPos;
                                                        s1 = peg$parseboardKey();
                                                        if (s1 !== peg$FAILED) {
                                                          s2 = peg$parsews();
                                                          if (s2 !== peg$FAILED) {
                                                            s3 = peg$parseintegerString();
                                                            if (s3 !== peg$FAILED) {
                                                              peg$savedPos = s0;
                                                              s1 = peg$c28(s3);
                                                              s0 = s1;
                                                            } else {
                                                              peg$currPos = s0;
                                                              s0 = peg$FAILED;
                                                            }
                                                          } else {
                                                            peg$currPos = s0;
                                                            s0 = peg$FAILED;
                                                          }
                                                        } else {
                                                          peg$currPos = s0;
                                                          s0 = peg$FAILED;
                                                        }
                                                        if (s0 === peg$FAILED) {
                                                          s0 = peg$currPos;
                                                          s1 = peg$parseopeningKey();
                                                          if (s1 !== peg$FAILED) {
                                                            s2 = peg$parsews();
                                                            if (s2 !== peg$FAILED) {
                                                              s3 = peg$parsestring();
                                                              if (s3 !== peg$FAILED) {
                                                                peg$savedPos = s0;
                                                                s1 = peg$c29(s3);
                                                                s0 = s1;
                                                              } else {
                                                                peg$currPos = s0;
                                                                s0 = peg$FAILED;
                                                              }
                                                            } else {
                                                              peg$currPos = s0;
                                                              s0 = peg$FAILED;
                                                            }
                                                          } else {
                                                            peg$currPos = s0;
                                                            s0 = peg$FAILED;
                                                          }
                                                          if (s0 === peg$FAILED) {
                                                            s0 = peg$currPos;
                                                            s1 = peg$parsevariationKey();
                                                            if (s1 !== peg$FAILED) {
                                                              s2 = peg$parsews();
                                                              if (s2 !== peg$FAILED) {
                                                                s3 = peg$parsestring();
                                                                if (s3 !== peg$FAILED) {
                                                                  peg$savedPos = s0;
                                                                  s1 = peg$c30(s3);
                                                                  s0 = s1;
                                                                } else {
                                                                  peg$currPos = s0;
                                                                  s0 = peg$FAILED;
                                                                }
                                                              } else {
                                                                peg$currPos = s0;
                                                                s0 = peg$FAILED;
                                                              }
                                                            } else {
                                                              peg$currPos = s0;
                                                              s0 = peg$FAILED;
                                                            }
                                                            if (s0 === peg$FAILED) {
                                                              s0 = peg$currPos;
                                                              s1 = peg$parsesubVariationKey();
                                                              if (s1 !== peg$FAILED) {
                                                                s2 = peg$parsews();
                                                                if (s2 !== peg$FAILED) {
                                                                  s3 = peg$parsestring();
                                                                  if (s3 !== peg$FAILED) {
                                                                    peg$savedPos = s0;
                                                                    s1 = peg$c31(s3);
                                                                    s0 = s1;
                                                                  } else {
                                                                    peg$currPos = s0;
                                                                    s0 = peg$FAILED;
                                                                  }
                                                                } else {
                                                                  peg$currPos = s0;
                                                                  s0 = peg$FAILED;
                                                                }
                                                              } else {
                                                                peg$currPos = s0;
                                                                s0 = peg$FAILED;
                                                              }
                                                              if (s0 === peg$FAILED) {
                                                                s0 = peg$currPos;
                                                                s1 = peg$parseecoKey();
                                                                if (s1 !== peg$FAILED) {
                                                                  s2 = peg$parsews();
                                                                  if (s2 !== peg$FAILED) {
                                                                    s3 = peg$parsestring();
                                                                    if (s3 !== peg$FAILED) {
                                                                      peg$savedPos = s0;
                                                                      s1 = peg$c32(s3);
                                                                      s0 = s1;
                                                                    } else {
                                                                      peg$currPos = s0;
                                                                      s0 = peg$FAILED;
                                                                    }
                                                                  } else {
                                                                    peg$currPos = s0;
                                                                    s0 = peg$FAILED;
                                                                  }
                                                                } else {
                                                                  peg$currPos = s0;
                                                                  s0 = peg$FAILED;
                                                                }
                                                                if (s0 === peg$FAILED) {
                                                                  s0 = peg$currPos;
                                                                  s1 = peg$parsenicKey();
                                                                  if (s1 !== peg$FAILED) {
                                                                    s2 = peg$parsews();
                                                                    if (s2 !== peg$FAILED) {
                                                                      s3 = peg$parsestring();
                                                                      if (s3 !== peg$FAILED) {
                                                                        peg$savedPos = s0;
                                                                        s1 = peg$c33(s3);
                                                                        s0 = s1;
                                                                      } else {
                                                                        peg$currPos = s0;
                                                                        s0 = peg$FAILED;
                                                                      }
                                                                    } else {
                                                                      peg$currPos = s0;
                                                                      s0 = peg$FAILED;
                                                                    }
                                                                  } else {
                                                                    peg$currPos = s0;
                                                                    s0 = peg$FAILED;
                                                                  }
                                                                  if (s0 === peg$FAILED) {
                                                                    s0 = peg$currPos;
                                                                    s1 = peg$parsetimeKey();
                                                                    if (s1 !== peg$FAILED) {
                                                                      s2 = peg$parsews();
                                                                      if (s2 !== peg$FAILED) {
                                                                        s3 = peg$parsestring();
                                                                        if (s3 !== peg$FAILED) {
                                                                          peg$savedPos = s0;
                                                                          s1 = peg$c34(s3);
                                                                          s0 = s1;
                                                                        } else {
                                                                          peg$currPos = s0;
                                                                          s0 = peg$FAILED;
                                                                        }
                                                                      } else {
                                                                        peg$currPos = s0;
                                                                        s0 = peg$FAILED;
                                                                      }
                                                                    } else {
                                                                      peg$currPos = s0;
                                                                      s0 = peg$FAILED;
                                                                    }
                                                                    if (s0 === peg$FAILED) {
                                                                      s0 = peg$currPos;
                                                                      s1 = peg$parseutcTimeKey();
                                                                      if (s1 !== peg$FAILED) {
                                                                        s2 = peg$parsews();
                                                                        if (s2 !== peg$FAILED) {
                                                                          s3 = peg$parsestring();
                                                                          if (s3 !== peg$FAILED) {
                                                                            peg$savedPos = s0;
                                                                            s1 = peg$c35(s3);
                                                                            s0 = s1;
                                                                          } else {
                                                                            peg$currPos = s0;
                                                                            s0 = peg$FAILED;
                                                                          }
                                                                        } else {
                                                                          peg$currPos = s0;
                                                                          s0 = peg$FAILED;
                                                                        }
                                                                      } else {
                                                                        peg$currPos = s0;
                                                                        s0 = peg$FAILED;
                                                                      }
                                                                      if (s0 === peg$FAILED) {
                                                                        s0 = peg$currPos;
                                                                        s1 = peg$parseutcDateKey();
                                                                        if (s1 !== peg$FAILED) {
                                                                          s2 = peg$parsews();
                                                                          if (s2 !== peg$FAILED) {
                                                                            s3 = peg$parsestring();
                                                                            if (s3 !== peg$FAILED) {
                                                                              peg$savedPos = s0;
                                                                              s1 = peg$c36(s3);
                                                                              s0 = s1;
                                                                            } else {
                                                                              peg$currPos = s0;
                                                                              s0 = peg$FAILED;
                                                                            }
                                                                          } else {
                                                                            peg$currPos = s0;
                                                                            s0 = peg$FAILED;
                                                                          }
                                                                        } else {
                                                                          peg$currPos = s0;
                                                                          s0 = peg$FAILED;
                                                                        }
                                                                        if (s0 === peg$FAILED) {
                                                                          s0 = peg$currPos;
                                                                          s1 = peg$parsetimeControlKey();
                                                                          if (s1 !== peg$FAILED) {
                                                                            s2 = peg$parsews();
                                                                            if (s2 !== peg$FAILED) {
                                                                              s3 = peg$parsestring();
                                                                              if (s3 !== peg$FAILED) {
                                                                                peg$savedPos = s0;
                                                                                s1 = peg$c37(s3);
                                                                                s0 = s1;
                                                                              } else {
                                                                                peg$currPos = s0;
                                                                                s0 = peg$FAILED;
                                                                              }
                                                                            } else {
                                                                              peg$currPos = s0;
                                                                              s0 = peg$FAILED;
                                                                            }
                                                                          } else {
                                                                            peg$currPos = s0;
                                                                            s0 = peg$FAILED;
                                                                          }
                                                                          if (s0 === peg$FAILED) {
                                                                            s0 = peg$currPos;
                                                                            s1 = peg$parsesetUpKey();
                                                                            if (s1 !== peg$FAILED) {
                                                                              s2 = peg$parsews();
                                                                              if (s2 !== peg$FAILED) {
                                                                                s3 = peg$parsestring();
                                                                                if (s3 !== peg$FAILED) {
                                                                                  peg$savedPos = s0;
                                                                                  s1 = peg$c38(s3);
                                                                                  s0 = s1;
                                                                                } else {
                                                                                  peg$currPos = s0;
                                                                                  s0 = peg$FAILED;
                                                                                }
                                                                              } else {
                                                                                peg$currPos = s0;
                                                                                s0 = peg$FAILED;
                                                                              }
                                                                            } else {
                                                                              peg$currPos = s0;
                                                                              s0 = peg$FAILED;
                                                                            }
                                                                            if (s0 === peg$FAILED) {
                                                                              s0 = peg$currPos;
                                                                              s1 = peg$parsefenKey();
                                                                              if (s1 !== peg$FAILED) {
                                                                                s2 = peg$parsews();
                                                                                if (s2 !== peg$FAILED) {
                                                                                  s3 = peg$parsestring();
                                                                                  if (s3 !== peg$FAILED) {
                                                                                    peg$savedPos = s0;
                                                                                    s1 = peg$c39(s3);
                                                                                    s0 = s1;
                                                                                  } else {
                                                                                    peg$currPos = s0;
                                                                                    s0 = peg$FAILED;
                                                                                  }
                                                                                } else {
                                                                                  peg$currPos = s0;
                                                                                  s0 = peg$FAILED;
                                                                                }
                                                                              } else {
                                                                                peg$currPos = s0;
                                                                                s0 = peg$FAILED;
                                                                              }
                                                                              if (s0 === peg$FAILED) {
                                                                                s0 = peg$currPos;
                                                                                s1 = peg$parseterminationKey();
                                                                                if (s1 !== peg$FAILED) {
                                                                                  s2 = peg$parsews();
                                                                                  if (s2 !== peg$FAILED) {
                                                                                    s3 = peg$parsestring();
                                                                                    if (s3 !== peg$FAILED) {
                                                                                      peg$savedPos = s0;
                                                                                      s1 = peg$c40(s3);
                                                                                      s0 = s1;
                                                                                    } else {
                                                                                      peg$currPos = s0;
                                                                                      s0 = peg$FAILED;
                                                                                    }
                                                                                  } else {
                                                                                    peg$currPos = s0;
                                                                                    s0 = peg$FAILED;
                                                                                  }
                                                                                } else {
                                                                                  peg$currPos = s0;
                                                                                  s0 = peg$FAILED;
                                                                                }
                                                                                if (s0 === peg$FAILED) {
                                                                                  s0 = peg$currPos;
                                                                                  s1 = peg$parseanotatorKey();
                                                                                  if (s1 !== peg$FAILED) {
                                                                                    s2 = peg$parsews();
                                                                                    if (s2 !== peg$FAILED) {
                                                                                      s3 = peg$parsestring();
                                                                                      if (s3 !== peg$FAILED) {
                                                                                        peg$savedPos = s0;
                                                                                        s1 = peg$c41(s3);
                                                                                        s0 = s1;
                                                                                      } else {
                                                                                        peg$currPos = s0;
                                                                                        s0 = peg$FAILED;
                                                                                      }
                                                                                    } else {
                                                                                      peg$currPos = s0;
                                                                                      s0 = peg$FAILED;
                                                                                    }
                                                                                  } else {
                                                                                    peg$currPos = s0;
                                                                                    s0 = peg$FAILED;
                                                                                  }
                                                                                  if (s0 === peg$FAILED) {
                                                                                    s0 = peg$currPos;
                                                                                    s1 = peg$parsemodeKey();
                                                                                    if (s1 !== peg$FAILED) {
                                                                                      s2 = peg$parsews();
                                                                                      if (s2 !== peg$FAILED) {
                                                                                        s3 = peg$parsestring();
                                                                                        if (s3 !== peg$FAILED) {
                                                                                          peg$savedPos = s0;
                                                                                          s1 = peg$c42(s3);
                                                                                          s0 = s1;
                                                                                        } else {
                                                                                          peg$currPos = s0;
                                                                                          s0 = peg$FAILED;
                                                                                        }
                                                                                      } else {
                                                                                        peg$currPos = s0;
                                                                                        s0 = peg$FAILED;
                                                                                      }
                                                                                    } else {
                                                                                      peg$currPos = s0;
                                                                                      s0 = peg$FAILED;
                                                                                    }
                                                                                    if (s0 === peg$FAILED) {
                                                                                      s0 = peg$currPos;
                                                                                      s1 = peg$parseplyCountKey();
                                                                                      if (s1 !== peg$FAILED) {
                                                                                        s2 = peg$parsews();
                                                                                        if (s2 !== peg$FAILED) {
                                                                                          s3 = peg$parseintegerString();
                                                                                          if (s3 !== peg$FAILED) {
                                                                                            peg$savedPos = s0;
                                                                                            s1 = peg$c43(s3);
                                                                                            s0 = s1;
                                                                                          } else {
                                                                                            peg$currPos = s0;
                                                                                            s0 = peg$FAILED;
                                                                                          }
                                                                                        } else {
                                                                                          peg$currPos = s0;
                                                                                          s0 = peg$FAILED;
                                                                                        }
                                                                                      } else {
                                                                                        peg$currPos = s0;
                                                                                        s0 = peg$FAILED;
                                                                                      }
                                                                                      if (s0 === peg$FAILED) {
                                                                                        s0 = peg$currPos;
                                                                                        s1 = peg$parsestringNoQuot();
                                                                                        if (s1 !== peg$FAILED) {
                                                                                          s2 = peg$parsews();
                                                                                          if (s2 !== peg$FAILED) {
                                                                                            s3 = peg$parsestring();
                                                                                            if (s3 !== peg$FAILED) {
                                                                                              peg$savedPos = s0;
                                                                                              s1 = peg$c44(s1, s3);
                                                                                              s0 = s1;
                                                                                            } else {
                                                                                              peg$currPos = s0;
                                                                                              s0 = peg$FAILED;
                                                                                            }
                                                                                          } else {
                                                                                            peg$currPos = s0;
                                                                                            s0 = peg$FAILED;
                                                                                          }
                                                                                        } else {
                                                                                          peg$currPos = s0;
                                                                                          s0 = peg$FAILED;
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }

              return s0;
            }

            function peg$parseeventKey() {
              var s0;

              if (input.substr(peg$currPos, 5) === peg$c45) {
                s0 = peg$c45;
                peg$currPos += 5;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c46);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 5) === peg$c47) {
                  s0 = peg$c47;
                  peg$currPos += 5;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c48);
                  }
                }
              }

              return s0;
            }

            function peg$parsesiteKey() {
              var s0;

              if (input.substr(peg$currPos, 4) === peg$c49) {
                s0 = peg$c49;
                peg$currPos += 4;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c50);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 4) === peg$c51) {
                  s0 = peg$c51;
                  peg$currPos += 4;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c52);
                  }
                }
              }

              return s0;
            }

            function peg$parsedateKey() {
              var s0;

              if (input.substr(peg$currPos, 4) === peg$c53) {
                s0 = peg$c53;
                peg$currPos += 4;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c54);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 4) === peg$c55) {
                  s0 = peg$c55;
                  peg$currPos += 4;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c56);
                  }
                }
              }

              return s0;
            }

            function peg$parseroundKey() {
              var s0;

              if (input.substr(peg$currPos, 5) === peg$c57) {
                s0 = peg$c57;
                peg$currPos += 5;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c58);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 5) === peg$c59) {
                  s0 = peg$c59;
                  peg$currPos += 5;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c60);
                  }
                }
              }

              return s0;
            }

            function peg$parsewhiteKey() {
              var s0;

              if (input.substr(peg$currPos, 5) === peg$c61) {
                s0 = peg$c61;
                peg$currPos += 5;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c62);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 5) === peg$c61) {
                  s0 = peg$c61;
                  peg$currPos += 5;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c62);
                  }
                }
              }

              return s0;
            }

            function peg$parseblackKey() {
              var s0;

              if (input.substr(peg$currPos, 5) === peg$c63) {
                s0 = peg$c63;
                peg$currPos += 5;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c64);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 5) === peg$c65) {
                  s0 = peg$c65;
                  peg$currPos += 5;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c66);
                  }
                }
              }

              return s0;
            }

            function peg$parseresultKey() {
              var s0;

              if (input.substr(peg$currPos, 6) === peg$c67) {
                s0 = peg$c67;
                peg$currPos += 6;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c68);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 6) === peg$c69) {
                  s0 = peg$c69;
                  peg$currPos += 6;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c70);
                  }
                }
              }

              return s0;
            }

            function peg$parsewhiteTitleKey() {
              var s0;

              if (input.substr(peg$currPos, 10) === peg$c71) {
                s0 = peg$c71;
                peg$currPos += 10;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c72);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 10) === peg$c73) {
                  s0 = peg$c73;
                  peg$currPos += 10;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c74);
                  }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 10) === peg$c75) {
                    s0 = peg$c75;
                    peg$currPos += 10;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c76);
                    }
                  }
                }
              }

              return s0;
            }

            function peg$parseblackTitleKey() {
              var s0;

              if (input.substr(peg$currPos, 10) === peg$c77) {
                s0 = peg$c77;
                peg$currPos += 10;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c78);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 10) === peg$c79) {
                  s0 = peg$c79;
                  peg$currPos += 10;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c80);
                  }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 10) === peg$c81) {
                    s0 = peg$c81;
                    peg$currPos += 10;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c82);
                    }
                  }
                }
              }

              return s0;
            }

            function peg$parsewhiteEloKey() {
              var s0;

              if (input.substr(peg$currPos, 8) === peg$c83) {
                s0 = peg$c83;
                peg$currPos += 8;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c84);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 8) === peg$c85) {
                  s0 = peg$c85;
                  peg$currPos += 8;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c86);
                  }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 8) === peg$c87) {
                    s0 = peg$c87;
                    peg$currPos += 8;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c88);
                    }
                  }
                  if (s0 === peg$FAILED) {
                    if (input.substr(peg$currPos, 8) === peg$c89) {
                      s0 = peg$c89;
                      peg$currPos += 8;
                    } else {
                      s0 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c90);
                      }
                    }
                  }
                }
              }

              return s0;
            }

            function peg$parseblackEloKey() {
              var s0;

              if (input.substr(peg$currPos, 8) === peg$c91) {
                s0 = peg$c91;
                peg$currPos += 8;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c92);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 8) === peg$c93) {
                  s0 = peg$c93;
                  peg$currPos += 8;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c94);
                  }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 8) === peg$c95) {
                    s0 = peg$c95;
                    peg$currPos += 8;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c96);
                    }
                  }
                  if (s0 === peg$FAILED) {
                    if (input.substr(peg$currPos, 8) === peg$c97) {
                      s0 = peg$c97;
                      peg$currPos += 8;
                    } else {
                      s0 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c98);
                      }
                    }
                  }
                }
              }

              return s0;
            }

            function peg$parsewhiteUSCFKey() {
              var s0;

              if (input.substr(peg$currPos, 9) === peg$c99) {
                s0 = peg$c99;
                peg$currPos += 9;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c100);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 9) === peg$c101) {
                  s0 = peg$c101;
                  peg$currPos += 9;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c102);
                  }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 9) === peg$c103) {
                    s0 = peg$c103;
                    peg$currPos += 9;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c104);
                    }
                  }
                  if (s0 === peg$FAILED) {
                    if (input.substr(peg$currPos, 9) === peg$c105) {
                      s0 = peg$c105;
                      peg$currPos += 9;
                    } else {
                      s0 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c106);
                      }
                    }
                  }
                }
              }

              return s0;
            }

            function peg$parseblackUSCFKey() {
              var s0;

              if (input.substr(peg$currPos, 9) === peg$c107) {
                s0 = peg$c107;
                peg$currPos += 9;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c108);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 9) === peg$c109) {
                  s0 = peg$c109;
                  peg$currPos += 9;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c110);
                  }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 9) === peg$c111) {
                    s0 = peg$c111;
                    peg$currPos += 9;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c112);
                    }
                  }
                  if (s0 === peg$FAILED) {
                    if (input.substr(peg$currPos, 9) === peg$c113) {
                      s0 = peg$c113;
                      peg$currPos += 9;
                    } else {
                      s0 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c114);
                      }
                    }
                  }
                }
              }

              return s0;
            }

            function peg$parsewhiteNAKey() {
              var s0;

              if (input.substr(peg$currPos, 7) === peg$c115) {
                s0 = peg$c115;
                peg$currPos += 7;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c116);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 7) === peg$c117) {
                  s0 = peg$c117;
                  peg$currPos += 7;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c118);
                  }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 7) === peg$c119) {
                    s0 = peg$c119;
                    peg$currPos += 7;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c120);
                    }
                  }
                  if (s0 === peg$FAILED) {
                    if (input.substr(peg$currPos, 7) === peg$c121) {
                      s0 = peg$c121;
                      peg$currPos += 7;
                    } else {
                      s0 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c122);
                      }
                    }
                  }
                }
              }

              return s0;
            }

            function peg$parseblackNAKey() {
              var s0;

              if (input.substr(peg$currPos, 7) === peg$c123) {
                s0 = peg$c123;
                peg$currPos += 7;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c124);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 7) === peg$c125) {
                  s0 = peg$c125;
                  peg$currPos += 7;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c126);
                  }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 7) === peg$c127) {
                    s0 = peg$c127;
                    peg$currPos += 7;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c128);
                    }
                  }
                  if (s0 === peg$FAILED) {
                    if (input.substr(peg$currPos, 7) === peg$c129) {
                      s0 = peg$c129;
                      peg$currPos += 7;
                    } else {
                      s0 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c130);
                      }
                    }
                  }
                }
              }

              return s0;
            }

            function peg$parsewhiteTypeKey() {
              var s0;

              if (input.substr(peg$currPos, 9) === peg$c131) {
                s0 = peg$c131;
                peg$currPos += 9;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c132);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 9) === peg$c133) {
                  s0 = peg$c133;
                  peg$currPos += 9;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c134);
                  }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 9) === peg$c135) {
                    s0 = peg$c135;
                    peg$currPos += 9;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c136);
                    }
                  }
                }
              }

              return s0;
            }

            function peg$parseblackTypeKey() {
              var s0;

              if (input.substr(peg$currPos, 9) === peg$c137) {
                s0 = peg$c137;
                peg$currPos += 9;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c138);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 9) === peg$c139) {
                  s0 = peg$c139;
                  peg$currPos += 9;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c140);
                  }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 9) === peg$c141) {
                    s0 = peg$c141;
                    peg$currPos += 9;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c142);
                    }
                  }
                }
              }

              return s0;
            }

            function peg$parseeventDateKey() {
              var s0;

              if (input.substr(peg$currPos, 9) === peg$c143) {
                s0 = peg$c143;
                peg$currPos += 9;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c144);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 9) === peg$c145) {
                  s0 = peg$c145;
                  peg$currPos += 9;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c146);
                  }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 9) === peg$c147) {
                    s0 = peg$c147;
                    peg$currPos += 9;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c148);
                    }
                  }
                }
              }

              return s0;
            }

            function peg$parseeventSponsorKey() {
              var s0;

              if (input.substr(peg$currPos, 12) === peg$c149) {
                s0 = peg$c149;
                peg$currPos += 12;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c150);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 12) === peg$c151) {
                  s0 = peg$c151;
                  peg$currPos += 12;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c152);
                  }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 12) === peg$c153) {
                    s0 = peg$c153;
                    peg$currPos += 12;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c154);
                    }
                  }
                }
              }

              return s0;
            }

            function peg$parsesectionKey() {
              var s0;

              if (input.substr(peg$currPos, 7) === peg$c155) {
                s0 = peg$c155;
                peg$currPos += 7;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c156);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 7) === peg$c157) {
                  s0 = peg$c157;
                  peg$currPos += 7;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c158);
                  }
                }
              }

              return s0;
            }

            function peg$parsestageKey() {
              var s0;

              if (input.substr(peg$currPos, 5) === peg$c159) {
                s0 = peg$c159;
                peg$currPos += 5;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c160);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 5) === peg$c161) {
                  s0 = peg$c161;
                  peg$currPos += 5;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c162);
                  }
                }
              }

              return s0;
            }

            function peg$parseboardKey() {
              var s0;

              if (input.substr(peg$currPos, 5) === peg$c163) {
                s0 = peg$c163;
                peg$currPos += 5;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c164);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 5) === peg$c165) {
                  s0 = peg$c165;
                  peg$currPos += 5;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c166);
                  }
                }
              }

              return s0;
            }

            function peg$parseopeningKey() {
              var s0;

              if (input.substr(peg$currPos, 7) === peg$c167) {
                s0 = peg$c167;
                peg$currPos += 7;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c168);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 7) === peg$c169) {
                  s0 = peg$c169;
                  peg$currPos += 7;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c170);
                  }
                }
              }

              return s0;
            }

            function peg$parsevariationKey() {
              var s0;

              if (input.substr(peg$currPos, 9) === peg$c171) {
                s0 = peg$c171;
                peg$currPos += 9;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c172);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 9) === peg$c173) {
                  s0 = peg$c173;
                  peg$currPos += 9;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c174);
                  }
                }
              }

              return s0;
            }

            function peg$parsesubVariationKey() {
              var s0;

              if (input.substr(peg$currPos, 12) === peg$c175) {
                s0 = peg$c175;
                peg$currPos += 12;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c176);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 12) === peg$c177) {
                  s0 = peg$c177;
                  peg$currPos += 12;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c178);
                  }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 12) === peg$c179) {
                    s0 = peg$c179;
                    peg$currPos += 12;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c180);
                    }
                  }
                }
              }

              return s0;
            }

            function peg$parseecoKey() {
              var s0;

              if (input.substr(peg$currPos, 3) === peg$c181) {
                s0 = peg$c181;
                peg$currPos += 3;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c182);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 3) === peg$c183) {
                  s0 = peg$c183;
                  peg$currPos += 3;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c184);
                  }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 3) === peg$c185) {
                    s0 = peg$c185;
                    peg$currPos += 3;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c186);
                    }
                  }
                }
              }

              return s0;
            }

            function peg$parsenicKey() {
              var s0;

              if (input.substr(peg$currPos, 3) === peg$c187) {
                s0 = peg$c187;
                peg$currPos += 3;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c188);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 3) === peg$c189) {
                  s0 = peg$c189;
                  peg$currPos += 3;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c190);
                  }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 3) === peg$c191) {
                    s0 = peg$c191;
                    peg$currPos += 3;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c192);
                    }
                  }
                }
              }

              return s0;
            }

            function peg$parsetimeKey() {
              var s0;

              if (input.substr(peg$currPos, 4) === peg$c193) {
                s0 = peg$c193;
                peg$currPos += 4;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c194);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 4) === peg$c195) {
                  s0 = peg$c195;
                  peg$currPos += 4;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c196);
                  }
                }
              }

              return s0;
            }

            function peg$parseutcTimeKey() {
              var s0;

              if (input.substr(peg$currPos, 7) === peg$c197) {
                s0 = peg$c197;
                peg$currPos += 7;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c198);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 7) === peg$c199) {
                  s0 = peg$c199;
                  peg$currPos += 7;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c200);
                  }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 7) === peg$c201) {
                    s0 = peg$c201;
                    peg$currPos += 7;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c202);
                    }
                  }
                  if (s0 === peg$FAILED) {
                    if (input.substr(peg$currPos, 7) === peg$c203) {
                      s0 = peg$c203;
                      peg$currPos += 7;
                    } else {
                      s0 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c204);
                      }
                    }
                    if (s0 === peg$FAILED) {
                      if (input.substr(peg$currPos, 7) === peg$c205) {
                        s0 = peg$c205;
                        peg$currPos += 7;
                      } else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c206);
                        }
                      }
                    }
                  }
                }
              }

              return s0;
            }

            function peg$parseutcDateKey() {
              var s0;

              if (input.substr(peg$currPos, 7) === peg$c207) {
                s0 = peg$c207;
                peg$currPos += 7;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c208);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 7) === peg$c209) {
                  s0 = peg$c209;
                  peg$currPos += 7;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c210);
                  }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 7) === peg$c211) {
                    s0 = peg$c211;
                    peg$currPos += 7;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c212);
                    }
                  }
                  if (s0 === peg$FAILED) {
                    if (input.substr(peg$currPos, 7) === peg$c213) {
                      s0 = peg$c213;
                      peg$currPos += 7;
                    } else {
                      s0 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c214);
                      }
                    }
                    if (s0 === peg$FAILED) {
                      if (input.substr(peg$currPos, 7) === peg$c215) {
                        s0 = peg$c215;
                        peg$currPos += 7;
                      } else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c216);
                        }
                      }
                    }
                  }
                }
              }

              return s0;
            }

            function peg$parsetimeControlKey() {
              var s0;

              if (input.substr(peg$currPos, 11) === peg$c217) {
                s0 = peg$c217;
                peg$currPos += 11;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c218);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 11) === peg$c219) {
                  s0 = peg$c219;
                  peg$currPos += 11;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c220);
                  }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 11) === peg$c221) {
                    s0 = peg$c221;
                    peg$currPos += 11;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c222);
                    }
                  }
                }
              }

              return s0;
            }

            function peg$parsesetUpKey() {
              var s0;

              if (input.substr(peg$currPos, 5) === peg$c223) {
                s0 = peg$c223;
                peg$currPos += 5;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c224);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 5) === peg$c225) {
                  s0 = peg$c225;
                  peg$currPos += 5;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c226);
                  }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 5) === peg$c227) {
                    s0 = peg$c227;
                    peg$currPos += 5;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c228);
                    }
                  }
                }
              }

              return s0;
            }

            function peg$parsefenKey() {
              var s0;

              if (input.substr(peg$currPos, 3) === peg$c229) {
                s0 = peg$c229;
                peg$currPos += 3;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c230);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 3) === peg$c231) {
                  s0 = peg$c231;
                  peg$currPos += 3;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c232);
                  }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 3) === peg$c233) {
                    s0 = peg$c233;
                    peg$currPos += 3;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c234);
                    }
                  }
                }
              }

              return s0;
            }

            function peg$parseterminationKey() {
              var s0;

              if (input.substr(peg$currPos, 11) === peg$c235) {
                s0 = peg$c235;
                peg$currPos += 11;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c236);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 11) === peg$c237) {
                  s0 = peg$c237;
                  peg$currPos += 11;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c238);
                  }
                }
              }

              return s0;
            }

            function peg$parseanotatorKey() {
              var s0;

              if (input.substr(peg$currPos, 9) === peg$c239) {
                s0 = peg$c239;
                peg$currPos += 9;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c240);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 9) === peg$c241) {
                  s0 = peg$c241;
                  peg$currPos += 9;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c242);
                  }
                }
              }

              return s0;
            }

            function peg$parsemodeKey() {
              var s0;

              if (input.substr(peg$currPos, 4) === peg$c243) {
                s0 = peg$c243;
                peg$currPos += 4;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c244);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 4) === peg$c245) {
                  s0 = peg$c245;
                  peg$currPos += 4;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c246);
                  }
                }
              }

              return s0;
            }

            function peg$parseplyCountKey() {
              var s0;

              if (input.substr(peg$currPos, 8) === peg$c247) {
                s0 = peg$c247;
                peg$currPos += 8;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c248);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 8) === peg$c249) {
                  s0 = peg$c249;
                  peg$currPos += 8;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c250);
                  }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 8) === peg$c251) {
                    s0 = peg$c251;
                    peg$currPos += 8;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c252);
                    }
                  }
                }
              }

              return s0;
            }

            function peg$parsews() {
              var s0, s1;

              peg$silentFails++;
              s0 = [];
              if (peg$c254.test(input.charAt(peg$currPos))) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c255);
                }
              }
              while (s1 !== peg$FAILED) {
                s0.push(s1);
                if (peg$c254.test(input.charAt(peg$currPos))) {
                  s1 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c255);
                  }
                }
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c253);
                }
              }

              return s0;
            }

            function peg$parsewsp() {
              var s0, s1;

              s0 = [];
              if (peg$c254.test(input.charAt(peg$currPos))) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c255);
                }
              }
              if (s1 !== peg$FAILED) {
                while (s1 !== peg$FAILED) {
                  s0.push(s1);
                  if (peg$c254.test(input.charAt(peg$currPos))) {
                    s1 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c255);
                    }
                  }
                }
              } else {
                s0 = peg$FAILED;
              }

              return s0;
            }

            function peg$parseeol() {
              var s0, s1;

              s0 = [];
              if (peg$c256.test(input.charAt(peg$currPos))) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c257);
                }
              }
              if (s1 !== peg$FAILED) {
                while (s1 !== peg$FAILED) {
                  s0.push(s1);
                  if (peg$c256.test(input.charAt(peg$currPos))) {
                    s1 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c257);
                    }
                  }
                }
              } else {
                s0 = peg$FAILED;
              }

              return s0;
            }

            function peg$parsestring() {
              var s0, s1, s2, s3;

              peg$silentFails++;
              s0 = peg$currPos;
              s1 = peg$parsequotation_mark();
              if (s1 !== peg$FAILED) {
                s2 = [];
                s3 = peg$parsechar();
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  s3 = peg$parsechar();
                }
                if (s2 !== peg$FAILED) {
                  s3 = peg$parsequotation_mark();
                  if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c259(s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c258);
                }
              }

              return s0;
            }

            function peg$parsestringNoQuot() {
              var s0, s1, s2;

              s0 = peg$currPos;
              s1 = [];
              if (peg$c260.test(input.charAt(peg$currPos))) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c261);
                }
              }
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                if (peg$c260.test(input.charAt(peg$currPos))) {
                  s2 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c261);
                  }
                }
              }
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c259(s1);
              }
              s0 = s1;

              return s0;
            }

            function peg$parsequotation_mark() {
              var s0;

              if (input.charCodeAt(peg$currPos) === 34) {
                s0 = peg$c262;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c263);
                }
              }

              return s0;
            }

            function peg$parsechar() {
              var s0;

              if (peg$c264.test(input.charAt(peg$currPos))) {
                s0 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c265);
                }
              }

              return s0;
            }

            function peg$parsedate() {
              var s0, s1, s2, s3, s4, s5, s6, s7, s8;

              s0 = peg$currPos;
              s1 = peg$parsequotation_mark();
              if (s1 !== peg$FAILED) {
                s2 = peg$currPos;
                if (peg$c266.test(input.charAt(peg$currPos))) {
                  s3 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c267);
                  }
                }
                if (s3 !== peg$FAILED) {
                  if (peg$c266.test(input.charAt(peg$currPos))) {
                    s4 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c267);
                    }
                  }
                  if (s4 !== peg$FAILED) {
                    if (peg$c266.test(input.charAt(peg$currPos))) {
                      s5 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s5 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c267);
                      }
                    }
                    if (s5 !== peg$FAILED) {
                      if (peg$c266.test(input.charAt(peg$currPos))) {
                        s6 = input.charAt(peg$currPos);
                        peg$currPos++;
                      } else {
                        s6 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c267);
                        }
                      }
                      if (s6 !== peg$FAILED) {
                        s3 = [s3, s4, s5, s6];
                        s2 = s3;
                      } else {
                        peg$currPos = s2;
                        s2 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s2;
                      s2 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 46) {
                    s3 = peg$c268;
                    peg$currPos++;
                  } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c269);
                    }
                  }
                  if (s3 !== peg$FAILED) {
                    s4 = peg$currPos;
                    if (peg$c266.test(input.charAt(peg$currPos))) {
                      s5 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s5 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c267);
                      }
                    }
                    if (s5 !== peg$FAILED) {
                      if (peg$c266.test(input.charAt(peg$currPos))) {
                        s6 = input.charAt(peg$currPos);
                        peg$currPos++;
                      } else {
                        s6 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c267);
                        }
                      }
                      if (s6 !== peg$FAILED) {
                        s5 = [s5, s6];
                        s4 = s5;
                      } else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s4;
                      s4 = peg$FAILED;
                    }
                    if (s4 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 46) {
                        s5 = peg$c268;
                        peg$currPos++;
                      } else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c269);
                        }
                      }
                      if (s5 !== peg$FAILED) {
                        s6 = peg$currPos;
                        if (peg$c266.test(input.charAt(peg$currPos))) {
                          s7 = input.charAt(peg$currPos);
                          peg$currPos++;
                        } else {
                          s7 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c267);
                          }
                        }
                        if (s7 !== peg$FAILED) {
                          if (peg$c266.test(input.charAt(peg$currPos))) {
                            s8 = input.charAt(peg$currPos);
                            peg$currPos++;
                          } else {
                            s8 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$c267);
                            }
                          }
                          if (s8 !== peg$FAILED) {
                            s7 = [s7, s8];
                            s6 = s7;
                          } else {
                            peg$currPos = s6;
                            s6 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s6;
                          s6 = peg$FAILED;
                        }
                        if (s6 !== peg$FAILED) {
                          s7 = peg$parsequotation_mark();
                          if (s7 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c270(s2, s4, s6);
                            s0 = s1;
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }

              return s0;
            }

            function peg$parseresult() {
              var s0, s1, s2, s3;

              s0 = peg$currPos;
              s1 = peg$parsequotation_mark();
              if (s1 !== peg$FAILED) {
                s2 = peg$parseinner_result();
                if (s2 !== peg$FAILED) {
                  s3 = peg$parsequotation_mark();
                  if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c271(s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }

              return s0;
            }

            function peg$parseinner_result() {
              var s0, s1;

              s0 = peg$currPos;
              if (input.substr(peg$currPos, 3) === peg$c272) {
                s1 = peg$c272;
                peg$currPos += 3;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c273);
                }
              }
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c274(s1);
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 3) === peg$c275) {
                  s1 = peg$c275;
                  peg$currPos += 3;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c276);
                  }
                }
                if (s1 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c271(s1);
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  if (input.substr(peg$currPos, 3) === peg$c277) {
                    s1 = peg$c277;
                    peg$currPos += 3;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c278);
                    }
                  }
                  if (s1 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c271(s1);
                  }
                  s0 = s1;
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 3) === peg$c279) {
                      s1 = peg$c279;
                      peg$currPos += 3;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c280);
                      }
                    }
                    if (s1 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c271(s1);
                    }
                    s0 = s1;
                    if (s0 === peg$FAILED) {
                      s0 = peg$currPos;
                      if (input.substr(peg$currPos, 7) === peg$c281) {
                        s1 = peg$c281;
                        peg$currPos += 7;
                      } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c282);
                        }
                      }
                      if (s1 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c271(s1);
                      }
                      s0 = s1;
                      if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        if (input.charCodeAt(peg$currPos) === 42) {
                          s1 = peg$c283;
                          peg$currPos++;
                        } else {
                          s1 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c284);
                          }
                        }
                        if (s1 !== peg$FAILED) {
                          peg$savedPos = s0;
                          s1 = peg$c271(s1);
                        }
                        s0 = s1;
                      }
                    }
                  }
                }
              }

              return s0;
            }

            function peg$parseintegerOrDash() {
              var s0, s1, s2, s3;

              s0 = peg$parseintegerString();
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parsequotation_mark();
                if (s1 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 45) {
                    s2 = peg$c285;
                    peg$currPos++;
                  } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c286);
                    }
                  }
                  if (s2 !== peg$FAILED) {
                    s3 = peg$parsequotation_mark();
                    if (s3 !== peg$FAILED) {
                      s1 = [s1, s2, s3];
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              }

              return s0;
            }

            function peg$parseintegerString() {
              var s0, s1, s2, s3;

              s0 = peg$currPos;
              s1 = peg$parsequotation_mark();
              if (s1 !== peg$FAILED) {
                s2 = [];
                if (peg$c287.test(input.charAt(peg$currPos))) {
                  s3 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c288);
                  }
                }
                if (s3 !== peg$FAILED) {
                  while (s3 !== peg$FAILED) {
                    s2.push(s3);
                    if (peg$c287.test(input.charAt(peg$currPos))) {
                      s3 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s3 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c288);
                      }
                    }
                  }
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s3 = peg$parsequotation_mark();
                  if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c289(s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }

              return s0;
            }

            function peg$parsepgn() {
              var s0, s1, s2;

              s0 = peg$currPos;
              s1 = peg$parsepgnStartWhite();
              if (s1 !== peg$FAILED) {
                s2 = peg$parsepgnBlack();
                if (s2 === peg$FAILED) {
                  s2 = null;
                }
                if (s2 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c290(s1, s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parsepgnStartBlack();
                if (s1 !== peg$FAILED) {
                  s2 = peg$parsepgnWhite();
                  if (s2 === peg$FAILED) {
                    s2 = null;
                  }
                  if (s2 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c291(s1, s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  s1 = peg$parsews();
                  if (s1 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c292();
                  }
                  s0 = s1;
                }
              }

              return s0;
            }

            function peg$parsepgnStartWhite() {
              var s0, s1;

              s0 = peg$currPos;
              s1 = peg$parsepgnWhite();
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c293(s1);
              }
              s0 = s1;

              return s0;
            }

            function peg$parsepgnStartBlack() {
              var s0, s1;

              s0 = peg$currPos;
              s1 = peg$parsepgnBlack();
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c294(s1);
              }
              s0 = s1;

              return s0;
            }

            function peg$parsepgnWhite() {
              var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;

              s0 = peg$currPos;
              s1 = peg$parsews();
              if (s1 !== peg$FAILED) {
                s2 = peg$parsecomments();
                if (s2 === peg$FAILED) {
                  s2 = null;
                }
                if (s2 !== peg$FAILED) {
                  s3 = peg$parsews();
                  if (s3 !== peg$FAILED) {
                    s4 = peg$parsemoveNumber();
                    if (s4 === peg$FAILED) {
                      s4 = null;
                    }
                    if (s4 !== peg$FAILED) {
                      s5 = peg$parsews();
                      if (s5 !== peg$FAILED) {
                        s6 = peg$parsehalfMove();
                        if (s6 !== peg$FAILED) {
                          s7 = peg$parsews();
                          if (s7 !== peg$FAILED) {
                            s8 = peg$parsenags();
                            if (s8 === peg$FAILED) {
                              s8 = null;
                            }
                            if (s8 !== peg$FAILED) {
                              s9 = peg$parsews();
                              if (s9 !== peg$FAILED) {
                                s10 = peg$parsecomments();
                                if (s10 === peg$FAILED) {
                                  s10 = null;
                                }
                                if (s10 !== peg$FAILED) {
                                  s11 = peg$parsews();
                                  if (s11 !== peg$FAILED) {
                                    s12 = peg$parsevariationWhite();
                                    if (s12 === peg$FAILED) {
                                      s12 = null;
                                    }
                                    if (s12 !== peg$FAILED) {
                                      s13 = peg$parsepgnBlack();
                                      if (s13 === peg$FAILED) {
                                        s13 = null;
                                      }
                                      if (s13 !== peg$FAILED) {
                                        peg$savedPos = s0;
                                        s1 = peg$c295(s2, s4, s6, s8, s10, s12, s13);
                                        s0 = s1;
                                      } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                      }
                                    } else {
                                      peg$currPos = s0;
                                      s0 = peg$FAILED;
                                    }
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$parseendGame();
              }

              return s0;
            }

            function peg$parsepgnBlack() {
              var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14;

              s0 = peg$currPos;
              s1 = peg$parsews();
              if (s1 !== peg$FAILED) {
                s2 = peg$parsecomments();
                if (s2 === peg$FAILED) {
                  s2 = null;
                }
                if (s2 !== peg$FAILED) {
                  s3 = peg$parsews();
                  if (s3 !== peg$FAILED) {
                    s4 = peg$parsemoveNumber();
                    if (s4 === peg$FAILED) {
                      s4 = null;
                    }
                    if (s4 !== peg$FAILED) {
                      s5 = peg$parsews();
                      if (s5 !== peg$FAILED) {
                        s6 = peg$parsehalfMove();
                        if (s6 !== peg$FAILED) {
                          s7 = peg$parsews();
                          if (s7 !== peg$FAILED) {
                            s8 = peg$parsenags();
                            if (s8 === peg$FAILED) {
                              s8 = null;
                            }
                            if (s8 !== peg$FAILED) {
                              s9 = peg$parsews();
                              if (s9 !== peg$FAILED) {
                                s10 = peg$parsecomments();
                                if (s10 === peg$FAILED) {
                                  s10 = null;
                                }
                                if (s10 !== peg$FAILED) {
                                  s11 = peg$parsews();
                                  if (s11 !== peg$FAILED) {
                                    s12 = peg$parsews();
                                    if (s12 !== peg$FAILED) {
                                      s13 = peg$parsevariationBlack();
                                      if (s13 === peg$FAILED) {
                                        s13 = null;
                                      }
                                      if (s13 !== peg$FAILED) {
                                        s14 = peg$parsepgnWhite();
                                        if (s14 === peg$FAILED) {
                                          s14 = null;
                                        }
                                        if (s14 !== peg$FAILED) {
                                          peg$savedPos = s0;
                                          s1 = peg$c296(s2, s4, s6, s8, s10, s13, s14);
                                          s0 = s1;
                                        } else {
                                          peg$currPos = s0;
                                          s0 = peg$FAILED;
                                        }
                                      } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                      }
                                    } else {
                                      peg$currPos = s0;
                                      s0 = peg$FAILED;
                                    }
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$parseendGame();
              }

              return s0;
            }

            function peg$parseendGame() {
              var s0, s1;

              s0 = peg$currPos;
              if (input.substr(peg$currPos, 3) === peg$c275) {
                s1 = peg$c275;
                peg$currPos += 3;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c276);
                }
              }
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c297();
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 3) === peg$c279) {
                  s1 = peg$c279;
                  peg$currPos += 3;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c280);
                  }
                }
                if (s1 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c298();
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  if (input.substr(peg$currPos, 3) === peg$c272) {
                    s1 = peg$c272;
                    peg$currPos += 3;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c273);
                    }
                  }
                  if (s1 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c299();
                  }
                  s0 = s1;
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 3) === peg$c277) {
                      s1 = peg$c277;
                      peg$currPos += 3;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c278);
                      }
                    }
                    if (s1 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c300();
                    }
                    s0 = s1;
                    if (s0 === peg$FAILED) {
                      s0 = peg$currPos;
                      if (input.substr(peg$currPos, 7) === peg$c281) {
                        s1 = peg$c281;
                        peg$currPos += 7;
                      } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c282);
                        }
                      }
                      if (s1 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c301();
                      }
                      s0 = s1;
                      if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        if (input.charCodeAt(peg$currPos) === 42) {
                          s1 = peg$c283;
                          peg$currPos++;
                        } else {
                          s1 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c284);
                          }
                        }
                        if (s1 !== peg$FAILED) {
                          peg$savedPos = s0;
                          s1 = peg$c302();
                        }
                        s0 = s1;
                      }
                    }
                  }
                }
              }

              return s0;
            }

            function peg$parsecomments() {
              var s0, s1, s2, s3, s4, s5;

              s0 = peg$currPos;
              s1 = peg$parsecomment();
              if (s1 !== peg$FAILED) {
                s2 = [];
                s3 = peg$currPos;
                s4 = peg$parsews();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parsecomment();
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s3;
                    s4 = peg$c303(s1, s5);
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  s3 = peg$currPos;
                  s4 = peg$parsews();
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parsecomment();
                    if (s5 !== peg$FAILED) {
                      peg$savedPos = s3;
                      s4 = peg$c303(s1, s5);
                      s3 = s4;
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                }
                if (s2 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c304(s1, s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }

              return s0;
            }

            function peg$parsecomment() {
              var s0, s1, s2, s3;

              s0 = peg$currPos;
              s1 = peg$parsecl();
              if (s1 !== peg$FAILED) {
                s2 = peg$parseinnerComment();
                if (s2 !== peg$FAILED) {
                  s3 = peg$parsecr();
                  if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c305(s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parsecommentEndOfLine();
                if (s1 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c306(s1);
                }
                s0 = s1;
              }

              return s0;
            }

            function peg$parseinnerComment() {
              var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;

              s0 = peg$currPos;
              s1 = peg$parsews();
              if (s1 !== peg$FAILED) {
                s2 = peg$parsebl();
                if (s2 !== peg$FAILED) {
                  if (input.substr(peg$currPos, 4) === peg$c307) {
                    s3 = peg$c307;
                    peg$currPos += 4;
                  } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c308);
                    }
                  }
                  if (s3 !== peg$FAILED) {
                    s4 = peg$parsewsp();
                    if (s4 !== peg$FAILED) {
                      s5 = peg$parsecolorFields();
                      if (s5 !== peg$FAILED) {
                        s6 = peg$parsews();
                        if (s6 !== peg$FAILED) {
                          s7 = peg$parsebr();
                          if (s7 !== peg$FAILED) {
                            s8 = [];
                            s9 = peg$currPos;
                            s10 = peg$parseinnerComment();
                            if (s10 !== peg$FAILED) {
                              peg$savedPos = s9;
                              s10 = peg$c309(s5, s10);
                            }
                            s9 = s10;
                            while (s9 !== peg$FAILED) {
                              s8.push(s9);
                              s9 = peg$currPos;
                              s10 = peg$parseinnerComment();
                              if (s10 !== peg$FAILED) {
                                peg$savedPos = s9;
                                s10 = peg$c309(s5, s10);
                              }
                              s9 = s10;
                            }
                            if (s8 !== peg$FAILED) {
                              peg$savedPos = s0;
                              s1 = peg$c310(s5, s8);
                              s0 = s1;
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parsews();
                if (s1 !== peg$FAILED) {
                  s2 = peg$parsebl();
                  if (s2 !== peg$FAILED) {
                    if (input.substr(peg$currPos, 4) === peg$c311) {
                      s3 = peg$c311;
                      peg$currPos += 4;
                    } else {
                      s3 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c312);
                      }
                    }
                    if (s3 !== peg$FAILED) {
                      s4 = peg$parsewsp();
                      if (s4 !== peg$FAILED) {
                        s5 = peg$parsecolorArrows();
                        if (s5 !== peg$FAILED) {
                          s6 = peg$parsews();
                          if (s6 !== peg$FAILED) {
                            s7 = peg$parsebr();
                            if (s7 !== peg$FAILED) {
                              s8 = [];
                              s9 = peg$currPos;
                              s10 = peg$parseinnerComment();
                              if (s10 !== peg$FAILED) {
                                peg$savedPos = s9;
                                s10 = peg$c313(s5, s10);
                              }
                              s9 = s10;
                              while (s9 !== peg$FAILED) {
                                s8.push(s9);
                                s9 = peg$currPos;
                                s10 = peg$parseinnerComment();
                                if (s10 !== peg$FAILED) {
                                  peg$savedPos = s9;
                                  s10 = peg$c313(s5, s10);
                                }
                                s9 = s10;
                              }
                              if (s8 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s1 = peg$c314(s5, s8);
                                s0 = s1;
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  s1 = peg$parsews();
                  if (s1 !== peg$FAILED) {
                    s2 = peg$parsebl();
                    if (s2 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 37) {
                        s3 = peg$c315;
                        peg$currPos++;
                      } else {
                        s3 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c316);
                        }
                      }
                      if (s3 !== peg$FAILED) {
                        s4 = peg$parseclockCommand();
                        if (s4 !== peg$FAILED) {
                          s5 = peg$parsewsp();
                          if (s5 !== peg$FAILED) {
                            s6 = peg$parseclockValue();
                            if (s6 !== peg$FAILED) {
                              s7 = peg$parsews();
                              if (s7 !== peg$FAILED) {
                                s8 = peg$parsebr();
                                if (s8 !== peg$FAILED) {
                                  s9 = [];
                                  s10 = peg$currPos;
                                  s11 = peg$parseinnerComment();
                                  if (s11 !== peg$FAILED) {
                                    peg$savedPos = s10;
                                    s11 = peg$c317(s4, s6, s11);
                                  }
                                  s10 = s11;
                                  while (s10 !== peg$FAILED) {
                                    s9.push(s10);
                                    s10 = peg$currPos;
                                    s11 = peg$parseinnerComment();
                                    if (s11 !== peg$FAILED) {
                                      peg$savedPos = s10;
                                      s11 = peg$c317(s4, s6, s11);
                                    }
                                    s10 = s11;
                                  }
                                  if (s9 !== peg$FAILED) {
                                    peg$savedPos = s0;
                                    s1 = peg$c318(s4, s6, s9);
                                    s0 = s1;
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    s1 = peg$parsews();
                    if (s1 !== peg$FAILED) {
                      s2 = peg$parsebl();
                      if (s2 !== peg$FAILED) {
                        if (input.substr(peg$currPos, 5) === peg$c319) {
                          s3 = peg$c319;
                          peg$currPos += 5;
                        } else {
                          s3 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c320);
                          }
                        }
                        if (s3 !== peg$FAILED) {
                          s4 = peg$parsewsp();
                          if (s4 !== peg$FAILED) {
                            s5 = peg$parsestringNoQuot();
                            if (s5 !== peg$FAILED) {
                              s6 = peg$parsews();
                              if (s6 !== peg$FAILED) {
                                s7 = peg$parsebr();
                                if (s7 !== peg$FAILED) {
                                  s8 = [];
                                  s9 = peg$currPos;
                                  s10 = peg$parseinnerComment();
                                  if (s10 !== peg$FAILED) {
                                    peg$savedPos = s9;
                                    s10 = peg$c321(s5, s10);
                                  }
                                  s9 = s10;
                                  while (s9 !== peg$FAILED) {
                                    s8.push(s9);
                                    s9 = peg$currPos;
                                    s10 = peg$parseinnerComment();
                                    if (s10 !== peg$FAILED) {
                                      peg$savedPos = s9;
                                      s10 = peg$c321(s5, s10);
                                    }
                                    s9 = s10;
                                  }
                                  if (s8 !== peg$FAILED) {
                                    peg$savedPos = s0;
                                    s1 = peg$c322(s5, s8);
                                    s0 = s1;
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                    if (s0 === peg$FAILED) {
                      s0 = peg$currPos;
                      s1 = peg$parsews();
                      if (s1 !== peg$FAILED) {
                        s2 = peg$parsebl();
                        if (s2 !== peg$FAILED) {
                          if (input.charCodeAt(peg$currPos) === 37) {
                            s3 = peg$c315;
                            peg$currPos++;
                          } else {
                            s3 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$c316);
                            }
                          }
                          if (s3 !== peg$FAILED) {
                            s4 = peg$parsestringNoQuot();
                            if (s4 !== peg$FAILED) {
                              s5 = peg$parsewsp();
                              if (s5 !== peg$FAILED) {
                                s6 = [];
                                s7 = peg$parsenbr();
                                if (s7 !== peg$FAILED) {
                                  while (s7 !== peg$FAILED) {
                                    s6.push(s7);
                                    s7 = peg$parsenbr();
                                  }
                                } else {
                                  s6 = peg$FAILED;
                                }
                                if (s6 !== peg$FAILED) {
                                  s7 = peg$parsebr();
                                  if (s7 !== peg$FAILED) {
                                    s8 = [];
                                    s9 = peg$currPos;
                                    s10 = peg$parseinnerComment();
                                    if (s10 !== peg$FAILED) {
                                      peg$savedPos = s9;
                                      s10 = peg$c323(s4, s10);
                                    }
                                    s9 = s10;
                                    while (s9 !== peg$FAILED) {
                                      s8.push(s9);
                                      s9 = peg$currPos;
                                      s10 = peg$parseinnerComment();
                                      if (s10 !== peg$FAILED) {
                                        peg$savedPos = s9;
                                        s10 = peg$c323(s4, s10);
                                      }
                                      s9 = s10;
                                    }
                                    if (s8 !== peg$FAILED) {
                                      peg$savedPos = s0;
                                      s1 = peg$c324(s4, s8);
                                      s0 = s1;
                                    } else {
                                      peg$currPos = s0;
                                      s0 = peg$FAILED;
                                    }
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                      if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        s1 = [];
                        s2 = peg$parsenonCommand();
                        if (s2 !== peg$FAILED) {
                          while (s2 !== peg$FAILED) {
                            s1.push(s2);
                            s2 = peg$parsenonCommand();
                          }
                        } else {
                          s1 = peg$FAILED;
                        }
                        if (s1 !== peg$FAILED) {
                          s2 = [];
                          s3 = peg$currPos;
                          s4 = peg$parsews();
                          if (s4 !== peg$FAILED) {
                            s5 = peg$parseinnerComment();
                            if (s5 !== peg$FAILED) {
                              peg$savedPos = s3;
                              s4 = peg$c325(s1, s5);
                              s3 = s4;
                            } else {
                              peg$currPos = s3;
                              s3 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                          }
                          while (s3 !== peg$FAILED) {
                            s2.push(s3);
                            s3 = peg$currPos;
                            s4 = peg$parsews();
                            if (s4 !== peg$FAILED) {
                              s5 = peg$parseinnerComment();
                              if (s5 !== peg$FAILED) {
                                peg$savedPos = s3;
                                s4 = peg$c325(s1, s5);
                                s3 = s4;
                              } else {
                                peg$currPos = s3;
                                s3 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s3;
                              s3 = peg$FAILED;
                            }
                          }
                          if (s2 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c326(s1, s2);
                            s0 = s1;
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      }
                    }
                  }
                }
              }

              return s0;
            }

            function peg$parsenonCommand() {
              var s0, s1, s2, s3;

              s0 = peg$currPos;
              s1 = peg$currPos;
              peg$silentFails++;
              if (input.substr(peg$currPos, 2) === peg$c327) {
                s2 = peg$c327;
                peg$currPos += 2;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c328);
                }
              }
              peg$silentFails--;
              if (s2 === peg$FAILED) {
                s1 = void 0;
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$currPos;
                peg$silentFails++;
                if (input.charCodeAt(peg$currPos) === 125) {
                  s3 = peg$c329;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c330);
                  }
                }
                peg$silentFails--;
                if (s3 === peg$FAILED) {
                  s2 = void 0;
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s3 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c331);
                    }
                  }
                  if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c332(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }

              return s0;
            }

            function peg$parsenbr() {
              var s0, s1, s2;

              s0 = peg$currPos;
              s1 = peg$currPos;
              peg$silentFails++;
              s2 = peg$parsebr();
              peg$silentFails--;
              if (s2 === peg$FAILED) {
                s1 = void 0;
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
              if (s1 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s2 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c331);
                  }
                }
                if (s2 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c332(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }

              return s0;
            }

            function peg$parsecommentEndOfLine() {
              var s0, s1, s2, s3;

              s0 = peg$currPos;
              s1 = peg$parsesemicolon();
              if (s1 !== peg$FAILED) {
                s2 = [];
                if (peg$c333.test(input.charAt(peg$currPos))) {
                  s3 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c334);
                  }
                }
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  if (peg$c333.test(input.charAt(peg$currPos))) {
                    s3 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c334);
                    }
                  }
                }
                if (s2 !== peg$FAILED) {
                  s3 = peg$parseeol();
                  if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c335(s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }

              return s0;
            }

            function peg$parsecolorFields() {
              var s0, s1, s2, s3, s4, s5, s6, s7;

              s0 = peg$currPos;
              s1 = peg$parsecolorField();
              if (s1 !== peg$FAILED) {
                s2 = peg$parsews();
                if (s2 !== peg$FAILED) {
                  s3 = [];
                  s4 = peg$currPos;
                  if (input.charCodeAt(peg$currPos) === 44) {
                    s5 = peg$c336;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c337);
                    }
                  }
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parsews();
                    if (s6 !== peg$FAILED) {
                      s7 = peg$parsecolorField();
                      if (s7 !== peg$FAILED) {
                        s5 = [s5, s6, s7];
                        s4 = s5;
                      } else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s4;
                      s4 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                  while (s4 !== peg$FAILED) {
                    s3.push(s4);
                    s4 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 44) {
                      s5 = peg$c336;
                      peg$currPos++;
                    } else {
                      s5 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c337);
                      }
                    }
                    if (s5 !== peg$FAILED) {
                      s6 = peg$parsews();
                      if (s6 !== peg$FAILED) {
                        s7 = peg$parsecolorField();
                        if (s7 !== peg$FAILED) {
                          s5 = [s5, s6, s7];
                          s4 = s5;
                        } else {
                          peg$currPos = s4;
                          s4 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s4;
                      s4 = peg$FAILED;
                    }
                  }
                  if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c338(s1, s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }

              return s0;
            }

            function peg$parsecolorField() {
              var s0, s1, s2;

              s0 = peg$currPos;
              s1 = peg$parsecolor();
              if (s1 !== peg$FAILED) {
                s2 = peg$parsefield();
                if (s2 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c339(s1, s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }

              return s0;
            }

            function peg$parsecolorArrows() {
              var s0, s1, s2, s3, s4, s5, s6, s7;

              s0 = peg$currPos;
              s1 = peg$parsecolorArrow();
              if (s1 !== peg$FAILED) {
                s2 = peg$parsews();
                if (s2 !== peg$FAILED) {
                  s3 = [];
                  s4 = peg$currPos;
                  if (input.charCodeAt(peg$currPos) === 44) {
                    s5 = peg$c336;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c337);
                    }
                  }
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parsews();
                    if (s6 !== peg$FAILED) {
                      s7 = peg$parsecolorArrow();
                      if (s7 !== peg$FAILED) {
                        s5 = [s5, s6, s7];
                        s4 = s5;
                      } else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s4;
                      s4 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                  while (s4 !== peg$FAILED) {
                    s3.push(s4);
                    s4 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 44) {
                      s5 = peg$c336;
                      peg$currPos++;
                    } else {
                      s5 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c337);
                      }
                    }
                    if (s5 !== peg$FAILED) {
                      s6 = peg$parsews();
                      if (s6 !== peg$FAILED) {
                        s7 = peg$parsecolorArrow();
                        if (s7 !== peg$FAILED) {
                          s5 = [s5, s6, s7];
                          s4 = s5;
                        } else {
                          peg$currPos = s4;
                          s4 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s4;
                      s4 = peg$FAILED;
                    }
                  }
                  if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c338(s1, s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }

              return s0;
            }

            function peg$parsecolorArrow() {
              var s0, s1, s2, s3;

              s0 = peg$currPos;
              s1 = peg$parsecolor();
              if (s1 !== peg$FAILED) {
                s2 = peg$parsefield();
                if (s2 !== peg$FAILED) {
                  s3 = peg$parsefield();
                  if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c340(s1, s2, s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }

              return s0;
            }

            function peg$parsecolor() {
              var s0, s1;

              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 89) {
                s1 = peg$c341;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c342);
                }
              }
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c343();
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 71) {
                  s1 = peg$c344;
                  peg$currPos++;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c345);
                  }
                }
                if (s1 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c346();
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  if (input.charCodeAt(peg$currPos) === 82) {
                    s1 = peg$c347;
                    peg$currPos++;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c348);
                    }
                  }
                  if (s1 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c349();
                  }
                  s0 = s1;
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 66) {
                      s1 = peg$c350;
                      peg$currPos++;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c351);
                      }
                    }
                    if (s1 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c352();
                    }
                    s0 = s1;
                  }
                }
              }

              return s0;
            }

            function peg$parsefield() {
              var s0, s1, s2;

              s0 = peg$currPos;
              s1 = peg$parsecolumn();
              if (s1 !== peg$FAILED) {
                s2 = peg$parserow();
                if (s2 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c353(s1, s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }

              return s0;
            }

            function peg$parsecl() {
              var s0;

              if (input.charCodeAt(peg$currPos) === 123) {
                s0 = peg$c354;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c355);
                }
              }

              return s0;
            }

            function peg$parsecr() {
              var s0;

              if (input.charCodeAt(peg$currPos) === 125) {
                s0 = peg$c329;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c330);
                }
              }

              return s0;
            }

            function peg$parsebl() {
              var s0;

              if (input.charCodeAt(peg$currPos) === 91) {
                s0 = peg$c356;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c357);
                }
              }

              return s0;
            }

            function peg$parsebr() {
              var s0;

              if (input.charCodeAt(peg$currPos) === 93) {
                s0 = peg$c358;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c359);
                }
              }

              return s0;
            }

            function peg$parsesemicolon() {
              var s0;

              if (input.charCodeAt(peg$currPos) === 59) {
                s0 = peg$c360;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c361);
                }
              }

              return s0;
            }

            function peg$parseclockCommand() {
              var s0, s1;

              s0 = peg$currPos;
              if (input.substr(peg$currPos, 3) === peg$c362) {
                s1 = peg$c362;
                peg$currPos += 3;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c363);
                }
              }
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c364();
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 3) === peg$c365) {
                  s1 = peg$c365;
                  peg$currPos += 3;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c366);
                  }
                }
                if (s1 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c367();
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  if (input.substr(peg$currPos, 3) === peg$c368) {
                    s1 = peg$c368;
                    peg$currPos += 3;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c369);
                    }
                  }
                  if (s1 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c370();
                  }
                  s0 = s1;
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 3) === peg$c371) {
                      s1 = peg$c371;
                      peg$currPos += 3;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c372);
                      }
                    }
                    if (s1 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c373();
                    }
                    s0 = s1;
                  }
                }
              }

              return s0;
            }

            function peg$parseclockValue() {
              var s0, s1, s2, s3, s4, s5, s6, s7, s8;

              s0 = peg$currPos;
              s1 = peg$parsedigit();
              if (s1 !== peg$FAILED) {
                s2 = peg$parsedigit();
                if (s2 === peg$FAILED) {
                  s2 = null;
                }
                if (s2 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 58) {
                    s3 = peg$c374;
                    peg$currPos++;
                  } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c375);
                    }
                  }
                  if (s3 !== peg$FAILED) {
                    s4 = peg$parsedigit();
                    if (s4 !== peg$FAILED) {
                      s5 = peg$parsedigit();
                      if (s5 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 58) {
                          s6 = peg$c374;
                          peg$currPos++;
                        } else {
                          s6 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c375);
                          }
                        }
                        if (s6 !== peg$FAILED) {
                          s7 = peg$parsedigit();
                          if (s7 !== peg$FAILED) {
                            s8 = peg$parsedigit();
                            if (s8 !== peg$FAILED) {
                              peg$savedPos = s0;
                              s1 = peg$c376(s1, s2, s4, s5, s7, s8);
                              s0 = s1;
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }

              return s0;
            }

            function peg$parsedigit() {
              var s0, s1;

              s0 = peg$currPos;
              if (peg$c287.test(input.charAt(peg$currPos))) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c288);
                }
              }
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c377(s1);
              }
              s0 = s1;

              return s0;
            }

            function peg$parsevariationWhite() {
              var s0, s1, s2, s3, s4, s5;

              s0 = peg$currPos;
              s1 = peg$parsepl();
              if (s1 !== peg$FAILED) {
                s2 = peg$parsepgnWhite();
                if (s2 !== peg$FAILED) {
                  s3 = peg$parsepr();
                  if (s3 !== peg$FAILED) {
                    s4 = peg$parsews();
                    if (s4 !== peg$FAILED) {
                      s5 = peg$parsevariationWhite();
                      if (s5 === peg$FAILED) {
                        s5 = null;
                      }
                      if (s5 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c378(s2, s5);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }

              return s0;
            }

            function peg$parsevariationBlack() {
              var s0, s1, s2, s3, s4, s5;

              s0 = peg$currPos;
              s1 = peg$parsepl();
              if (s1 !== peg$FAILED) {
                s2 = peg$parsepgnStartBlack();
                if (s2 !== peg$FAILED) {
                  s3 = peg$parsepr();
                  if (s3 !== peg$FAILED) {
                    s4 = peg$parsews();
                    if (s4 !== peg$FAILED) {
                      s5 = peg$parsevariationBlack();
                      if (s5 === peg$FAILED) {
                        s5 = null;
                      }
                      if (s5 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c378(s2, s5);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }

              return s0;
            }

            function peg$parsepl() {
              var s0;

              if (input.charCodeAt(peg$currPos) === 40) {
                s0 = peg$c379;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c380);
                }
              }

              return s0;
            }

            function peg$parsepr() {
              var s0;

              if (input.charCodeAt(peg$currPos) === 41) {
                s0 = peg$c381;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c382);
                }
              }

              return s0;
            }

            function peg$parsemoveNumber() {
              var s0, s1, s2, s3, s4;

              s0 = peg$currPos;
              s1 = peg$parseinteger();
              if (s1 !== peg$FAILED) {
                s2 = [];
                s3 = peg$parsewhiteSpace();
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  s3 = peg$parsewhiteSpace();
                }
                if (s2 !== peg$FAILED) {
                  s3 = [];
                  s4 = peg$parsedot();
                  while (s4 !== peg$FAILED) {
                    s3.push(s4);
                    s4 = peg$parsedot();
                  }
                  if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c383(s1);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }

              return s0;
            }

            function peg$parsedot() {
              var s0;

              if (input.charCodeAt(peg$currPos) === 46) {
                s0 = peg$c268;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c269);
                }
              }

              return s0;
            }

            function peg$parseinteger() {
              var s0, s1, s2;

              peg$silentFails++;
              s0 = peg$currPos;
              s1 = [];
              if (peg$c287.test(input.charAt(peg$currPos))) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c288);
                }
              }
              if (s2 !== peg$FAILED) {
                while (s2 !== peg$FAILED) {
                  s1.push(s2);
                  if (peg$c287.test(input.charAt(peg$currPos))) {
                    s2 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c288);
                    }
                  }
                }
              } else {
                s1 = peg$FAILED;
              }
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c289(s1);
              }
              s0 = s1;
              peg$silentFails--;
              if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c384);
                }
              }

              return s0;
            }

            function peg$parsewhiteSpace() {
              var s0, s1, s2;

              s0 = peg$currPos;
              s1 = [];
              if (input.charCodeAt(peg$currPos) === 32) {
                s2 = peg$c385;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c386);
                }
              }
              if (s2 !== peg$FAILED) {
                while (s2 !== peg$FAILED) {
                  s1.push(s2);
                  if (input.charCodeAt(peg$currPos) === 32) {
                    s2 = peg$c385;
                    peg$currPos++;
                  } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c386);
                    }
                  }
                }
              } else {
                s1 = peg$FAILED;
              }
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c387();
              }
              s0 = s1;

              return s0;
            }

            function peg$parsehalfMove() {
              var s0, s1, s2, s3, s4, s5, s6, s7, s8;

              s0 = peg$currPos;
              s1 = peg$parsefigure();
              if (s1 === peg$FAILED) {
                s1 = null;
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$currPos;
                peg$silentFails++;
                s3 = peg$parsecheckdisc();
                peg$silentFails--;
                if (s3 !== peg$FAILED) {
                  peg$currPos = s2;
                  s2 = void 0;
                } else {
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  s3 = peg$parsediscriminator();
                  if (s3 !== peg$FAILED) {
                    s4 = peg$parsestrike();
                    if (s4 === peg$FAILED) {
                      s4 = null;
                    }
                    if (s4 !== peg$FAILED) {
                      s5 = peg$parsecolumn();
                      if (s5 !== peg$FAILED) {
                        s6 = peg$parserow();
                        if (s6 !== peg$FAILED) {
                          s7 = peg$parsepromotion();
                          if (s7 === peg$FAILED) {
                            s7 = null;
                          }
                          if (s7 !== peg$FAILED) {
                            s8 = peg$parsecheck();
                            if (s8 === peg$FAILED) {
                              s8 = null;
                            }
                            if (s8 !== peg$FAILED) {
                              peg$savedPos = s0;
                              s1 = peg$c388(s1, s3, s4, s5, s6, s7, s8);
                              s0 = s1;
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parsefigure();
                if (s1 === peg$FAILED) {
                  s1 = null;
                }
                if (s1 !== peg$FAILED) {
                  s2 = peg$parsecolumn();
                  if (s2 !== peg$FAILED) {
                    s3 = peg$parserow();
                    if (s3 !== peg$FAILED) {
                      s4 = peg$parsestrikeOrDash();
                      if (s4 === peg$FAILED) {
                        s4 = null;
                      }
                      if (s4 !== peg$FAILED) {
                        s5 = peg$parsecolumn();
                        if (s5 !== peg$FAILED) {
                          s6 = peg$parserow();
                          if (s6 !== peg$FAILED) {
                            s7 = peg$parsepromotion();
                            if (s7 === peg$FAILED) {
                              s7 = null;
                            }
                            if (s7 !== peg$FAILED) {
                              s8 = peg$parsecheck();
                              if (s8 === peg$FAILED) {
                                s8 = null;
                              }
                              if (s8 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s1 = peg$c389(s1, s2, s3, s4, s5, s6, s7, s8);
                                s0 = s1;
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  s1 = peg$parsefigure();
                  if (s1 === peg$FAILED) {
                    s1 = null;
                  }
                  if (s1 !== peg$FAILED) {
                    s2 = peg$parsestrike();
                    if (s2 === peg$FAILED) {
                      s2 = null;
                    }
                    if (s2 !== peg$FAILED) {
                      s3 = peg$parsecolumn();
                      if (s3 !== peg$FAILED) {
                        s4 = peg$parserow();
                        if (s4 !== peg$FAILED) {
                          s5 = peg$parsepromotion();
                          if (s5 === peg$FAILED) {
                            s5 = null;
                          }
                          if (s5 !== peg$FAILED) {
                            s6 = peg$parsecheck();
                            if (s6 === peg$FAILED) {
                              s6 = null;
                            }
                            if (s6 !== peg$FAILED) {
                              peg$savedPos = s0;
                              s1 = peg$c390(s1, s2, s3, s4, s5, s6);
                              s0 = s1;
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 5) === peg$c391) {
                      s1 = peg$c391;
                      peg$currPos += 5;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c392);
                      }
                    }
                    if (s1 !== peg$FAILED) {
                      s2 = peg$parsecheck();
                      if (s2 === peg$FAILED) {
                        s2 = null;
                      }
                      if (s2 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c393(s2);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                    if (s0 === peg$FAILED) {
                      s0 = peg$currPos;
                      if (input.substr(peg$currPos, 3) === peg$c394) {
                        s1 = peg$c394;
                        peg$currPos += 3;
                      } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c395);
                        }
                      }
                      if (s1 !== peg$FAILED) {
                        s2 = peg$parsecheck();
                        if (s2 === peg$FAILED) {
                          s2 = null;
                        }
                        if (s2 !== peg$FAILED) {
                          peg$savedPos = s0;
                          s1 = peg$c396(s2);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    }
                  }
                }
              }

              return s0;
            }

            function peg$parsecheck() {
              var s0, s1, s2, s3;

              s0 = peg$currPos;
              s1 = peg$currPos;
              s2 = peg$currPos;
              peg$silentFails++;
              if (input.substr(peg$currPos, 2) === peg$c397) {
                s3 = peg$c397;
                peg$currPos += 2;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c398);
                }
              }
              peg$silentFails--;
              if (s3 === peg$FAILED) {
                s2 = void 0;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 43) {
                  s3 = peg$c399;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c400);
                  }
                }
                if (s3 !== peg$FAILED) {
                  s2 = [s2, s3];
                  s1 = s2;
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c401(s1);
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$currPos;
                s2 = peg$currPos;
                peg$silentFails++;
                if (input.substr(peg$currPos, 3) === peg$c402) {
                  s3 = peg$c402;
                  peg$currPos += 3;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c403);
                  }
                }
                peg$silentFails--;
                if (s3 === peg$FAILED) {
                  s2 = void 0;
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 35) {
                    s3 = peg$c404;
                    peg$currPos++;
                  } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c405);
                    }
                  }
                  if (s3 !== peg$FAILED) {
                    s2 = [s2, s3];
                    s1 = s2;
                  } else {
                    peg$currPos = s1;
                    s1 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
                if (s1 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c401(s1);
                }
                s0 = s1;
              }

              return s0;
            }

            function peg$parsepromotion() {
              var s0, s1, s2;

              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 61) {
                s1 = peg$c406;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c407);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$parsepromFigure();
                if (s2 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c408(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }

              return s0;
            }

            function peg$parsenags() {
              var s0, s1, s2, s3;

              s0 = peg$currPos;
              s1 = peg$parsenag();
              if (s1 !== peg$FAILED) {
                s2 = peg$parsews();
                if (s2 !== peg$FAILED) {
                  s3 = peg$parsenags();
                  if (s3 === peg$FAILED) {
                    s3 = null;
                  }
                  if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c409(s1, s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }

              return s0;
            }

            function peg$parsenag() {
              var s0, s1, s2;

              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 36) {
                s1 = peg$c410;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c411);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$parseinteger();
                if (s2 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c412(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 2) === peg$c413) {
                  s1 = peg$c413;
                  peg$currPos += 2;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c414);
                  }
                }
                if (s1 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c415();
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  if (input.substr(peg$currPos, 2) === peg$c416) {
                    s1 = peg$c416;
                    peg$currPos += 2;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c417);
                    }
                  }
                  if (s1 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c418();
                  }
                  s0 = s1;
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 2) === peg$c419) {
                      s1 = peg$c419;
                      peg$currPos += 2;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c420);
                      }
                    }
                    if (s1 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c421();
                    }
                    s0 = s1;
                    if (s0 === peg$FAILED) {
                      s0 = peg$currPos;
                      if (input.substr(peg$currPos, 2) === peg$c422) {
                        s1 = peg$c422;
                        peg$currPos += 2;
                      } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c423);
                        }
                      }
                      if (s1 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c424();
                      }
                      s0 = s1;
                      if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        if (input.charCodeAt(peg$currPos) === 33) {
                          s1 = peg$c425;
                          peg$currPos++;
                        } else {
                          s1 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c426);
                          }
                        }
                        if (s1 !== peg$FAILED) {
                          peg$savedPos = s0;
                          s1 = peg$c427();
                        }
                        s0 = s1;
                        if (s0 === peg$FAILED) {
                          s0 = peg$currPos;
                          if (input.charCodeAt(peg$currPos) === 63) {
                            s1 = peg$c428;
                            peg$currPos++;
                          } else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$c429);
                            }
                          }
                          if (s1 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c430();
                          }
                          s0 = s1;
                          if (s0 === peg$FAILED) {
                            s0 = peg$currPos;
                            if (input.charCodeAt(peg$currPos) === 8252) {
                              s1 = peg$c431;
                              peg$currPos++;
                            } else {
                              s1 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$c432);
                              }
                            }
                            if (s1 !== peg$FAILED) {
                              peg$savedPos = s0;
                              s1 = peg$c415();
                            }
                            s0 = s1;
                            if (s0 === peg$FAILED) {
                              s0 = peg$currPos;
                              if (input.charCodeAt(peg$currPos) === 8263) {
                                s1 = peg$c433;
                                peg$currPos++;
                              } else {
                                s1 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                  peg$fail(peg$c434);
                                }
                              }
                              if (s1 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s1 = peg$c418();
                              }
                              s0 = s1;
                              if (s0 === peg$FAILED) {
                                s0 = peg$currPos;
                                if (input.charCodeAt(peg$currPos) === 8265) {
                                  s1 = peg$c435;
                                  peg$currPos++;
                                } else {
                                  s1 = peg$FAILED;
                                  if (peg$silentFails === 0) {
                                    peg$fail(peg$c436);
                                  }
                                }
                                if (s1 !== peg$FAILED) {
                                  peg$savedPos = s0;
                                  s1 = peg$c421();
                                }
                                s0 = s1;
                                if (s0 === peg$FAILED) {
                                  s0 = peg$currPos;
                                  if (input.charCodeAt(peg$currPos) === 8264) {
                                    s1 = peg$c437;
                                    peg$currPos++;
                                  } else {
                                    s1 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                      peg$fail(peg$c438);
                                    }
                                  }
                                  if (s1 !== peg$FAILED) {
                                    peg$savedPos = s0;
                                    s1 = peg$c424();
                                  }
                                  s0 = s1;
                                  if (s0 === peg$FAILED) {
                                    s0 = peg$currPos;
                                    if (input.charCodeAt(peg$currPos) === 9633) {
                                      s1 = peg$c439;
                                      peg$currPos++;
                                    } else {
                                      s1 = peg$FAILED;
                                      if (peg$silentFails === 0) {
                                        peg$fail(peg$c440);
                                      }
                                    }
                                    if (s1 !== peg$FAILED) {
                                      peg$savedPos = s0;
                                      s1 = peg$c441();
                                    }
                                    s0 = s1;
                                    if (s0 === peg$FAILED) {
                                      s0 = peg$currPos;
                                      if (input.charCodeAt(peg$currPos) === 61) {
                                        s1 = peg$c406;
                                        peg$currPos++;
                                      } else {
                                        s1 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                          peg$fail(peg$c407);
                                        }
                                      }
                                      if (s1 !== peg$FAILED) {
                                        peg$savedPos = s0;
                                        s1 = peg$c442();
                                      }
                                      s0 = s1;
                                      if (s0 === peg$FAILED) {
                                        s0 = peg$currPos;
                                        if (input.charCodeAt(peg$currPos) === 8734) {
                                          s1 = peg$c443;
                                          peg$currPos++;
                                        } else {
                                          s1 = peg$FAILED;
                                          if (peg$silentFails === 0) {
                                            peg$fail(peg$c444);
                                          }
                                        }
                                        if (s1 !== peg$FAILED) {
                                          peg$savedPos = s0;
                                          s1 = peg$c445();
                                        }
                                        s0 = s1;
                                        if (s0 === peg$FAILED) {
                                          s0 = peg$currPos;
                                          if (input.charCodeAt(peg$currPos) === 10866) {
                                            s1 = peg$c446;
                                            peg$currPos++;
                                          } else {
                                            s1 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                              peg$fail(peg$c447);
                                            }
                                          }
                                          if (s1 !== peg$FAILED) {
                                            peg$savedPos = s0;
                                            s1 = peg$c448();
                                          }
                                          s0 = s1;
                                          if (s0 === peg$FAILED) {
                                            s0 = peg$currPos;
                                            if (input.charCodeAt(peg$currPos) === 10865) {
                                              s1 = peg$c449;
                                              peg$currPos++;
                                            } else {
                                              s1 = peg$FAILED;
                                              if (peg$silentFails === 0) {
                                                peg$fail(peg$c450);
                                              }
                                            }
                                            if (s1 !== peg$FAILED) {
                                              peg$savedPos = s0;
                                              s1 = peg$c451();
                                            }
                                            s0 = s1;
                                            if (s0 === peg$FAILED) {
                                              s0 = peg$currPos;
                                              if (input.charCodeAt(peg$currPos) === 177) {
                                                s1 = peg$c452;
                                                peg$currPos++;
                                              } else {
                                                s1 = peg$FAILED;
                                                if (peg$silentFails === 0) {
                                                  peg$fail(peg$c453);
                                                }
                                              }
                                              if (s1 !== peg$FAILED) {
                                                peg$savedPos = s0;
                                                s1 = peg$c454();
                                              }
                                              s0 = s1;
                                              if (s0 === peg$FAILED) {
                                                s0 = peg$currPos;
                                                if (input.charCodeAt(peg$currPos) === 8723) {
                                                  s1 = peg$c455;
                                                  peg$currPos++;
                                                } else {
                                                  s1 = peg$FAILED;
                                                  if (peg$silentFails === 0) {
                                                    peg$fail(peg$c456);
                                                  }
                                                }
                                                if (s1 !== peg$FAILED) {
                                                  peg$savedPos = s0;
                                                  s1 = peg$c457();
                                                }
                                                s0 = s1;
                                                if (s0 === peg$FAILED) {
                                                  s0 = peg$currPos;
                                                  if (input.substr(peg$currPos, 2) === peg$c397) {
                                                    s1 = peg$c397;
                                                    peg$currPos += 2;
                                                  } else {
                                                    s1 = peg$FAILED;
                                                    if (peg$silentFails === 0) {
                                                      peg$fail(peg$c398);
                                                    }
                                                  }
                                                  if (s1 !== peg$FAILED) {
                                                    peg$savedPos = s0;
                                                    s1 = peg$c458();
                                                  }
                                                  s0 = s1;
                                                  if (s0 === peg$FAILED) {
                                                    s0 = peg$currPos;
                                                    if (input.substr(peg$currPos, 2) === peg$c459) {
                                                      s1 = peg$c459;
                                                      peg$currPos += 2;
                                                    } else {
                                                      s1 = peg$FAILED;
                                                      if (peg$silentFails === 0) {
                                                        peg$fail(peg$c460);
                                                      }
                                                    }
                                                    if (s1 !== peg$FAILED) {
                                                      peg$savedPos = s0;
                                                      s1 = peg$c461();
                                                    }
                                                    s0 = s1;
                                                    if (s0 === peg$FAILED) {
                                                      s0 = peg$currPos;
                                                      if (input.charCodeAt(peg$currPos) === 10752) {
                                                        s1 = peg$c462;
                                                        peg$currPos++;
                                                      } else {
                                                        s1 = peg$FAILED;
                                                        if (peg$silentFails === 0) {
                                                          peg$fail(peg$c463);
                                                        }
                                                      }
                                                      if (s1 !== peg$FAILED) {
                                                        peg$savedPos = s0;
                                                        s1 = peg$c464();
                                                      }
                                                      s0 = s1;
                                                      if (s0 === peg$FAILED) {
                                                        s0 = peg$currPos;
                                                        if (input.charCodeAt(peg$currPos) === 10227) {
                                                          s1 = peg$c465;
                                                          peg$currPos++;
                                                        } else {
                                                          s1 = peg$FAILED;
                                                          if (peg$silentFails === 0) {
                                                            peg$fail(peg$c466);
                                                          }
                                                        }
                                                        if (s1 !== peg$FAILED) {
                                                          peg$savedPos = s0;
                                                          s1 = peg$c467();
                                                        }
                                                        s0 = s1;
                                                        if (s0 === peg$FAILED) {
                                                          s0 = peg$currPos;
                                                          if (input.charCodeAt(peg$currPos) === 8594) {
                                                            s1 = peg$c468;
                                                            peg$currPos++;
                                                          } else {
                                                            s1 = peg$FAILED;
                                                            if (peg$silentFails === 0) {
                                                              peg$fail(peg$c469);
                                                            }
                                                          }
                                                          if (s1 !== peg$FAILED) {
                                                            peg$savedPos = s0;
                                                            s1 = peg$c470();
                                                          }
                                                          s0 = s1;
                                                          if (s0 === peg$FAILED) {
                                                            s0 = peg$currPos;
                                                            if (input.charCodeAt(peg$currPos) === 8593) {
                                                              s1 = peg$c471;
                                                              peg$currPos++;
                                                            } else {
                                                              s1 = peg$FAILED;
                                                              if (peg$silentFails === 0) {
                                                                peg$fail(peg$c472);
                                                              }
                                                            }
                                                            if (s1 !== peg$FAILED) {
                                                              peg$savedPos = s0;
                                                              s1 = peg$c473();
                                                            }
                                                            s0 = s1;
                                                            if (s0 === peg$FAILED) {
                                                              s0 = peg$currPos;
                                                              if (input.charCodeAt(peg$currPos) === 8646) {
                                                                s1 = peg$c474;
                                                                peg$currPos++;
                                                              } else {
                                                                s1 = peg$FAILED;
                                                                if (peg$silentFails === 0) {
                                                                  peg$fail(peg$c475);
                                                                }
                                                              }
                                                              if (s1 !== peg$FAILED) {
                                                                peg$savedPos = s0;
                                                                s1 = peg$c476();
                                                              }
                                                              s0 = s1;
                                                              if (s0 === peg$FAILED) {
                                                                s0 = peg$currPos;
                                                                if (input.charCodeAt(peg$currPos) === 68) {
                                                                  s1 = peg$c477;
                                                                  peg$currPos++;
                                                                } else {
                                                                  s1 = peg$FAILED;
                                                                  if (peg$silentFails === 0) {
                                                                    peg$fail(peg$c478);
                                                                  }
                                                                }
                                                                if (s1 !== peg$FAILED) {
                                                                  peg$savedPos = s0;
                                                                  s1 = peg$c479();
                                                                }
                                                                s0 = s1;
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }

              return s0;
            }

            function peg$parsediscriminator() {
              var s0;

              s0 = peg$parsecolumn();
              if (s0 === peg$FAILED) {
                s0 = peg$parserow();
              }

              return s0;
            }

            function peg$parsecheckdisc() {
              var s0, s1, s2, s3, s4;

              s0 = peg$currPos;
              s1 = peg$parsediscriminator();
              if (s1 !== peg$FAILED) {
                s2 = peg$parsestrike();
                if (s2 === peg$FAILED) {
                  s2 = null;
                }
                if (s2 !== peg$FAILED) {
                  s3 = peg$parsecolumn();
                  if (s3 !== peg$FAILED) {
                    s4 = peg$parserow();
                    if (s4 !== peg$FAILED) {
                      s1 = [s1, s2, s3, s4];
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }

              return s0;
            }

            function peg$parsefigure() {
              var s0;

              if (peg$c480.test(input.charAt(peg$currPos))) {
                s0 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c481);
                }
              }

              return s0;
            }

            function peg$parsepromFigure() {
              var s0;

              if (peg$c482.test(input.charAt(peg$currPos))) {
                s0 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c483);
                }
              }

              return s0;
            }

            function peg$parsecolumn() {
              var s0;

              if (peg$c484.test(input.charAt(peg$currPos))) {
                s0 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c485);
                }
              }

              return s0;
            }

            function peg$parserow() {
              var s0;

              if (peg$c486.test(input.charAt(peg$currPos))) {
                s0 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c487);
                }
              }

              return s0;
            }

            function peg$parsestrike() {
              var s0;

              if (input.charCodeAt(peg$currPos) === 120) {
                s0 = peg$c488;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c489);
                }
              }

              return s0;
            }

            function peg$parsestrikeOrDash() {
              var s0;

              if (input.charCodeAt(peg$currPos) === 120) {
                s0 = peg$c488;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c489);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 45) {
                  s0 = peg$c285;
                  peg$currPos++;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c286);
                  }
                }
              }

              return s0;
            }


            function makeInteger(o) {
              return parseInt(o.join(""), 10);
            }

            function merge(array) {
              var ret = {}
              // return array
              array.forEach(function(json) {
                for (var key in json) {
                  if (typeof json[key] == "string") ret[key] = ret[key] ? trimEnd(ret[key]) + " " + trimStart(json[key]) : json[key]
                  if (Array.isArray(json[key])) ret[key] = ret[key] ? ret[key].concat(json[key]) : json[key]
                }
              })
              return ret
            }

            function trimStart(st) {
              if (typeof st !== "string") return st
              var r = /^\s+/
              return st.replace(r, '')
            }

            function trimEnd(st) {
              if (typeof st !== "string") return st
              var r = /\s+$/
              return st.replace(r, '')
            }



            peg$result = peg$startRuleFunction();

            if (peg$result !== peg$FAILED && peg$currPos === input.length) {
              return peg$result;
            } else {
              if (peg$result !== peg$FAILED && peg$currPos < input.length) {
                peg$fail(peg$endExpectation());
              }

              throw peg$buildStructuredError(
                peg$maxFailExpected,
                peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
                peg$maxFailPos < input.length ?
                peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) :
                peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
              );
            }
          }

          module.exports = {
            SyntaxError: peg$SyntaxError,
            parse: peg$parse
          };

        }, {}],
        2: [function(require, module, exports) {
          const parser = require('./pgn-parser.js')
          window.parsePgn = parser.parse
        }, {
          "./pgn-parser.js": 3
        }],
        3: [function(require, module, exports) {
          const parser = require('./_pgn-parser.js')

          /**
           * Patches the original function, to avoid empty games. May include additional functionality
           * for understanding parse errors later.
           */
          const parse = function(input, options) {
            // Had to trim the grammar to allow no whitespace after a game, this is consumed only when read many games
            // Therefore the strings are trimmed here.
            if (!options || (options.startRule === 'pgn') || (options.startRule === 'game')) {
              input = input.trim()
            }
            let result = parser.parse(input, options)
            if (options && (options.startRule === 'games')) {
              // result should be an array of games. Check the last game, if it is empty, and remove it then
              if (!Array.isArray(result)) return result
              if (result.length === 0) return result
              let last = result.pop()
              if ((Object.keys(last.tags).length > 0) || (last.moves.length > 0)) {
                result.push(last)
              }
              return result
            }
            return result
          }

          module.exports = {
            SyntaxError: parser.SyntaxError,
            parse: parse
          };

        }, {
          "./_pgn-parser.js": 1
        }]
      }, {}, [2]);
    </script>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <style media="screen">
/*
 * Chessground base css properties.
 *
 * You need to include the css files in themes folder in order to have the
 * board and pieces displayed!
 */
 ::-webkit-scrollbar {
  display: none;
}

body {
  margin:0 auto;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}

select { font-size:1.2em; }

button {
  position: relative;
  top: 0.07em;
  font-size: 1.4em;
  background-color: #f5f5f5;
  color: #333B45 !important;
  border: 1px solid #dcdcdc;
  border-radius: 2px;
  box-shadow: 0px 0px 3px 1px black;
  cursor: pointer;
}

#center {
  display:none;
  text-align: center;
  background-color: rgba(255,255,255,.2);
  border-radius: 5px;
  box-shadow: 0px 0px 6px 2px black;
  padding: .4em;
  z-index: 100;
  white-space: nowrap;
  backdrop-filter: blur(5px);
  position:absolute;
  top: 3.5vmin;
  left: 50%;
  transform: translateX(-50%);
}

button:hover {
  background-color: #F8F8F8;
  border: 1px solid #C6C6C6;
  box-shadow: 0px 0px 6px 0px grey;
  color: #333;
}
button:active {
  background-color: #d6d6d6;
}

button:focus {
  outline: 0;
}
 html, img {
   margin: 0;
   color: white;

 }
.cg-wrap {
  position: relative;
  display: block;
}

cg-board {
  border: 0;
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  line-height: 0;
  background-size: cover;
  cursor: pointer;
}
cg-board square {
  position: absolute;
  top: 0;
  left: 0;
  width: 12.5%;
  height: 12.5%;
  pointer-events: none;
}
cg-board square.move-dest {
  background: radial-gradient(rgba(20, 85, 30, 0.5) 22%, #208530 0, rgba(0, 0, 0, 0.3) 0, rgba(0, 0, 0, 0) 0);
  pointer-events: auto;
}
cg-board square.premove-dest {
  background: radial-gradient(rgba(20, 30, 85, 0.5) 22%, #203085 0, rgba(0, 0, 0, 0.3) 0, rgba(0, 0, 0, 0) 0);
}
cg-board square.oc.move-dest {
  background: radial-gradient(transparent 0%, transparent 80%, rgba(20, 85, 0, 0.3) 80%);
}
cg-board square.oc.premove-dest {
  background: radial-gradient(transparent 0%, transparent 80%, rgba(20, 30, 85, 0.2) 80%);
}
cg-board square.move-dest:hover {
  background: rgba(20, 85, 30, 0.3);
}
cg-board square.premove-dest:hover {
  background: rgba(20, 30, 85, 0.2);
}
cg-board square.last-move {
  will-change: transform;
  background-color: rgba(155, 199, 0, 0.41);
}
cg-board square.selected {
  background-color: rgba(20, 85, 30, 0.5);
}
cg-board square.check {
  background: radial-gradient(ellipse at center, rgba(255, 0, 0, 1) 0%, rgba(231, 0, 0, 1) 25%, rgba(169, 0, 0, 0) 89%, rgba(158, 0, 0, 0) 100%);
}
cg-board square.current-premove {
  background-color: rgba(20, 30, 85, 0.5);
}
.cg-wrap piece {
  position: absolute;
  top: 0;
  left: 0;
  width: 12.5%;
  height: 12.5%;
  background-size: cover;
  z-index: 2;
  will-change: transform;
  pointer-events: none;
}
cg-board piece.dragging {
  cursor: move;
  z-index: 10;
}
cg-board piece.anim {
  z-index: 8;
}
cg-board piece.fading {
  z-index: 1;
  opacity: 0.5;
}
.cg-wrap square.move-dest:hover {
  background-color: rgba(20, 85, 30, 0.3);
}
.cg-wrap piece.ghost {
  opacity: 0.3;
}
.cg-wrap .cg-shapes, .cg-wrap .cg-custom-svgs {
  overflow: hidden;
  position: absolute;
  top: 0px;
  left: 0px;
  width: 100%;
  height: 100%;
  pointer-events: none;
}
.cg-wrap .cg-shapes {
  opacity: 0.6;
  z-index: 2;
}
.cg-wrap .cg-custom-svgs {
  /* over piece.anim = 8, but under piece.dragging = 10 */
  z-index: 9;
}
.cg-wrap coords {
  position: absolute;
  display: flex;
  pointer-events: none;
  opacity: 0.8;
  font-size: 9px;
}
.cg-wrap coords.ranks {
  right: -15px;
  top: 0;
  flex-flow: column-reverse;
  height: 100%;
  width: 12px;
}
.cg-wrap coords.ranks.black {
  flex-flow: column;
}
.cg-wrap coords.files {
  bottom: -16px;
  left: 0;
  flex-flow: row;
  width: 100%;
  height: 16px;
  text-transform: uppercase;
  text-align: center;
}
.cg-wrap coords.files.black {
  flex-flow: row-reverse;
}
.cg-wrap coords coord {
  flex: 1 1 auto;
}
.cg-wrap coords.ranks coord {
  transform: translateY(39%);
}

    /*
* Board
*/
.blue .cg-wrap {
  background-image: url('data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4PSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIgogICAgIHZpZXdCb3g9IjAgMCA4IDgiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyI+CjxnIGlkPSJhIj4KICA8ZyBpZD0iYiI+CiAgICA8ZyBpZD0iYyI+CiAgICAgIDxnIGlkPSJkIj4KICAgICAgICA8cmVjdCB3aWR0aD0iMSIgaGVpZ2h0PSIxIiBmaWxsPSIjZjBkOWI1IiBpZD0iZSIvPgogICAgICAgIDx1c2UgeD0iMSIgeT0iMSIgaHJlZj0iI2UiIHg6aHJlZj0iI2UiLz4KICAgICAgICA8cmVjdCB5PSIxIiB3aWR0aD0iMSIgaGVpZ2h0PSIxIiBmaWxsPSIjYjU4ODYzIiBpZD0iZiIvPgogICAgICAgIDx1c2UgeD0iMSIgeT0iLTEiIGhyZWY9IiNmIiB4OmhyZWY9IiNmIi8+CiAgICAgIDwvZz4KICAgICAgPHVzZSB4PSIyIiBocmVmPSIjZCIgeDpocmVmPSIjZCIvPgogICAgPC9nPgogICAgPHVzZSB4PSI0IiBocmVmPSIjYyIgeDpocmVmPSIjYyIvPgogIDwvZz4KICA8dXNlIHk9IjIiIGhyZWY9IiNiIiB4OmhyZWY9IiNiIi8+CjwvZz4KPHVzZSB5PSI0IiBocmVmPSIjYSIgeDpocmVmPSIjYSIvPgo8L3N2Zz4K');

}

.merida .cg-wrap piece.pawn.white {
background-image: url('_wP.svg');
}
.merida .cg-wrap piece.bishop.white {
background-image: url('_wB.svg');
}
.merida .cg-wrap piece.knight.white {
background-image: url('_wN.svg');
}
.merida .cg-wrap piece.rook.white {
background-image: url('_wR.svg');
}
.merida .cg-wrap piece.queen.white {
background-image: url('_wQ.svg');
}
.merida .cg-wrap piece.king.white {
background-image: url('_wK.svg');
}
.merida .cg-wrap piece.pawn.black {
background-image: url('_bP.svg');
}
.merida .cg-wrap piece.bishop.black {
background-image: url('_bB.svg');
}
.merida .cg-wrap piece.knight.black {
background-image: url('_bN.svg');
}
.merida .cg-wrap piece.rook.black {
background-image: url('_bR.svg');
}
.merida .cg-wrap piece.queen.black {
background-image: url('_bQ.svg');
}
.merida .cg-wrap piece.king.black {
background-image: url('_bK.svg');
}

    </style>
  </head>
  <body>
    <div style="text-align: center">
    <div id="chessground-examples"></div>
    <div id="center">
    <button value="q"><img id="promoteQ" style="width:min(75px, 12.5vmin);"></button>
    <button value="b"><img id="promoteB" style="width:min(75px, 12.5vmin);"></button>
    <button value="n"><img id="promoteN" style="width:min(75px, 12.5vmin);"></button>
    <button value="r"><img id="promoteR" style="width:min(75px, 12.5vmin);"></button>
    </div>
    </div>
    <script>
    function getUrlVars() {
      var vars = {};
      var parts = window.location.href.replace(/[?&]+([^=&]+)=([^&]*)/gi, function(m, key, value) {
        vars[key] = decodeURIComponent(value).replace("#!/0", "");
      });
      return vars;
    }

    var pgn = getUrlVars()["PGN"];
    var background = getUrlVars()["background"];
    document.body.style.backgroundColor = background;
    let parsedPGN = parsePgn(pgn, {
      startRule: "game"
    });

    var handicap = getUrlVars()["handicap"];
    var fen;
    var errorCount = 0;
    if (parsedPGN.tags.FEN) {
      fen = parsedPGN.tags.FEN
    } else {
      fen = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1"
    }


    var boardRotation = "black";
    var flipBoard = getUrlVars()["flip"];
    var FEN = fen;


    var patt = /(( b | w ))(?!.*\1)/g;
    var result = FEN.match(patt);
    if (result == " w ") {

      boardRotation = "white";

    }

    if (flipBoard == 'true' && boardRotation == "white") {
      boardRotation = "black"
    } else if (flipBoard == 'true' && boardRotation == "black") {
      boardRotation = "white";
    }
    var opponentColour = 'black';

    if (boardRotation == 'black') {
      opponentColour = 'white';
    }

    document.querySelector('#promoteQ').src = "_"+boardRotation[0]+"Q.svg";
    document.querySelector('#promoteB').src = "_"+boardRotation[0]+"B.svg";
    document.querySelector('#promoteN').src = "_"+boardRotation[0]+"N.svg";
    document.querySelector('#promoteR').src = "_"+boardRotation[0]+"R.svg";
    var count; // Int so we can track on which move we are.
    var expectedLine; // Set initially to the mainline of pgn but can change path with variations
    var expectedMove; // Set the expected move according to PGN
    var promoteChoice = 'q'; //default promotion to queen, can be changed with button withing template however it must be specified before move is made.
    var foundVariation; // a bullion to check if there are multiple lines
    var responseVar; // used to randomly sellect an appropriate response

    ;
    (function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.ChessgroundExamples = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
    /*
     * Copyright (c) 2016, Jeff Hlywa (jhlywa@gmail.com)
     * All rights reserved.
     *
     * Redistribution and use in source and binary forms, with or without
     * modification, are permitted provided that the following conditions are met:
     *
     * 1. Redistributions of source code must retain the above copyright notice,
     *    this list of conditions and the following disclaimer.
     * 2. Redistributions in binary form must reproduce the above copyright notice,
     *    this list of conditions and the following disclaimer in the documentation
     *    and/or other materials provided with the distribution.
     *
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
     * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
     * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
     * POSSIBILITY OF SUCH DAMAGE.
     *
     *----------------------------------------------------------------------------*/

    /* minified license below  */

    /* @license
     * Copyright (c) 2016, Jeff Hlywa (jhlywa@gmail.com)
     * Released under the BSD license
     * https://github.com/jhlywa/chess.js/blob/master/LICENSE
     */

    var Chess = function(fen) {

      /* jshint indent: false */

      var BLACK = 'b';
      var WHITE = 'w';

      var EMPTY = -1;

      var PAWN = 'p';
      var KNIGHT = 'n';
      var BISHOP = 'b';
      var ROOK = 'r';
      var QUEEN = 'q';
      var KING = 'k';

      var SYMBOLS = 'pnbrqkPNBRQK';

      var DEFAULT_POSITION = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';

      var POSSIBLE_RESULTS = ['1-0', '0-1', '1/2-1/2', '*'];

      var PAWN_OFFSETS = {
        b: [16, 32, 17, 15],
        w: [-16, -32, -17, -15]
      };

      var PIECE_OFFSETS = {
        n: [-18, -33, -31, -14,  18, 33, 31,  14],
        b: [-17, -15,  17,  15],
        r: [-16,   1,  16,  -1],
        q: [-17, -16, -15,   1,  17, 16, 15,  -1],
        k: [-17, -16, -15,   1,  17, 16, 15,  -1]
      };

      var ATTACKS = [
        20, 0, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0, 0,20, 0,
         0,20, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0,20, 0, 0,
         0, 0,20, 0, 0, 0, 0, 24,  0, 0, 0, 0,20, 0, 0, 0,
         0, 0, 0,20, 0, 0, 0, 24,  0, 0, 0,20, 0, 0, 0, 0,
         0, 0, 0, 0,20, 0, 0, 24,  0, 0,20, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0,20, 2, 24,  2,20, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 2,53, 56, 53, 2, 0, 0, 0, 0, 0, 0,
        24,24,24,24,24,24,56,  0, 56,24,24,24,24,24,24, 0,
         0, 0, 0, 0, 0, 2,53, 56, 53, 2, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0,20, 2, 24,  2,20, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0,20, 0, 0, 24,  0, 0,20, 0, 0, 0, 0, 0,
         0, 0, 0,20, 0, 0, 0, 24,  0, 0, 0,20, 0, 0, 0, 0,
         0, 0,20, 0, 0, 0, 0, 24,  0, 0, 0, 0,20, 0, 0, 0,
         0,20, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0,20, 0, 0,
        20, 0, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0, 0,20
      ];

      var RAYS = [
         17,  0,  0,  0,  0,  0,  0, 16,  0,  0,  0,  0,  0,  0, 15, 0,
          0, 17,  0,  0,  0,  0,  0, 16,  0,  0,  0,  0,  0, 15,  0, 0,
          0,  0, 17,  0,  0,  0,  0, 16,  0,  0,  0,  0, 15,  0,  0, 0,
          0,  0,  0, 17,  0,  0,  0, 16,  0,  0,  0, 15,  0,  0,  0, 0,
          0,  0,  0,  0, 17,  0,  0, 16,  0,  0, 15,  0,  0,  0,  0, 0,
          0,  0,  0,  0,  0, 17,  0, 16,  0, 15,  0,  0,  0,  0,  0, 0,
          0,  0,  0,  0,  0,  0, 17, 16, 15,  0,  0,  0,  0,  0,  0, 0,
          1,  1,  1,  1,  1,  1,  1,  0, -1, -1,  -1,-1, -1, -1, -1, 0,
          0,  0,  0,  0,  0,  0,-15,-16,-17,  0,  0,  0,  0,  0,  0, 0,
          0,  0,  0,  0,  0,-15,  0,-16,  0,-17,  0,  0,  0,  0,  0, 0,
          0,  0,  0,  0,-15,  0,  0,-16,  0,  0,-17,  0,  0,  0,  0, 0,
          0,  0,  0,-15,  0,  0,  0,-16,  0,  0,  0,-17,  0,  0,  0, 0,
          0,  0,-15,  0,  0,  0,  0,-16,  0,  0,  0,  0,-17,  0,  0, 0,
          0,-15,  0,  0,  0,  0,  0,-16,  0,  0,  0,  0,  0,-17,  0, 0,
        -15,  0,  0,  0,  0,  0,  0,-16,  0,  0,  0,  0,  0,  0,-17
      ];

      var SHIFTS = { p: 0, n: 1, b: 2, r: 3, q: 4, k: 5 };

      var FLAGS = {
        NORMAL: 'n',
        CAPTURE: 'c',
        BIG_PAWN: 'b',
        EP_CAPTURE: 'e',
        PROMOTION: 'p',
        KSIDE_CASTLE: 'k',
        QSIDE_CASTLE: 'q'
      };

      var BITS = {
        NORMAL: 1,
        CAPTURE: 2,
        BIG_PAWN: 4,
        EP_CAPTURE: 8,
        PROMOTION: 16,
        KSIDE_CASTLE: 32,
        QSIDE_CASTLE: 64
      };

      var RANK_1 = 7;
      var RANK_2 = 6;
      var RANK_3 = 5;
      var RANK_4 = 4;
      var RANK_5 = 3;
      var RANK_6 = 2;
      var RANK_7 = 1;
      var RANK_8 = 0;

      var SQUARES = {
        a8:   0, b8:   1, c8:   2, d8:   3, e8:   4, f8:   5, g8:   6, h8:   7,
        a7:  16, b7:  17, c7:  18, d7:  19, e7:  20, f7:  21, g7:  22, h7:  23,
        a6:  32, b6:  33, c6:  34, d6:  35, e6:  36, f6:  37, g6:  38, h6:  39,
        a5:  48, b5:  49, c5:  50, d5:  51, e5:  52, f5:  53, g5:  54, h5:  55,
        a4:  64, b4:  65, c4:  66, d4:  67, e4:  68, f4:  69, g4:  70, h4:  71,
        a3:  80, b3:  81, c3:  82, d3:  83, e3:  84, f3:  85, g3:  86, h3:  87,
        a2:  96, b2:  97, c2:  98, d2:  99, e2: 100, f2: 101, g2: 102, h2: 103,
        a1: 112, b1: 113, c1: 114, d1: 115, e1: 116, f1: 117, g1: 118, h1: 119
      };

      var ROOKS = {
        w: [{square: SQUARES.a1, flag: BITS.QSIDE_CASTLE},
            {square: SQUARES.h1, flag: BITS.KSIDE_CASTLE}],
        b: [{square: SQUARES.a8, flag: BITS.QSIDE_CASTLE},
            {square: SQUARES.h8, flag: BITS.KSIDE_CASTLE}]
      };

      var board = new Array(128);
      var kings = {w: EMPTY, b: EMPTY};
      var turn = WHITE;
      var castling = {w: 0, b: 0};
      var ep_square = EMPTY;
      var half_moves = 0;
      var move_number = 1;
      var history = [];
      var header = {};

      /* if the user passes in a fen string, load it, else default to
       * starting position
       */
      if (typeof fen === 'undefined') {
        load(DEFAULT_POSITION);
      } else {
        load(fen);
      }

      function clear() {
        board = new Array(128);
        kings = {w: EMPTY, b: EMPTY};
        turn = WHITE;
        castling = {w: 0, b: 0};
        ep_square = EMPTY;
        half_moves = 0;
        move_number = 1;
        history = [];
        header = {};
        update_setup(generate_fen());
      }

      function reset() {
        load(DEFAULT_POSITION);
      }

      function load(fen) {
        var tokens = fen.split(/\s+/);
        var position = tokens[0];
        var square = 0;

        if (!validate_fen(fen).valid) {
          return false;
        }

        clear();

        for (var i = 0; i < position.length; i++) {
          var piece = position.charAt(i);

          if (piece === '/') {
            square += 8;
          } else if (is_digit(piece)) {
            square += parseInt(piece, 10);
          } else {
            var color = (piece < 'a') ? WHITE : BLACK;
            put({type: piece.toLowerCase(), color: color}, algebraic(square));
            square++;
          }
        }

        turn = tokens[1];

        if (tokens[2].indexOf('K') > -1) {
          castling.w |= BITS.KSIDE_CASTLE;
        }
        if (tokens[2].indexOf('Q') > -1) {
          castling.w |= BITS.QSIDE_CASTLE;
        }
        if (tokens[2].indexOf('k') > -1) {
          castling.b |= BITS.KSIDE_CASTLE;
        }
        if (tokens[2].indexOf('q') > -1) {
          castling.b |= BITS.QSIDE_CASTLE;
        }

        ep_square = (tokens[3] === '-') ? EMPTY : SQUARES[tokens[3]];
        half_moves = parseInt(tokens[4], 10);
        move_number = parseInt(tokens[5], 10);

        update_setup(generate_fen());

        return true;
      }

      /* TODO: this function is pretty much crap - it validates structure but
       * completely ignores content (e.g. doesn't verify that each side has a king)
       * ... we should rewrite this, and ditch the silly error_number field while
       * we're at it
       */
      function validate_fen(fen) {
        var errors = {
           0: 'No errors.',
           1: 'FEN string must contain six space-delimited fields.',
           2: '6th field (move number) must be a positive integer.',
           3: '5th field (half move counter) must be a non-negative integer.',
           4: '4th field (en-passant square) is invalid.',
           5: '3rd field (castling availability) is invalid.',
           6: '2nd field (side to move) is invalid.',
           7: '1st field (piece positions) does not contain 8 \'/\'-delimited rows.',
           8: '1st field (piece positions) is invalid [consecutive numbers].',
           9: '1st field (piece positions) is invalid [invalid piece].',
          10: '1st field (piece positions) is invalid [row too large].',
          11: 'Illegal en-passant square',
        };

        /* 1st criterion: 6 space-seperated fields? */
        var tokens = fen.split(/\s+/);
        if (tokens.length !== 6) {
          return {valid: false, error_number: 1, error: errors[1]};
        }

        /* 2nd criterion: move number field is a integer value > 0? */
        if (isNaN(tokens[5]) || (parseInt(tokens[5], 10) <= 0)) {
          return {valid: false, error_number: 2, error: errors[2]};
        }

        /* 3rd criterion: half move counter is an integer >= 0? */
        if (isNaN(tokens[4]) || (parseInt(tokens[4], 10) < 0)) {
          return {valid: false, error_number: 3, error: errors[3]};
        }

        /* 4th criterion: 4th field is a valid e.p.-string? */
        if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {
          return {valid: false, error_number: 4, error: errors[4]};
        }

        /* 5th criterion: 3th field is a valid castle-string? */
        if( !/^(KQ?k?q?|Qk?q?|kq?|q|-)$/.test(tokens[2])) {
          return {valid: false, error_number: 5, error: errors[5]};
        }

        /* 6th criterion: 2nd field is "w" (white) or "b" (black)? */
        if (!/^(w|b)$/.test(tokens[1])) {
          return {valid: false, error_number: 6, error: errors[6]};
        }

        /* 7th criterion: 1st field contains 8 rows? */
        var rows = tokens[0].split('/');
        if (rows.length !== 8) {
          return {valid: false, error_number: 7, error: errors[7]};
        }

        /* 8th criterion: every row is valid? */
        for (var i = 0; i < rows.length; i++) {
          /* check for right sum of fields AND not two numbers in succession */
          var sum_fields = 0;
          var previous_was_number = false;

          for (var k = 0; k < rows[i].length; k++) {
            if (!isNaN(rows[i][k])) {
              if (previous_was_number) {
                return {valid: false, error_number: 8, error: errors[8]};
              }
              sum_fields += parseInt(rows[i][k], 10);
              previous_was_number = true;
            } else {
              if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {
                return {valid: false, error_number: 9, error: errors[9]};
              }
              sum_fields += 1;
              previous_was_number = false;
            }
          }
          if (sum_fields !== 8) {
            return {valid: false, error_number: 10, error: errors[10]};
          }
        }

        if ((tokens[3][1] == '3' && tokens[1] == 'w') ||
            (tokens[3][1] == '6' && tokens[1] == 'b')) {
              return {valid: false, error_number: 11, error: errors[11]};
        }

        /* everything's okay! */
        return {valid: true, error_number: 0, error: errors[0]};
      }

      function generate_fen() {
        var empty = 0;
        var fen = '';

        for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {
          if (board[i] == null) {
            empty++;
          } else {
            if (empty > 0) {
              fen += empty;
              empty = 0;
            }
            var color = board[i].color;
            var piece = board[i].type;

            fen += (color === WHITE) ?
                     piece.toUpperCase() : piece.toLowerCase();
          }

          if ((i + 1) & 0x88) {
            if (empty > 0) {
              fen += empty;
            }

            if (i !== SQUARES.h1) {
              fen += '/';
            }

            empty = 0;
            i += 8;
          }
        }

        var cflags = '';
        if (castling[WHITE] & BITS.KSIDE_CASTLE) { cflags += 'K'; }
        if (castling[WHITE] & BITS.QSIDE_CASTLE) { cflags += 'Q'; }
        if (castling[BLACK] & BITS.KSIDE_CASTLE) { cflags += 'k'; }
        if (castling[BLACK] & BITS.QSIDE_CASTLE) { cflags += 'q'; }

        /* do we have an empty castling flag? */
        cflags = cflags || '-';
        var epflags = (ep_square === EMPTY) ? '-' : algebraic(ep_square);

        return [fen, turn, cflags, epflags, half_moves, move_number].join(' ');
      }

      function set_header(args) {
        for (var i = 0; i < args.length; i += 2) {
          if (typeof args[i] === 'string' &&
              typeof args[i + 1] === 'string') {
            header[args[i]] = args[i + 1];
          }
        }
        return header;
      }

      /* called when the initial board setup is changed with put() or remove().
       * modifies the SetUp and FEN properties of the header object.  if the FEN is
       * equal to the default position, the SetUp and FEN are deleted
       * the setup is only updated if history.length is zero, ie moves haven't been
       * made.
       */
      function update_setup(fen) {
        if (history.length > 0) return;

        if (fen !== DEFAULT_POSITION) {
          header['SetUp'] = '1';
          header['FEN'] = fen;
        } else {
          delete header['SetUp'];
          delete header['FEN'];
        }
      }

      function get(square) {
        var piece = board[SQUARES[square]];
        return (piece) ? {type: piece.type, color: piece.color} : null;
      }

      function put(piece, square) {
        /* check for valid piece object */
        if (!('type' in piece && 'color' in piece)) {
          return false;
        }

        /* check for piece */
        if (SYMBOLS.indexOf(piece.type.toLowerCase()) === -1) {
          return false;
        }

        /* check for valid square */
        if (!(square in SQUARES)) {
          return false;
        }

        var sq = SQUARES[square];

        /* don't let the user place more than one king */
        if (piece.type == KING &&
            !(kings[piece.color] == EMPTY || kings[piece.color] == sq)) {
          return false;
        }

        board[sq] = {type: piece.type, color: piece.color};
        if (piece.type === KING) {
          kings[piece.color] = sq;
        }

        update_setup(generate_fen());

        return true;
      }

      function remove(square) {
        var piece = get(square);
        board[SQUARES[square]] = null;
        if (piece && piece.type === KING) {
          kings[piece.color] = EMPTY;
        }

        update_setup(generate_fen());

        return piece;
      }

      function build_move(board, from, to, flags, promotion) {
        var move = {
          color: turn,
          from: from,
          to: to,
          flags: flags,
          piece: board[from].type
        };

        if (promotion) {
          move.flags |= BITS.PROMOTION;
          move.promotion = promotion;
        }

        if (board[to]) {
          move.captured = board[to].type;
        } else if (flags & BITS.EP_CAPTURE) {
            move.captured = PAWN;
        }
        return move;
      }

      function generate_moves(options) {
        function add_move(board, moves, from, to, flags) {
          /* if pawn promotion */
          if (board[from].type === PAWN &&
             (rank(to) === RANK_8 || rank(to) === RANK_1)) {
              var pieces = [QUEEN, ROOK, BISHOP, KNIGHT];
              for (var i = 0, len = pieces.length; i < len; i++) {
                moves.push(build_move(board, from, to, flags, pieces[i]));
              }
          } else {
           moves.push(build_move(board, from, to, flags));
          }
        }

        var moves = [];
        var us = turn;
        var them = swap_color(us);
        var second_rank = {b: RANK_7, w: RANK_2};

        var first_sq = SQUARES.a8;
        var last_sq = SQUARES.h1;
        var single_square = false;

        /* do we want legal moves? */
        var legal = (typeof options !== 'undefined' && 'legal' in options) ?
                    options.legal : true;

        /* are we generating moves for a single square? */
        if (typeof options !== 'undefined' && 'square' in options) {
          if (options.square in SQUARES) {
            first_sq = last_sq = SQUARES[options.square];
            single_square = true;
          } else {
            /* invalid square */
            return [];
          }
        }

        for (var i = first_sq; i <= last_sq; i++) {
          /* did we run off the end of the board */
          if (i & 0x88) { i += 7; continue; }

          var piece = board[i];
          if (piece == null || piece.color !== us) {
            continue;
          }

          if (piece.type === PAWN) {
            /* single square, non-capturing */
            var square = i + PAWN_OFFSETS[us][0];
            if (board[square] == null) {
                add_move(board, moves, i, square, BITS.NORMAL);

              /* double square */
              var square = i + PAWN_OFFSETS[us][1];
              if (second_rank[us] === rank(i) && board[square] == null) {
                add_move(board, moves, i, square, BITS.BIG_PAWN);
              }
            }

            /* pawn captures */
            for (j = 2; j < 4; j++) {
              var square = i + PAWN_OFFSETS[us][j];
              if (square & 0x88) continue;

              if (board[square] != null &&
                  board[square].color === them) {
                  add_move(board, moves, i, square, BITS.CAPTURE);
              } else if (square === ep_square) {
                  add_move(board, moves, i, ep_square, BITS.EP_CAPTURE);
              }
            }
          } else {
            for (var j = 0, len = PIECE_OFFSETS[piece.type].length; j < len; j++) {
              var offset = PIECE_OFFSETS[piece.type][j];
              var square = i;

              while (true) {
                square += offset;
                if (square & 0x88) break;

                if (board[square] == null) {
                  add_move(board, moves, i, square, BITS.NORMAL);
                } else {
                  if (board[square].color === us) break;
                  add_move(board, moves, i, square, BITS.CAPTURE);
                  break;
                }

                /* break, if knight or king */
                if (piece.type === 'n' || piece.type === 'k') break;
              }
            }
          }
        }

        /* check for castling if: a) we're generating all moves, or b) we're doing
         * single square move generation on the king's square
         */
        if ((!single_square) || last_sq === kings[us]) {
          /* king-side castling */
          if (castling[us] & BITS.KSIDE_CASTLE) {
            var castling_from = kings[us];
            var castling_to = castling_from + 2;

            if (board[castling_from + 1] == null &&
                board[castling_to]       == null &&
                !attacked(them, kings[us]) &&
                !attacked(them, castling_from + 1) &&
                !attacked(them, castling_to)) {
              add_move(board, moves, kings[us] , castling_to,
                       BITS.KSIDE_CASTLE);
            }
          }

          /* queen-side castling */
          if (castling[us] & BITS.QSIDE_CASTLE) {
            var castling_from = kings[us];
            var castling_to = castling_from - 2;

            if (board[castling_from - 1] == null &&
                board[castling_from - 2] == null &&
                board[castling_from - 3] == null &&
                !attacked(them, kings[us]) &&
                !attacked(them, castling_from - 1) &&
                !attacked(them, castling_to)) {
              add_move(board, moves, kings[us], castling_to,
                       BITS.QSIDE_CASTLE);
            }
          }
        }

        /* return all pseudo-legal moves (this includes moves that allow the king
         * to be captured)
         */
        if (!legal) {
          return moves;
        }

        /* filter out illegal moves */
        var legal_moves = [];
        for (var i = 0, len = moves.length; i < len; i++) {
          make_move(moves[i]);
          if (!king_attacked(us)) {
            legal_moves.push(moves[i]);
          }
          undo_move();
        }

        return legal_moves;
      }

      /* convert a move from 0x88 coordinates to Standard Algebraic Notation
       * (SAN)
       *
       * @param {boolean} sloppy Use the sloppy SAN generator to work around over
       * disambiguation bugs in Fritz and Chessbase.  See below:
       *
       * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4
       * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned
       * 4. ... Ne7 is technically the valid SAN
       */
      function move_to_san(move, sloppy) {

        var output = '';

        if (move.flags & BITS.KSIDE_CASTLE) {
          output = 'O-O';
        } else if (move.flags & BITS.QSIDE_CASTLE) {
          output = 'O-O-O';
        } else {
          var disambiguator = get_disambiguator(move, sloppy);

          if (move.piece !== PAWN) {
            output += move.piece.toUpperCase() + disambiguator;
          }

          if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {
            if (move.piece === PAWN) {
              output += algebraic(move.from)[0];
            }
            output += 'x';
          }

          output += algebraic(move.to);

          if (move.flags & BITS.PROMOTION) {
            output += '=' + move.promotion.toUpperCase();
          }
        }

        make_move(move);
        if (in_check()) {
          if (in_checkmate()) {
            output += '#';
          } else {
            output += '+';
          }
        }
        undo_move();

        return output;
      }

      // parses all of the decorators out of a SAN string
      function stripped_san(move) {
        return move.replace(/=/,'').replace(/[+#]?[?!]*$/,'');
      }

      function attacked(color, square) {
        for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {
          /* did we run off the end of the board */
          if (i & 0x88) { i += 7; continue; }

          /* if empty square or wrong color */
          if (board[i] == null || board[i].color !== color) continue;

          var piece = board[i];
          var difference = i - square;
          var index = difference + 119;

          if (ATTACKS[index] & (1 << SHIFTS[piece.type])) {
            if (piece.type === PAWN) {
              if (difference > 0) {
                if (piece.color === WHITE) return true;
              } else {
                if (piece.color === BLACK) return true;
              }
              continue;
            }

            /* if the piece is a knight or a king */
            if (piece.type === 'n' || piece.type === 'k') return true;

            var offset = RAYS[index];
            var j = i + offset;

            var blocked = false;
            while (j !== square) {
              if (board[j] != null) { blocked = true; break; }
              j += offset;
            }

            if (!blocked) return true;
          }
        }

        return false;
      }

      function king_attacked(color) {
        return attacked(swap_color(color), kings[color]);
      }

      function in_check() {
        return king_attacked(turn);
      }

      function in_checkmate() {
        return in_check() && generate_moves().length === 0;
      }

      function in_stalemate() {
        return !in_check() && generate_moves().length === 0;
      }

      function insufficient_material() {
        var pieces = {};
        var bishops = [];
        var num_pieces = 0;
        var sq_color = 0;

        for (var i = SQUARES.a8; i<= SQUARES.h1; i++) {
          sq_color = (sq_color + 1) % 2;
          if (i & 0x88) { i += 7; continue; }

          var piece = board[i];
          if (piece) {
            pieces[piece.type] = (piece.type in pieces) ?
                                  pieces[piece.type] + 1 : 1;
            if (piece.type === BISHOP) {
              bishops.push(sq_color);
            }
            num_pieces++;
          }
        }

        /* k vs. k */
        if (num_pieces === 2) { return true; }

        /* k vs. kn .... or .... k vs. kb */
        else if (num_pieces === 3 && (pieces[BISHOP] === 1 ||
                                     pieces[KNIGHT] === 1)) { return true; }

        /* kb vs. kb where any number of bishops are all on the same color */
        else if (num_pieces === pieces[BISHOP] + 2) {
          var sum = 0;
          var len = bishops.length;
          for (var i = 0; i < len; i++) {
            sum += bishops[i];
          }
          if (sum === 0 || sum === len) { return true; }
        }

        return false;
      }

      function in_threefold_repetition() {
        /* TODO: while this function is fine for casual use, a better
         * implementation would use a Zobrist key (instead of FEN). the
         * Zobrist key would be maintained in the make_move/undo_move functions,
         * avoiding the costly that we do below.
         */
        var moves = [];
        var positions = {};
        var repetition = false;

        while (true) {
          var move = undo_move();
          if (!move) break;
          moves.push(move);
        }

        while (true) {
          /* remove the last two fields in the FEN string, they're not needed
           * when checking for draw by rep */
          var fen = generate_fen().split(' ').slice(0,4).join(' ');

          /* has the position occurred three or move times */
          positions[fen] = (fen in positions) ? positions[fen] + 1 : 1;
          if (positions[fen] >= 3) {
            repetition = true;
          }

          if (!moves.length) {
            break;
          }
          make_move(moves.pop());
        }

        return repetition;
      }

      function push(move) {
        history.push({
          move: move,
          kings: {b: kings.b, w: kings.w},
          turn: turn,
          castling: {b: castling.b, w: castling.w},
          ep_square: ep_square,
          half_moves: half_moves,
          move_number: move_number
        });
      }

      function make_move(move) {
        var us = turn;
        var them = swap_color(us);
        push(move);

        board[move.to] = board[move.from];
        board[move.from] = null;

        /* if ep capture, remove the captured pawn */
        if (move.flags & BITS.EP_CAPTURE) {
          if (turn === BLACK) {
            board[move.to - 16] = null;
          } else {
            board[move.to + 16] = null;
          }
        }

        /* if pawn promotion, replace with new piece */
        if (move.flags & BITS.PROMOTION) {
          board[move.to] = {type: move.promotion, color: us};
        }

        /* if we moved the king */
        if (board[move.to].type === KING) {
          kings[board[move.to].color] = move.to;

          /* if we castled, move the rook next to the king */
          if (move.flags & BITS.KSIDE_CASTLE) {
            var castling_to = move.to - 1;
            var castling_from = move.to + 1;
            board[castling_to] = board[castling_from];
            board[castling_from] = null;
          } else if (move.flags & BITS.QSIDE_CASTLE) {
            var castling_to = move.to + 1;
            var castling_from = move.to - 2;
            board[castling_to] = board[castling_from];
            board[castling_from] = null;
          }

          /* turn off castling */
          castling[us] = '';
        }

        /* turn off castling if we move a rook */
        if (castling[us]) {
          for (var i = 0, len = ROOKS[us].length; i < len; i++) {
            if (move.from === ROOKS[us][i].square &&
                castling[us] & ROOKS[us][i].flag) {
              castling[us] ^= ROOKS[us][i].flag;
              break;
            }
          }
        }

        /* turn off castling if we capture a rook */
        if (castling[them]) {
          for (var i = 0, len = ROOKS[them].length; i < len; i++) {
            if (move.to === ROOKS[them][i].square &&
                castling[them] & ROOKS[them][i].flag) {
              castling[them] ^= ROOKS[them][i].flag;
              break;
            }
          }
        }

        /* if big pawn move, update the en passant square */
        if (move.flags & BITS.BIG_PAWN) {
          if (turn === 'b') {
            ep_square = move.to - 16;
          } else {
            ep_square = move.to + 16;
          }
        } else {
          ep_square = EMPTY;
        }

        /* reset the 50 move counter if a pawn is moved or a piece is captured */
        if (move.piece === PAWN) {
          half_moves = 0;
        } else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {
          half_moves = 0;
        } else {
          half_moves++;
        }

        if (turn === BLACK) {
          move_number++;
        }
        turn = swap_color(turn);
      }

      function undo_move() {
        var old = history.pop();
        if (old == null) { return null; }

        var move = old.move;
        kings = old.kings;
        turn = old.turn;
        castling = old.castling;
        ep_square = old.ep_square;
        half_moves = old.half_moves;
        move_number = old.move_number;

        var us = turn;
        var them = swap_color(turn);

        board[move.from] = board[move.to];
        board[move.from].type = move.piece;  // to undo any promotions
        board[move.to] = null;

        if (move.flags & BITS.CAPTURE) {
          board[move.to] = {type: move.captured, color: them};
        } else if (move.flags & BITS.EP_CAPTURE) {
          var index;
          if (us === BLACK) {
            index = move.to - 16;
          } else {
            index = move.to + 16;
          }
          board[index] = {type: PAWN, color: them};
        }


        if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {
          var castling_to, castling_from;
          if (move.flags & BITS.KSIDE_CASTLE) {
            castling_to = move.to + 1;
            castling_from = move.to - 1;
          } else if (move.flags & BITS.QSIDE_CASTLE) {
            castling_to = move.to - 2;
            castling_from = move.to + 1;
          }

          board[castling_to] = board[castling_from];
          board[castling_from] = null;
        }

        return move;
      }

      /* this function is used to uniquely identify ambiguous moves */
      function get_disambiguator(move, sloppy) {
        var moves = generate_moves({legal: !sloppy});

        var from = move.from;
        var to = move.to;
        var piece = move.piece;

        var ambiguities = 0;
        var same_rank = 0;
        var same_file = 0;

        for (var i = 0, len = moves.length; i < len; i++) {
          var ambig_from = moves[i].from;
          var ambig_to = moves[i].to;
          var ambig_piece = moves[i].piece;

          /* if a move of the same piece type ends on the same to square, we'll
           * need to add a disambiguator to the algebraic notation
           */
          if (piece === ambig_piece && from !== ambig_from && to === ambig_to) {
            ambiguities++;

            if (rank(from) === rank(ambig_from)) {
              same_rank++;
            }

            if (file(from) === file(ambig_from)) {
              same_file++;
            }
          }
        }

        if (ambiguities > 0) {
          /* if there exists a similar moving piece on the same rank and file as
           * the move in question, use the square as the disambiguator
           */
          if (same_rank > 0 && same_file > 0) {
            return algebraic(from);
          }
          /* if the moving piece rests on the same file, use the rank symbol as the
           * disambiguator
           */
          else if (same_file > 0) {
            return algebraic(from).charAt(1);
          }
          /* else use the file symbol */
          else {
            return algebraic(from).charAt(0);
          }
        }

        return '';
      }

      function ascii() {
        var s = '   +------------------------+\n';
        for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {
          /* display the rank */
          if (file(i) === 0) {
            s += ' ' + '87654321'[rank(i)] + ' |';
          }

          /* empty piece */
          if (board[i] == null) {
            s += ' . ';
          } else {
            var piece = board[i].type;
            var color = board[i].color;
            var symbol = (color === WHITE) ?
                         piece.toUpperCase() : piece.toLowerCase();
            s += ' ' + symbol + ' ';
          }

          if ((i + 1) & 0x88) {
            s += '|\n';
            i += 8;
          }
        }
        s += '   +------------------------+\n';
        s += '     a  b  c  d  e  f  g  h\n';

        return s;
      }

      // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates
      function move_from_san(move, sloppy) {
        // strip off any move decorations: e.g Nf3+?!
        var clean_move = stripped_san(move);

        // if we're using the sloppy parser run a regex to grab piece, to, and from
        // this should parse invalid SAN like: Pe2-e4, Rc1c4, Qf3xf7
        if (sloppy) {
          var matches = clean_move.match(/([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/);
          if (matches) {
            var piece = matches[1];
            var from = matches[2];
            var to = matches[3];
            var promotion = matches[4];
          }
        }

        var moves = generate_moves();
        for (var i = 0, len = moves.length; i < len; i++) {
          // try the strict parser first, then the sloppy parser if requested
          // by the user
          if ((clean_move === stripped_san(move_to_san(moves[i]))) ||
              (sloppy && clean_move === stripped_san(move_to_san(moves[i], true)))) {
            return moves[i];
          } else {
            if (matches &&
                (!piece || piece.toLowerCase() == moves[i].piece) &&
                SQUARES[from] == moves[i].from &&
                SQUARES[to] == moves[i].to &&
                (!promotion || promotion.toLowerCase() == moves[i].promotion)) {
              return moves[i];
            }
          }
        }

        return null;
      }


      /*****************************************************************************
       * UTILITY FUNCTIONS
       ****************************************************************************/
      function rank(i) {
        return i >> 4;
      }

      function file(i) {
        return i & 15;
      }

      function algebraic(i){
        var f = file(i), r = rank(i);
        return 'abcdefgh'.substring(f,f+1) + '87654321'.substring(r,r+1);
      }

      function swap_color(c) {
        return c === WHITE ? BLACK : WHITE;
      }

      function is_digit(c) {
        return '0123456789'.indexOf(c) !== -1;
      }

      /* pretty = external move object */
      function make_pretty(ugly_move) {
        var move = clone(ugly_move);
        move.san = move_to_san(move, false);
        move.to = algebraic(move.to);
        move.from = algebraic(move.from);

        var flags = '';

        for (var flag in BITS) {
          if (BITS[flag] & move.flags) {
            flags += FLAGS[flag];
          }
        }
        move.flags = flags;

        return move;
      }

      function clone(obj) {
        var dupe = (obj instanceof Array) ? [] : {};

        for (var property in obj) {
          if (typeof property === 'object') {
            dupe[property] = clone(obj[property]);
          } else {
            dupe[property] = obj[property];
          }
        }

        return dupe;
      }

      function trim(str) {
        return str.replace(/^\s+|\s+$/g, '');
      }

      /*****************************************************************************
       * DEBUGGING UTILITIES
       ****************************************************************************/
      function perft(depth) {
        var moves = generate_moves({legal: false});
        var nodes = 0;
        var color = turn;

        for (var i = 0, len = moves.length; i < len; i++) {
          make_move(moves[i]);
          if (!king_attacked(color)) {
            if (depth - 1 > 0) {
              var child_nodes = perft(depth - 1);
              nodes += child_nodes;
            } else {
              nodes++;
            }
          }
          undo_move();
        }

        return nodes;
      }

      return {
        /***************************************************************************
         * PUBLIC CONSTANTS (is there a better way to do this?)
         **************************************************************************/
        WHITE: WHITE,
        BLACK: BLACK,
        PAWN: PAWN,
        KNIGHT: KNIGHT,
        BISHOP: BISHOP,
        ROOK: ROOK,
        QUEEN: QUEEN,
        KING: KING,
        SQUARES: (function() {
                    /* from the ECMA-262 spec (section 12.6.4):
                     * "The mechanics of enumerating the properties ... is
                     * implementation dependent"
                     * so: for (var sq in SQUARES) { keys.push(sq); } might not be
                     * ordered correctly
                     */
                    var keys = [];
                    for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {
                      if (i & 0x88) { i += 7; continue; }
                      keys.push(algebraic(i));
                    }
                    return keys;
                  })(),
        FLAGS: FLAGS,

        /***************************************************************************
         * PUBLIC API
         **************************************************************************/
        load: function(fen) {
          return load(fen);
        },

        reset: function() {
          return reset();
        },

        moves: function(options) {
          /* The internal representation of a chess move is in 0x88 format, and
           * not meant to be human-readable.  The code below converts the 0x88
           * square coordinates to algebraic coordinates.  It also prunes an
           * unnecessary move keys resulting from a verbose call.
           */

          var ugly_moves = generate_moves(options);
          var moves = [];

          for (var i = 0, len = ugly_moves.length; i < len; i++) {

            /* does the user want a full move object (most likely not), or just
             * SAN
             */
            if (typeof options !== 'undefined' && 'verbose' in options &&
                options.verbose) {
              moves.push(make_pretty(ugly_moves[i]));
            } else {
              moves.push(move_to_san(ugly_moves[i], false));
            }
          }

          return moves;
        },

        in_check: function() {
          return in_check();
        },

        in_checkmate: function() {
          return in_checkmate();
        },

        in_stalemate: function() {
          return in_stalemate();
        },

        in_draw: function() {
          return half_moves >= 100 ||
                 in_stalemate() ||
                 insufficient_material() ||
                 in_threefold_repetition();
        },

        insufficient_material: function() {
          return insufficient_material();
        },

        in_threefold_repetition: function() {
          return in_threefold_repetition();
        },

        game_over: function() {
          return half_moves >= 100 ||
                 in_checkmate() ||
                 in_stalemate() ||
                 insufficient_material() ||
                 in_threefold_repetition();
        },

        validate_fen: function(fen) {
          return validate_fen(fen);
        },

        fen: function() {
          return generate_fen();
        },

        pgn: function(options) {
          /* using the specification from http://www.chessclub.com/help/PGN-spec
           * example for html usage: .pgn({ max_width: 72, newline_char: "<br />" })
           */
          var newline = (typeof options === 'object' &&
                         typeof options.newline_char === 'string') ?
                         options.newline_char : '\n';
          var max_width = (typeof options === 'object' &&
                           typeof options.max_width === 'number') ?
                           options.max_width : 0;
          var result = [];
          var header_exists = false;

          /* add the PGN header headerrmation */
          for (var i in header) {
            /* TODO: order of enumerated properties in header object is not
             * guaranteed, see ECMA-262 spec (section 12.6.4)
             */
            result.push('[' + i + ' \"' + header[i] + '\"]' + newline);
            header_exists = true;
          }

          if (header_exists && history.length) {
            result.push(newline);
          }

          /* pop all of history onto reversed_history */
          var reversed_history = [];
          while (history.length > 0) {
            reversed_history.push(undo_move());
          }

          var moves = [];
          var move_string = '';

          /* build the list of moves.  a move_string looks like: "3. e3 e6" */
          while (reversed_history.length > 0) {
            var move = reversed_history.pop();

            /* if the position started with black to move, start PGN with 1. ... */
            if (!history.length && move.color === 'b') {
              move_string = move_number + '. ...';
            } else if (move.color === 'w') {
              /* store the previous generated move_string if we have one */
              if (move_string.length) {
                moves.push(move_string);
              }
              move_string = move_number + '.';
            }

            move_string = move_string + ' ' + move_to_san(move, false);
            make_move(move);
          }

          /* are there any other leftover moves? */
          if (move_string.length) {
            moves.push(move_string);
          }

          /* is there a result? */
          if (typeof header.Result !== 'undefined') {
            moves.push(header.Result);
          }

          /* history should be back to what is was before we started generating PGN,
           * so join together moves
           */
          if (max_width === 0) {
            return result.join('') + moves.join(' ');
          }

          /* wrap the PGN output at max_width */
          var current_width = 0;
          for (var i = 0; i < moves.length; i++) {
            /* if the current move will push past max_width */
            if (current_width + moves[i].length > max_width && i !== 0) {

              /* don't end the line with whitespace */
              if (result[result.length - 1] === ' ') {
                result.pop();
              }

              result.push(newline);
              current_width = 0;
            } else if (i !== 0) {
              result.push(' ');
              current_width++;
            }
            result.push(moves[i]);
            current_width += moves[i].length;
          }

          return result.join('');
        },

        load_pgn: function(pgn, options) {
          // allow the user to specify the sloppy move parser to work around over
          // disambiguation bugs in Fritz and Chessbase
          var sloppy = (typeof options !== 'undefined' && 'sloppy' in options) ?
                        options.sloppy : false;

          function mask(str) {
            return str.replace(/\\/g, '\\');
          }

          function has_keys(object) {
            for (var key in object) {
              return true;
            }
            return false;
          }

          function parse_pgn_header(header, options) {
            var newline_char = (typeof options === 'object' &&
                                typeof options.newline_char === 'string') ?
                                options.newline_char : '\r?\n';
            var header_obj = {};
            var headers = header.split(new RegExp(mask(newline_char)));
            var key = '';
            var value = '';

            for (var i = 0; i < headers.length; i++) {
              key = headers[i].replace(/^\[([A-Z][A-Za-z]*)\s.*\]$/, '$1');
              value = headers[i].replace(/^\[[A-Za-z]+\s"(.*)"\]$/, '$1');
              if (trim(key).length > 0) {
                header_obj[key] = value;
              }
            }

            return header_obj;
          }

          var newline_char = (typeof options === 'object' &&
                              typeof options.newline_char === 'string') ?
                              options.newline_char : '\r?\n';
          var regex = new RegExp('^(\\[(.|' + mask(newline_char) + ')*\\])' +
                                 '(' + mask(newline_char) + ')*' +
                                 '1.(' + mask(newline_char) + '|.)*$', 'g');

          /* get header part of the PGN file */
          var header_string = pgn.replace(regex, '$1');

          /* no info part given, begins with moves */
          if (header_string[0] !== '[') {
            header_string = '';
          }

          reset();

          /* parse PGN header */
          var headers = parse_pgn_header(header_string, options);
          for (var key in headers) {
            set_header([key, headers[key]]);
          }

          /* load the starting position indicated by [Setup '1'] and
          * [FEN position] */
          if (headers['SetUp'] === '1') {
              if (!(('FEN' in headers) && load(headers['FEN']))) {
                return false;
              }
          }

          /* delete header to get the moves */
          var ms = pgn.replace(header_string, '').replace(new RegExp(mask(newline_char), 'g'), ' ');

          /* delete comments */
          ms = ms.replace(/(\{[^}]+\})+?/g, '');

          /* delete recursive annotation variations */
          var rav_regex = /(\([^\(\)]+\))+?/g
          while (rav_regex.test(ms)) {
            ms = ms.replace(rav_regex, '');
          }

          /* delete move numbers */
          ms = ms.replace(/\d+\.(\.\.)?/g, '');

          /* delete ... indicating black to move */
          ms = ms.replace(/\.\.\./g, '');

          /* delete numeric annotation glyphs */
          ms = ms.replace(/\$\d+/g, '');

          /* trim and get array of moves */
          var moves = trim(ms).split(new RegExp(/\s+/));

          /* delete empty entries */
          moves = moves.join(',').replace(/,,+/g, ',').split(',');
          var move = '';

          for (var half_move = 0; half_move < moves.length - 1; half_move++) {
            move = move_from_san(moves[half_move], sloppy);

            /* move not possible! (don't clear the board to examine to show the
             * latest valid position)
             */
            if (move == null) {
              return false;
            } else {
              make_move(move);
            }
          }

          /* examine last move */
          move = moves[moves.length - 1];
          if (POSSIBLE_RESULTS.indexOf(move) > -1) {
            if (has_keys(header) && typeof header.Result === 'undefined') {
              set_header(['Result', move]);
            }
          }
          else {
            move = move_from_san(move, sloppy);
            if (move == null) {
              return false;
            } else {
              make_move(move);
            }
          }
          return true;
        },

        header: function() {
          return set_header(arguments);
        },

        ascii: function() {
          return ascii();
        },

        turn: function() {
          return turn;
        },

        move: function(move, options) {
          /* The move function can be called with in the following parameters:
           *
           * .move('Nxb7')      <- where 'move' is a case-sensitive SAN string
           *
           * .move({ from: 'h7', <- where the 'move' is a move object (additional
           *         to :'h8',      fields are ignored)
           *         promotion: 'q',
           *      })
           */

          // allow the user to specify the sloppy move parser to work around over
          // disambiguation bugs in Fritz and Chessbase
          var sloppy = (typeof options !== 'undefined' && 'sloppy' in options) ?
                        options.sloppy : false;

          var move_obj = null;

          if (typeof move === 'string') {
            move_obj = move_from_san(move, sloppy);
          } else if (typeof move === 'object') {
            var moves = generate_moves();

            /* convert the pretty move object to an ugly move object */
            for (var i = 0, len = moves.length; i < len; i++) {
              if (move.from === algebraic(moves[i].from) &&
                  move.to === algebraic(moves[i].to) &&
                  (!('promotion' in moves[i]) ||
                  move.promotion === moves[i].promotion)) {
                move_obj = moves[i];
                break;
              }
            }
          }

          /* failed to find move */
          if (!move_obj) {
            return null;
          }

          /* need to make a copy of move because we can't generate SAN after the
           * move is made
           */
          var pretty_move = make_pretty(move_obj);

          make_move(move_obj);

          return pretty_move;
        },

        undo: function() {
          var move = undo_move();
          return (move) ? make_pretty(move) : null;
        },

        clear: function() {
          return clear();
        },

        put: function(piece, square) {
          return put(piece, square);
        },

        get: function(square) {
          return get(square);
        },

        remove: function(square) {
          return remove(square);
        },

        perft: function(depth) {
          return perft(depth);
        },

        square_color: function(square) {
          if (square in SQUARES) {
            var sq_0x88 = SQUARES[square];
            return ((rank(sq_0x88) + file(sq_0x88)) % 2 === 0) ? 'light' : 'dark';
          }

          return null;
        },

        history: function(options) {
          var reversed_history = [];
          var move_history = [];
          var verbose = (typeof options !== 'undefined' && 'verbose' in options &&
                         options.verbose);

          while (history.length > 0) {
            reversed_history.push(undo_move());
          }

          while (reversed_history.length > 0) {
            var move = reversed_history.pop();
            if (verbose) {
              move_history.push(make_pretty(move));
            } else {
              move_history.push(move_to_san(move));
            }
            make_move(move);
          }

          return move_history;
        }

      };
    };

    /* export Chess object if using node or any other CommonJS compatible
     * environment */
    if (typeof exports !== 'undefined') exports.Chess = Chess;
    /* export Chess object for any RequireJS compatible environment */
    if (typeof define !== 'undefined') define( function () { return Chess;  });

    },{}],2:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.render = exports.anim = void 0;
    const util = require("./util");
    function anim(mutation, state) {
        return state.animation.enabled ? animate(mutation, state) : render(mutation, state);
    }
    exports.anim = anim;
    function render(mutation, state) {
        const result = mutation(state);
        state.dom.redraw();
        return result;
    }
    exports.render = render;
    function makePiece(key, piece) {
        return {
            key: key,
            pos: util.key2pos(key),
            piece: piece,
        };
    }
    function closer(piece, pieces) {
        return pieces.sort((p1, p2) => {
            return util.distanceSq(piece.pos, p1.pos) - util.distanceSq(piece.pos, p2.pos);
        })[0];
    }
    function computePlan(prevPieces, current) {
        const anims = new Map(), animedOrigs = [], fadings = new Map(), missings = [], news = [], prePieces = new Map();
        let curP, preP, vector;
        for (const [k, p] of prevPieces) {
            prePieces.set(k, makePiece(k, p));
        }
        for (const key of util.allKeys) {
            curP = current.pieces.get(key);
            preP = prePieces.get(key);
            if (curP) {
                if (preP) {
                    if (!util.samePiece(curP, preP.piece)) {
                        missings.push(preP);
                        news.push(makePiece(key, curP));
                    }
                }
                else
                    news.push(makePiece(key, curP));
            }
            else if (preP)
                missings.push(preP);
        }
        for (const newP of news) {
            preP = closer(newP, missings.filter(p => util.samePiece(newP.piece, p.piece)));
            if (preP) {
                vector = [preP.pos[0] - newP.pos[0], preP.pos[1] - newP.pos[1]];
                anims.set(newP.key, vector.concat(vector));
                animedOrigs.push(preP.key);
            }
        }
        for (const p of missings) {
            if (!animedOrigs.includes(p.key))
                fadings.set(p.key, p.piece);
        }
        return {
            anims: anims,
            fadings: fadings,
        };
    }
    function step(state, now) {
        const cur = state.animation.current;
        if (cur === undefined) {
            if (!state.dom.destroyed)
                state.dom.redrawNow();
            return;
        }
        const rest = 1 - (now - cur.start) * cur.frequency;
        if (rest <= 0) {
            state.animation.current = undefined;
            state.dom.redrawNow();
        }
        else {
            const ease = easing(rest);
            for (const cfg of cur.plan.anims.values()) {
                cfg[2] = cfg[0] * ease;
                cfg[3] = cfg[1] * ease;
            }
            state.dom.redrawNow(true);
            requestAnimationFrame((now = performance.now()) => step(state, now));
        }
    }
    function animate(mutation, state) {
        const prevPieces = new Map(state.pieces);
        const result = mutation(state);
        const plan = computePlan(prevPieces, state);
        if (plan.anims.size || plan.fadings.size) {
            const alreadyRunning = state.animation.current && state.animation.current.start;
            state.animation.current = {
                start: performance.now(),
                frequency: 1 / state.animation.duration,
                plan: plan,
            };
            if (!alreadyRunning)
                step(state, performance.now());
        }
        else {
            state.dom.redraw();
        }
        return result;
    }
    function easing(t) {
        return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
    }

    },{"./util":18}],3:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.start = void 0;
    const board = require("./board");
    const fen_1 = require("./fen");
    const config_1 = require("./config");
    const anim_1 = require("./anim");
    const drag_1 = require("./drag");
    const explosion_1 = require("./explosion");
    function start(state, redrawAll) {
        function toggleOrientation() {
            board.toggleOrientation(state);
            redrawAll();
        }
        return {
            set(config) {
                if (config.orientation && config.orientation !== state.orientation)
                    toggleOrientation();
                (config.fen ? anim_1.anim : anim_1.render)(state => config_1.configure(state, config), state);
            },
            state,
            getFen: () => fen_1.write(state.pieces),
            toggleOrientation,
            setPieces(pieces) {
                anim_1.anim(state => board.setPieces(state, pieces), state);
            },
            selectSquare(key, force) {
                if (key)
                    anim_1.anim(state => board.selectSquare(state, key, force), state);
                else if (state.selected) {
                    board.unselect(state);
                    state.dom.redraw();
                }
            },
            move(orig, dest) {
                anim_1.anim(state => board.baseMove(state, orig, dest), state);
            },
            newPiece(piece, key) {
                anim_1.anim(state => board.baseNewPiece(state, piece, key), state);
            },
            playPremove() {
                if (state.premovable.current) {
                    if (anim_1.anim(board.playPremove, state))
                        return true;
                    state.dom.redraw();
                }
                return false;
            },
            playPredrop(validate) {
                if (state.predroppable.current) {
                    const result = board.playPredrop(state, validate);
                    state.dom.redraw();
                    return result;
                }
                return false;
            },
            cancelPremove() {
                anim_1.render(board.unsetPremove, state);
            },
            cancelPredrop() {
                anim_1.render(board.unsetPredrop, state);
            },
            cancelMove() {
                anim_1.render(state => {
                    board.cancelMove(state);
                    drag_1.cancel(state);
                }, state);
            },
            stop() {
                anim_1.render(state => {
                    board.stop(state);
                    drag_1.cancel(state);
                }, state);
            },
            explode(keys) {
                explosion_1.explosion(state, keys);
            },
            setAutoShapes(shapes) {
                anim_1.render(state => (state.drawable.autoShapes = shapes), state);
            },
            setShapes(shapes) {
                anim_1.render(state => (state.drawable.shapes = shapes), state);
            },
            getKeyAtDomPos(pos) {
                return board.getKeyAtDomPos(pos, board.whitePov(state), state.dom.bounds());
            },
            redrawAll,
            dragNewPiece(piece, event, force) {
                drag_1.dragNewPiece(state, piece, event, force);
            },
            destroy() {
                board.stop(state);
                state.dom.unbind && state.dom.unbind();
                state.dom.destroyed = true;
            },
        };
    }
    exports.start = start;

    },{"./anim":2,"./board":4,"./config":6,"./drag":7,"./explosion":11,"./fen":12}],4:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.whitePov = exports.getSnappedKeyAtDomPos = exports.getKeyAtDomPos = exports.stop = exports.cancelMove = exports.playPredrop = exports.playPremove = exports.isDraggable = exports.canMove = exports.unselect = exports.setSelected = exports.selectSquare = exports.dropNewPiece = exports.userMove = exports.baseNewPiece = exports.baseMove = exports.unsetPredrop = exports.unsetPremove = exports.setCheck = exports.setPieces = exports.reset = exports.toggleOrientation = exports.callUserFunction = void 0;
    const util_1 = require("./util");
    const premove_1 = require("./premove");
    function callUserFunction(f, ...args) {
        if (f)
            setTimeout(() => f(...args), 1);
    }
    exports.callUserFunction = callUserFunction;
    function toggleOrientation(state) {
        state.orientation = util_1.opposite(state.orientation);
        state.animation.current = state.draggable.current = state.selected = undefined;
    }
    exports.toggleOrientation = toggleOrientation;
    function reset(state) {
        state.lastMove = undefined;
        unselect(state);
        unsetPremove(state);
        unsetPredrop(state);
    }
    exports.reset = reset;
    function setPieces(state, pieces) {
        for (const [key, piece] of pieces) {
            if (piece)
                state.pieces.set(key, piece);
            else
                state.pieces.delete(key);
        }
    }
    exports.setPieces = setPieces;
    function setCheck(state, color) {
        state.check = undefined;
        if (color === true)
            color = state.turnColor;
        if (color)
            for (const [k, p] of state.pieces) {
                if (p.role === 'king' && p.color === color) {
                    state.check = k;
                }
            }
    }
    exports.setCheck = setCheck;
    function setPremove(state, orig, dest, meta) {
        unsetPredrop(state);
        state.premovable.current = [orig, dest];
        callUserFunction(state.premovable.events.set, orig, dest, meta);
    }
    function unsetPremove(state) {
        if (state.premovable.current) {
            state.premovable.current = undefined;
            callUserFunction(state.premovable.events.unset);
        }
    }
    exports.unsetPremove = unsetPremove;
    function setPredrop(state, role, key) {
        unsetPremove(state);
        state.predroppable.current = { role, key };
        callUserFunction(state.predroppable.events.set, role, key);
    }
    function unsetPredrop(state) {
        const pd = state.predroppable;
        if (pd.current) {
            pd.current = undefined;
            callUserFunction(pd.events.unset);
        }
    }
    exports.unsetPredrop = unsetPredrop;
    function tryAutoCastle(state, orig, dest) {
        if (!state.autoCastle)
            return false;
        const king = state.pieces.get(orig);
        if (!king || king.role !== 'king')
            return false;
        const origPos = util_1.key2pos(orig);
        const destPos = util_1.key2pos(dest);
        if ((origPos[1] !== 0 && origPos[1] !== 7) || origPos[1] !== destPos[1])
            return false;
        if (origPos[0] === 4 && !state.pieces.has(dest)) {
            if (destPos[0] === 6)
                dest = util_1.pos2key([7, destPos[1]]);
            else if (destPos[0] === 2)
                dest = util_1.pos2key([0, destPos[1]]);
        }
        const rook = state.pieces.get(dest);
        if (!rook || rook.color !== king.color || rook.role !== 'rook')
            return false;
        state.pieces.delete(orig);
        state.pieces.delete(dest);
        if (origPos[0] < destPos[0]) {
            state.pieces.set(util_1.pos2key([6, destPos[1]]), king);
            state.pieces.set(util_1.pos2key([5, destPos[1]]), rook);
        }
        else {
            state.pieces.set(util_1.pos2key([2, destPos[1]]), king);
            state.pieces.set(util_1.pos2key([3, destPos[1]]), rook);
        }
        return true;
    }
    function baseMove(state, orig, dest) {
        const origPiece = state.pieces.get(orig), destPiece = state.pieces.get(dest);
        if (orig === dest || !origPiece)
            return false;
        const captured = destPiece && destPiece.color !== origPiece.color ? destPiece : undefined;
        if (dest === state.selected)
            unselect(state);
        callUserFunction(state.events.move, orig, dest, captured);
        if (!tryAutoCastle(state, orig, dest)) {
            state.pieces.set(dest, origPiece);
            state.pieces.delete(orig);
        }
        state.lastMove = [orig, dest];
        state.check = undefined;
        callUserFunction(state.events.change);
        return captured || true;
    }
    exports.baseMove = baseMove;
    function baseNewPiece(state, piece, key, force) {
        if (state.pieces.has(key)) {
            if (force)
                state.pieces.delete(key);
            else
                return false;
        }
        callUserFunction(state.events.dropNewPiece, piece, key);
        state.pieces.set(key, piece);
        state.lastMove = [key];
        state.check = undefined;
        callUserFunction(state.events.change);
        state.movable.dests = undefined;
        state.turnColor = util_1.opposite(state.turnColor);
        return true;
    }
    exports.baseNewPiece = baseNewPiece;
    function baseUserMove(state, orig, dest) {
        const result = baseMove(state, orig, dest);
        if (result) {
            state.movable.dests = undefined;
            state.turnColor = util_1.opposite(state.turnColor);
            state.animation.current = undefined;
        }
        return result;
    }
    function userMove(state, orig, dest) {
        if (canMove(state, orig, dest)) {
            const result = baseUserMove(state, orig, dest);
            if (result) {
                const holdTime = state.hold.stop();
                unselect(state);
                const metadata = {
                    premove: false,
                    ctrlKey: state.stats.ctrlKey,
                    holdTime,
                };
                if (result !== true)
                    metadata.captured = result;
                callUserFunction(state.movable.events.after, orig, dest, metadata);
                return true;
            }
        }
        else if (canPremove(state, orig, dest)) {
            setPremove(state, orig, dest, {
                ctrlKey: state.stats.ctrlKey,
            });
            unselect(state);
            return true;
        }
        unselect(state);
        return false;
    }
    exports.userMove = userMove;
    function dropNewPiece(state, orig, dest, force) {
        const piece = state.pieces.get(orig);
        if (piece && (canDrop(state, orig, dest) || force)) {
            state.pieces.delete(orig);
            baseNewPiece(state, piece, dest, force);
            callUserFunction(state.movable.events.afterNewPiece, piece.role, dest, {
                premove: false,
                predrop: false,
            });
        }
        else if (piece && canPredrop(state, orig, dest)) {
            setPredrop(state, piece.role, dest);
        }
        else {
            unsetPremove(state);
            unsetPredrop(state);
        }
        state.pieces.delete(orig);
        unselect(state);
    }
    exports.dropNewPiece = dropNewPiece;
    function selectSquare(state, key, force) {
        callUserFunction(state.events.select, key);
        if (state.selected) {
            if (state.selected === key && !state.draggable.enabled) {
                unselect(state);
                state.hold.cancel();
                return;
            }
            else if ((state.selectable.enabled || force) && state.selected !== key) {
                if (userMove(state, state.selected, key)) {
                    state.stats.dragged = false;
                    return;
                }
            }
        }
        if (isMovable(state, key) || isPremovable(state, key)) {
            setSelected(state, key);
            state.hold.start();
        }
    }
    exports.selectSquare = selectSquare;
    function setSelected(state, key) {
        state.selected = key;
        if (isPremovable(state, key)) {
            state.premovable.dests = premove_1.premove(state.pieces, key, state.premovable.castle);
        }
        else
            state.premovable.dests = undefined;
    }
    exports.setSelected = setSelected;
    function unselect(state) {
        state.selected = undefined;
        state.premovable.dests = undefined;
        state.hold.cancel();
    }
    exports.unselect = unselect;
    function isMovable(state, orig) {
        const piece = state.pieces.get(orig);
        return (!!piece &&
            (state.movable.color === 'both' || (state.movable.color === piece.color && state.turnColor === piece.color)));
    }
    function canMove(state, orig, dest) {
        var _a, _b;
        return (orig !== dest && isMovable(state, orig) && (state.movable.free || !!((_b = (_a = state.movable.dests) === null || _a === void 0 ? void 0 : _a.get(orig)) === null || _b === void 0 ? void 0 : _b.includes(dest))));
    }
    exports.canMove = canMove;
    function canDrop(state, orig, dest) {
        const piece = state.pieces.get(orig);
        return (!!piece &&
            (orig === dest || !state.pieces.has(dest)) &&
            (state.movable.color === 'both' || (state.movable.color === piece.color && state.turnColor === piece.color)));
    }
    function isPremovable(state, orig) {
        const piece = state.pieces.get(orig);
        return !!piece && state.premovable.enabled && state.movable.color === piece.color && state.turnColor !== piece.color;
    }
    function canPremove(state, orig, dest) {
        return (orig !== dest && isPremovable(state, orig) && premove_1.premove(state.pieces, orig, state.premovable.castle).includes(dest));
    }
    function canPredrop(state, orig, dest) {
        const piece = state.pieces.get(orig);
        const destPiece = state.pieces.get(dest);
        return (!!piece &&
            (!destPiece || destPiece.color !== state.movable.color) &&
            state.predroppable.enabled &&
            (piece.role !== 'pawn' || (dest[1] !== '1' && dest[1] !== '8')) &&
            state.movable.color === piece.color &&
            state.turnColor !== piece.color);
    }
    function isDraggable(state, orig) {
        const piece = state.pieces.get(orig);
        return (!!piece &&
            state.draggable.enabled &&
            (state.movable.color === 'both' ||
                (state.movable.color === piece.color && (state.turnColor === piece.color || state.premovable.enabled))));
    }
    exports.isDraggable = isDraggable;
    function playPremove(state) {
        const move = state.premovable.current;
        if (!move)
            return false;
        const orig = move[0], dest = move[1];
        let success = false;
        if (canMove(state, orig, dest)) {
            const result = baseUserMove(state, orig, dest);
            if (result) {
                const metadata = { premove: true };
                if (result !== true)
                    metadata.captured = result;
                callUserFunction(state.movable.events.after, orig, dest, metadata);
                success = true;
            }
        }
        unsetPremove(state);
        return success;
    }
    exports.playPremove = playPremove;
    function playPredrop(state, validate) {
        const drop = state.predroppable.current;
        let success = false;
        if (!drop)
            return false;
        if (validate(drop)) {
            const piece = {
                role: drop.role,
                color: state.movable.color,
            };
            if (baseNewPiece(state, piece, drop.key)) {
                callUserFunction(state.movable.events.afterNewPiece, drop.role, drop.key, {
                    premove: false,
                    predrop: true,
                });
                success = true;
            }
        }
        unsetPredrop(state);
        return success;
    }
    exports.playPredrop = playPredrop;
    function cancelMove(state) {
        unsetPremove(state);
        unsetPredrop(state);
        unselect(state);
    }
    exports.cancelMove = cancelMove;
    function stop(state) {
        state.movable.color = state.movable.dests = state.animation.current = undefined;
        cancelMove(state);
    }
    exports.stop = stop;
    function getKeyAtDomPos(pos, asWhite, bounds) {
        let file = Math.floor((8 * (pos[0] - bounds.left)) / bounds.width);
        if (!asWhite)
            file = 7 - file;
        let rank = 7 - Math.floor((8 * (pos[1] - bounds.top)) / bounds.height);
        if (!asWhite)
            rank = 7 - rank;
        return file >= 0 && file < 8 && rank >= 0 && rank < 8 ? util_1.pos2key([file, rank]) : undefined;
    }
    exports.getKeyAtDomPos = getKeyAtDomPos;
    function getSnappedKeyAtDomPos(orig, pos, asWhite, bounds) {
        const origPos = util_1.key2pos(orig);
        const validSnapPos = util_1.allPos.filter(pos2 => {
            return premove_1.queen(origPos[0], origPos[1], pos2[0], pos2[1]) || premove_1.knight(origPos[0], origPos[1], pos2[0], pos2[1]);
        });
        const validSnapCenters = validSnapPos.map(pos2 => util_1.computeSquareCenter(util_1.pos2key(pos2), asWhite, bounds));
        const validSnapDistances = validSnapCenters.map(pos2 => util_1.distanceSq(pos, pos2));
        const [, closestSnapIndex] = validSnapDistances.reduce((a, b, index) => (a[0] < b ? a : [b, index]), [
            validSnapDistances[0],
            0,
        ]);
        return util_1.pos2key(validSnapPos[closestSnapIndex]);
    }
    exports.getSnappedKeyAtDomPos = getSnappedKeyAtDomPos;
    function whitePov(s) {
        return s.orientation === 'white';
    }
    exports.whitePov = whitePov;

    },{"./premove":13,"./util":18}],5:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Chessground = void 0;
    const api_1 = require("./api");
    const config_1 = require("./config");
    const state_1 = require("./state");
    const wrap_1 = require("./wrap");
    const events = require("./events");
    const render_1 = require("./render");
    const svg = require("./svg");
    const util = require("./util");
    function Chessground(element, config) {
        const maybeState = state_1.defaults();
        config_1.configure(maybeState, config || {});
        function redrawAll() {
            const prevUnbind = 'dom' in maybeState ? maybeState.dom.unbind : undefined;
            const relative = maybeState.viewOnly && !maybeState.drawable.visible, elements = wrap_1.renderWrap(element, maybeState, relative), bounds = util.memo(() => elements.board.getBoundingClientRect()), redrawNow = (skipSvg) => {
                render_1.render(state);
                if (!skipSvg && elements.svg)
                    svg.renderSvg(state, elements.svg, elements.customSvg);
            }, boundsUpdated = () => {
                bounds.clear();
                render_1.updateBounds(state);
                if (elements.svg)
                    svg.renderSvg(state, elements.svg, elements.customSvg);
            };
            const state = maybeState;
            state.dom = {
                elements,
                bounds,
                redraw: debounceRedraw(redrawNow),
                redrawNow,
                unbind: prevUnbind,
                relative,
            };
            state.drawable.prevSvgHash = '';
            redrawNow(false);
            events.bindBoard(state, boundsUpdated);
            if (!prevUnbind)
                state.dom.unbind = events.bindDocument(state, boundsUpdated);
            state.events.insert && state.events.insert(elements);
            return state;
        }
        return api_1.start(redrawAll(), redrawAll);
    }
    exports.Chessground = Chessground;
    function debounceRedraw(redrawNow) {
        let redrawing = false;
        return () => {
            if (redrawing)
                return;
            redrawing = true;
            requestAnimationFrame(() => {
                redrawNow();
                redrawing = false;
            });
        };
    }

    },{"./api":3,"./config":6,"./events":10,"./render":14,"./state":15,"./svg":16,"./util":18,"./wrap":19}],6:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.configure = void 0;
    const board_1 = require("./board");
    const fen_1 = require("./fen");
    function configure(state, config) {
        var _a;
        if ((_a = config.movable) === null || _a === void 0 ? void 0 : _a.dests)
            state.movable.dests = undefined;
        merge(state, config);
        if (config.fen) {
            state.pieces = fen_1.read(config.fen);
            state.drawable.shapes = [];
        }
        if (config.hasOwnProperty('check'))
            board_1.setCheck(state, config.check || false);
        if (config.hasOwnProperty('lastMove') && !config.lastMove)
            state.lastMove = undefined;
        else if (config.lastMove)
            state.lastMove = config.lastMove;
        if (state.selected)
            board_1.setSelected(state, state.selected);
        if (!state.animation.duration || state.animation.duration < 100)
            state.animation.enabled = false;
        if (!state.movable.rookCastle && state.movable.dests) {
            const rank = state.movable.color === 'white' ? '1' : '8', kingStartPos = ('e' + rank), dests = state.movable.dests.get(kingStartPos), king = state.pieces.get(kingStartPos);
            if (!dests || !king || king.role !== 'king')
                return;
            state.movable.dests.set(kingStartPos, dests.filter(d => !(d === 'a' + rank && dests.includes(('c' + rank))) &&
                !(d === 'h' + rank && dests.includes(('g' + rank)))));
        }
    }
    exports.configure = configure;
    function merge(base, extend) {
        for (const key in extend) {
            if (isObject(base[key]) && isObject(extend[key]))
                merge(base[key], extend[key]);
            else
                base[key] = extend[key];
        }
    }
    function isObject(o) {
        return typeof o === 'object';
    }

    },{"./board":4,"./fen":12}],7:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.cancel = exports.end = exports.move = exports.dragNewPiece = exports.start = void 0;
    const board = require("./board");
    const util = require("./util");
    const draw_1 = require("./draw");
    const anim_1 = require("./anim");
    function start(s, e) {
        if (!e.isTrusted || (e.button !== undefined && e.button !== 0))
            return;
        if (e.touches && e.touches.length > 1)
            return;
        const bounds = s.dom.bounds(), position = util.eventPosition(e), orig = board.getKeyAtDomPos(position, board.whitePov(s), bounds);
        if (!orig)
            return;
        const piece = s.pieces.get(orig);
        const previouslySelected = s.selected;
        if (!previouslySelected && s.drawable.enabled && (s.drawable.eraseOnClick || !piece || piece.color !== s.turnColor))
            draw_1.clear(s);
        if (e.cancelable !== false &&
            (!e.touches || !s.movable.color || piece || previouslySelected || pieceCloseTo(s, position)))
            e.preventDefault();
        const hadPremove = !!s.premovable.current;
        const hadPredrop = !!s.predroppable.current;
        s.stats.ctrlKey = e.ctrlKey;
        if (s.selected && board.canMove(s, s.selected, orig)) {
            anim_1.anim(state => board.selectSquare(state, orig), s);
        }
        else {
            board.selectSquare(s, orig);
        }
        const stillSelected = s.selected === orig;
        const element = pieceElementByKey(s, orig);
        if (piece && element && stillSelected && board.isDraggable(s, orig)) {
            s.draggable.current = {
                orig,
                piece,
                origPos: position,
                pos: position,
                started: s.draggable.autoDistance && s.stats.dragged,
                element,
                previouslySelected,
                originTarget: e.target,
            };
            element.cgDragging = true;
            element.classList.add('dragging');
            const ghost = s.dom.elements.ghost;
            if (ghost) {
                ghost.className = `ghost ${piece.color} ${piece.role}`;
                util.translateAbs(ghost, util.posToTranslateAbs(bounds)(util.key2pos(orig), board.whitePov(s)));
                util.setVisible(ghost, true);
            }
            processDrag(s);
        }
        else {
            if (hadPremove)
                board.unsetPremove(s);
            if (hadPredrop)
                board.unsetPredrop(s);
        }
        s.dom.redraw();
    }
    exports.start = start;
    function pieceCloseTo(s, pos) {
        const asWhite = board.whitePov(s), bounds = s.dom.bounds(), radiusSq = Math.pow(bounds.width / 8, 2);
        for (const key in s.pieces) {
            const center = util.computeSquareCenter(key, asWhite, bounds);
            if (util.distanceSq(center, pos) <= radiusSq)
                return true;
        }
        return false;
    }
    function dragNewPiece(s, piece, e, force) {
        const key = 'a0';
        s.pieces.set(key, piece);
        s.dom.redraw();
        const position = util.eventPosition(e);
        s.draggable.current = {
            orig: key,
            piece,
            origPos: position,
            pos: position,
            started: true,
            element: () => pieceElementByKey(s, key),
            originTarget: e.target,
            newPiece: true,
            force: !!force,
        };
        processDrag(s);
    }
    exports.dragNewPiece = dragNewPiece;
    function processDrag(s) {
        requestAnimationFrame(() => {
            var _a;
            const cur = s.draggable.current;
            if (!cur)
                return;
            if ((_a = s.animation.current) === null || _a === void 0 ? void 0 : _a.plan.anims.has(cur.orig))
                s.animation.current = undefined;
            const origPiece = s.pieces.get(cur.orig);
            if (!origPiece || !util.samePiece(origPiece, cur.piece))
                cancel(s);
            else {
                if (!cur.started && util.distanceSq(cur.pos, cur.origPos) >= Math.pow(s.draggable.distance, 2))
                    cur.started = true;
                if (cur.started) {
                    if (typeof cur.element === 'function') {
                        const found = cur.element();
                        if (!found)
                            return;
                        found.cgDragging = true;
                        found.classList.add('dragging');
                        cur.element = found;
                    }
                    const bounds = s.dom.bounds();
                    util.translateAbs(cur.element, [
                        cur.pos[0] - bounds.left - bounds.width / 16,
                        cur.pos[1] - bounds.top - bounds.height / 16,
                    ]);
                }
            }
            processDrag(s);
        });
    }
    function move(s, e) {
        if (s.draggable.current && (!e.touches || e.touches.length < 2)) {
            s.draggable.current.pos = util.eventPosition(e);
        }
    }
    exports.move = move;
    function end(s, e) {
        const cur = s.draggable.current;
        if (!cur)
            return;
        if (e.type === 'touchend' && e.cancelable !== false)
            e.preventDefault();
        if (e.type === 'touchend' && cur.originTarget !== e.target && !cur.newPiece) {
            s.draggable.current = undefined;
            return;
        }
        board.unsetPremove(s);
        board.unsetPredrop(s);
        const eventPos = util.eventPosition(e) || cur.pos;
        const dest = board.getKeyAtDomPos(eventPos, board.whitePov(s), s.dom.bounds());
        if (dest && cur.started && cur.orig !== dest) {
            if (cur.newPiece)
                board.dropNewPiece(s, cur.orig, dest, cur.force);
            else {
                s.stats.ctrlKey = e.ctrlKey;
                if (board.userMove(s, cur.orig, dest))
                    s.stats.dragged = true;
            }
        }
        else if (cur.newPiece) {
            s.pieces.delete(cur.orig);
        }
        else if (s.draggable.deleteOnDropOff && !dest) {
            s.pieces.delete(cur.orig);
            board.callUserFunction(s.events.change);
        }
        if (cur.orig === cur.previouslySelected && (cur.orig === dest || !dest))
            board.unselect(s);
        else if (!s.selectable.enabled)
            board.unselect(s);
        removeDragElements(s);
        s.draggable.current = undefined;
        s.dom.redraw();
    }
    exports.end = end;
    function cancel(s) {
        const cur = s.draggable.current;
        if (cur) {
            if (cur.newPiece)
                s.pieces.delete(cur.orig);
            s.draggable.current = undefined;
            board.unselect(s);
            removeDragElements(s);
            s.dom.redraw();
        }
    }
    exports.cancel = cancel;
    function removeDragElements(s) {
        const e = s.dom.elements;
        if (e.ghost)
            util.setVisible(e.ghost, false);
    }
    function pieceElementByKey(s, key) {
        let el = s.dom.elements.board.firstChild;
        while (el) {
            if (el.cgKey === key && el.tagName === 'PIECE')
                return el;
            el = el.nextSibling;
        }
        return;
    }

    },{"./anim":2,"./board":4,"./draw":8,"./util":18}],8:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.clear = exports.cancel = exports.end = exports.move = exports.processDraw = exports.start = void 0;
    const board_1 = require("./board");
    const util_1 = require("./util");
    const brushes = ['green', 'red', 'blue', 'yellow'];
    function start(state, e) {
        if (e.touches && e.touches.length > 1)
            return;
        e.stopPropagation();
        e.preventDefault();
        e.ctrlKey ? board_1.unselect(state) : board_1.cancelMove(state);
        const pos = util_1.eventPosition(e), orig = board_1.getKeyAtDomPos(pos, board_1.whitePov(state), state.dom.bounds());
        if (!orig)
            return;
        state.drawable.current = {
            orig,
            pos,
            brush: eventBrush(e),
            snapToValidMove: state.drawable.defaultSnapToValidMove,
        };
        processDraw(state);
    }
    exports.start = start;
    function processDraw(state) {
        requestAnimationFrame(() => {
            const cur = state.drawable.current;
            if (cur) {
                const keyAtDomPos = board_1.getKeyAtDomPos(cur.pos, board_1.whitePov(state), state.dom.bounds());
                if (!keyAtDomPos) {
                    cur.snapToValidMove = false;
                }
                const mouseSq = cur.snapToValidMove
                    ? board_1.getSnappedKeyAtDomPos(cur.orig, cur.pos, board_1.whitePov(state), state.dom.bounds())
                    : keyAtDomPos;
                if (mouseSq !== cur.mouseSq) {
                    cur.mouseSq = mouseSq;
                    cur.dest = mouseSq !== cur.orig ? mouseSq : undefined;
                    state.dom.redrawNow();
                }
                processDraw(state);
            }
        });
    }
    exports.processDraw = processDraw;
    function move(state, e) {
        if (state.drawable.current)
            state.drawable.current.pos = util_1.eventPosition(e);
    }
    exports.move = move;
    function end(state) {
        const cur = state.drawable.current;
        if (cur) {
            if (cur.mouseSq)
                addShape(state.drawable, cur);
            cancel(state);
        }
    }
    exports.end = end;
    function cancel(state) {
        if (state.drawable.current) {
            state.drawable.current = undefined;
            state.dom.redraw();
        }
    }
    exports.cancel = cancel;
    function clear(state) {
        if (state.drawable.shapes.length) {
            state.drawable.shapes = [];
            state.dom.redraw();
            onChange(state.drawable);
        }
    }
    exports.clear = clear;
    function eventBrush(e) {
        var _a;
        const modA = (e.shiftKey || e.ctrlKey) && util_1.isRightButton(e);
        const modB = e.altKey || e.metaKey || ((_a = e.getModifierState) === null || _a === void 0 ? void 0 : _a.call(e, 'AltGraph'));
        return brushes[(modA ? 1 : 0) + (modB ? 2 : 0)];
    }
    function addShape(drawable, cur) {
        const sameShape = (s) => s.orig === cur.orig && s.dest === cur.dest;
        const similar = drawable.shapes.find(sameShape);
        if (similar)
            drawable.shapes = drawable.shapes.filter(s => !sameShape(s));
        if (!similar || similar.brush !== cur.brush)
            drawable.shapes.push(cur);
        onChange(drawable);
    }
    function onChange(drawable) {
        if (drawable.onChange)
            drawable.onChange(drawable.shapes);
    }

    },{"./board":4,"./util":18}],9:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.drop = exports.cancelDropMode = exports.setDropMode = void 0;
    const board = require("./board");
    const util = require("./util");
    const drag_1 = require("./drag");
    function setDropMode(s, piece) {
        s.dropmode = {
            active: true,
            piece,
        };
        drag_1.cancel(s);
    }
    exports.setDropMode = setDropMode;
    function cancelDropMode(s) {
        s.dropmode = {
            active: false,
        };
    }
    exports.cancelDropMode = cancelDropMode;
    function drop(s, e) {
        if (!s.dropmode.active)
            return;
        board.unsetPremove(s);
        board.unsetPredrop(s);
        const piece = s.dropmode.piece;
        if (piece) {
            s.pieces.set('a0', piece);
            const position = util.eventPosition(e);
            const dest = position && board.getKeyAtDomPos(position, board.whitePov(s), s.dom.bounds());
            if (dest)
                board.dropNewPiece(s, 'a0', dest);
        }
        s.dom.redraw();
    }
    exports.drop = drop;

    },{"./board":4,"./drag":7,"./util":18}],10:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bindDocument = exports.bindBoard = void 0;
    const drag = require("./drag");
    const draw = require("./draw");
    const drop_1 = require("./drop");
    const util_1 = require("./util");
    function bindBoard(s, boundsUpdated) {
        const boardEl = s.dom.elements.board;
        if (!s.dom.relative && s.resizable && 'ResizeObserver' in window) {
            const observer = new window['ResizeObserver'](boundsUpdated);
            observer.observe(boardEl);
        }
        if (s.viewOnly)
            return;
        const onStart = startDragOrDraw(s);
        boardEl.addEventListener('touchstart', onStart, {
            passive: false,
        });
        boardEl.addEventListener('mousedown', onStart, {
            passive: false,
        });
        if (s.disableContextMenu || s.drawable.enabled) {
            boardEl.addEventListener('contextmenu', e => e.preventDefault());
        }
    }
    exports.bindBoard = bindBoard;
    function bindDocument(s, boundsUpdated) {
        const unbinds = [];
        if (!s.dom.relative && s.resizable && !('ResizeObserver' in window)) {
            unbinds.push(unbindable(document.body, 'chessground.resize', boundsUpdated));
        }
        if (!s.viewOnly) {
            const onmove = dragOrDraw(s, drag.move, draw.move);
            const onend = dragOrDraw(s, drag.end, draw.end);
            for (const ev of ['touchmove', 'mousemove'])
                unbinds.push(unbindable(document, ev, onmove));
            for (const ev of ['touchend', 'mouseup'])
                unbinds.push(unbindable(document, ev, onend));
            const onScroll = () => s.dom.bounds.clear();
            unbinds.push(unbindable(document, 'scroll', onScroll, { capture: true, passive: true }));
            unbinds.push(unbindable(window, 'resize', onScroll, { passive: true }));
        }
        return () => unbinds.forEach(f => f());
    }
    exports.bindDocument = bindDocument;
    function unbindable(el, eventName, callback, options) {
        el.addEventListener(eventName, callback, options);
        return () => el.removeEventListener(eventName, callback, options);
    }
    function startDragOrDraw(s) {
        return e => {
            if (s.draggable.current)
                drag.cancel(s);
            else if (s.drawable.current)
                draw.cancel(s);
            else if (e.shiftKey || util_1.isRightButton(e)) {
                if (s.drawable.enabled)
                    draw.start(s, e);
            }
            else if (!s.viewOnly) {
                if (s.dropmode.active)
                    drop_1.drop(s, e);
                else
                    drag.start(s, e);
            }
        };
    }
    function dragOrDraw(s, withDrag, withDraw) {
        return e => {
            if (s.drawable.current) {
                if (s.drawable.enabled)
                    withDraw(s, e);
            }
            else if (!s.viewOnly)
                withDrag(s, e);
        };
    }

    },{"./drag":7,"./draw":8,"./drop":9,"./util":18}],11:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.explosion = void 0;
    function explosion(state, keys) {
        state.exploding = { stage: 1, keys };
        state.dom.redraw();
        setTimeout(() => {
            setStage(state, 2);
            setTimeout(() => setStage(state, undefined), 120);
        }, 120);
    }
    exports.explosion = explosion;
    function setStage(state, stage) {
        if (state.exploding) {
            if (stage)
                state.exploding.stage = stage;
            else
                state.exploding = undefined;
            state.dom.redraw();
        }
    }

    },{}],12:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.write = exports.read = exports.initial = void 0;
    const util_1 = require("./util");
    const cg = require("./types");
    exports.initial = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR';
    const roles = {
        p: 'pawn',
        r: 'rook',
        n: 'knight',
        b: 'bishop',
        q: 'queen',
        k: 'king',
    };
    const letters = {
        pawn: 'p',
        rook: 'r',
        knight: 'n',
        bishop: 'b',
        queen: 'q',
        king: 'k',
    };
    function read(fen) {
        if (fen === 'start')
            fen = exports.initial;
        const pieces = new Map();
        let row = 7, col = 0;
        for (const c of fen) {
            switch (c) {
                case ' ':
                    return pieces;
                case '/':
                    --row;
                    if (row < 0)
                        return pieces;
                    col = 0;
                    break;
                case '~':
                    const piece = pieces.get(util_1.pos2key([col, row]));
                    if (piece)
                        piece.promoted = true;
                    break;
                default:
                    const nb = c.charCodeAt(0);
                    if (nb < 57)
                        col += nb - 48;
                    else {
                        const role = c.toLowerCase();
                        pieces.set(util_1.pos2key([col, row]), {
                            role: roles[role],
                            color: c === role ? 'black' : 'white',
                        });
                        ++col;
                    }
            }
        }
        return pieces;
    }
    exports.read = read;
    function write(pieces) {
        return util_1.invRanks
            .map(y => cg.files
            .map(x => {
            const piece = pieces.get((x + y));
            if (piece) {
                const letter = letters[piece.role];
                return piece.color === 'white' ? letter.toUpperCase() : letter;
            }
            else
                return '1';
        })
            .join(''))
            .join('/')
            .replace(/1{2,}/g, s => s.length.toString());
    }
    exports.write = write;

    },{"./types":17,"./util":18}],13:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.premove = exports.queen = exports.knight = void 0;
    const util = require("./util");
    function diff(a, b) {
        return Math.abs(a - b);
    }
    function pawn(color) {
        return (x1, y1, x2, y2) => diff(x1, x2) < 2 &&
            (color === 'white'
                ?
                    y2 === y1 + 1 || (y1 <= 1 && y2 === y1 + 2 && x1 === x2)
                : y2 === y1 - 1 || (y1 >= 6 && y2 === y1 - 2 && x1 === x2));
    }
    const knight = (x1, y1, x2, y2) => {
        const xd = diff(x1, x2);
        const yd = diff(y1, y2);
        return (xd === 1 && yd === 2) || (xd === 2 && yd === 1);
    };
    exports.knight = knight;
    const bishop = (x1, y1, x2, y2) => {
        return diff(x1, x2) === diff(y1, y2);
    };
    const rook = (x1, y1, x2, y2) => {
        return x1 === x2 || y1 === y2;
    };
    const queen = (x1, y1, x2, y2) => {
        return bishop(x1, y1, x2, y2) || rook(x1, y1, x2, y2);
    };
    exports.queen = queen;
    function king(color, rookFiles, canCastle) {
        return (x1, y1, x2, y2) => (diff(x1, x2) < 2 && diff(y1, y2) < 2) ||
            (canCastle &&
                y1 === y2 &&
                y1 === (color === 'white' ? 0 : 7) &&
                ((x1 === 4 && ((x2 === 2 && rookFiles.includes(0)) || (x2 === 6 && rookFiles.includes(7)))) ||
                    rookFiles.includes(x2)));
    }
    function rookFilesOf(pieces, color) {
        const backrank = color === 'white' ? '1' : '8';
        const files = [];
        for (const [key, piece] of pieces) {
            if (key[1] === backrank && piece.color === color && piece.role === 'rook') {
                files.push(util.key2pos(key)[0]);
            }
        }
        return files;
    }
    function premove(pieces, key, canCastle) {
        const piece = pieces.get(key);
        if (!piece)
            return [];
        const pos = util.key2pos(key), r = piece.role, mobility = r === 'pawn'
            ? pawn(piece.color)
            : r === 'knight'
                ? exports.knight
                : r === 'bishop'
                    ? bishop
                    : r === 'rook'
                        ? rook
                        : r === 'queen'
                            ? exports.queen
                            : king(piece.color, rookFilesOf(pieces, piece.color), canCastle);
        return util.allPos
            .filter(pos2 => (pos[0] !== pos2[0] || pos[1] !== pos2[1]) && mobility(pos[0], pos[1], pos2[0], pos2[1]))
            .map(util.pos2key);
    }
    exports.premove = premove;

    },{"./util":18}],14:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.updateBounds = exports.render = void 0;
    const util_1 = require("./util");
    const board_1 = require("./board");
    const util = require("./util");
    function render(s) {
        const asWhite = board_1.whitePov(s), posToTranslate = s.dom.relative ? util.posToTranslateRel : util.posToTranslateAbs(s.dom.bounds()), translate = s.dom.relative ? util.translateRel : util.translateAbs, boardEl = s.dom.elements.board, pieces = s.pieces, curAnim = s.animation.current, anims = curAnim ? curAnim.plan.anims : new Map(), fadings = curAnim ? curAnim.plan.fadings : new Map(), curDrag = s.draggable.current, squares = computeSquareClasses(s), samePieces = new Set(), sameSquares = new Set(), movedPieces = new Map(), movedSquares = new Map();
        let k, el, pieceAtKey, elPieceName, anim, fading, pMvdset, pMvd, sMvdset, sMvd;
        el = boardEl.firstChild;
        while (el) {
            k = el.cgKey;
            if (isPieceNode(el)) {
                pieceAtKey = pieces.get(k);
                anim = anims.get(k);
                fading = fadings.get(k);
                elPieceName = el.cgPiece;
                if (el.cgDragging && (!curDrag || curDrag.orig !== k)) {
                    el.classList.remove('dragging');
                    translate(el, posToTranslate(util_1.key2pos(k), asWhite));
                    el.cgDragging = false;
                }
                if (!fading && el.cgFading) {
                    el.cgFading = false;
                    el.classList.remove('fading');
                }
                if (pieceAtKey) {
                    if (anim && el.cgAnimating && elPieceName === pieceNameOf(pieceAtKey)) {
                        const pos = util_1.key2pos(k);
                        pos[0] += anim[2];
                        pos[1] += anim[3];
                        el.classList.add('anim');
                        translate(el, posToTranslate(pos, asWhite));
                    }
                    else if (el.cgAnimating) {
                        el.cgAnimating = false;
                        el.classList.remove('anim');
                        translate(el, posToTranslate(util_1.key2pos(k), asWhite));
                        if (s.addPieceZIndex)
                            el.style.zIndex = posZIndex(util_1.key2pos(k), asWhite);
                    }
                    if (elPieceName === pieceNameOf(pieceAtKey) && (!fading || !el.cgFading)) {
                        samePieces.add(k);
                    }
                    else {
                        if (fading && elPieceName === pieceNameOf(fading)) {
                            el.classList.add('fading');
                            el.cgFading = true;
                        }
                        else {
                            appendValue(movedPieces, elPieceName, el);
                        }
                    }
                }
                else {
                    appendValue(movedPieces, elPieceName, el);
                }
            }
            else if (isSquareNode(el)) {
                const cn = el.className;
                if (squares.get(k) === cn)
                    sameSquares.add(k);
                else
                    appendValue(movedSquares, cn, el);
            }
            el = el.nextSibling;
        }
        for (const [sk, className] of squares) {
            if (!sameSquares.has(sk)) {
                sMvdset = movedSquares.get(className);
                sMvd = sMvdset && sMvdset.pop();
                const translation = posToTranslate(util_1.key2pos(sk), asWhite);
                if (sMvd) {
                    sMvd.cgKey = sk;
                    translate(sMvd, translation);
                }
                else {
                    const squareNode = util_1.createEl('square', className);
                    squareNode.cgKey = sk;
                    translate(squareNode, translation);
                    boardEl.insertBefore(squareNode, boardEl.firstChild);
                }
            }
        }
        for (const [k, p] of pieces) {
            anim = anims.get(k);
            if (!samePieces.has(k)) {
                pMvdset = movedPieces.get(pieceNameOf(p));
                pMvd = pMvdset && pMvdset.pop();
                if (pMvd) {
                    pMvd.cgKey = k;
                    if (pMvd.cgFading) {
                        pMvd.classList.remove('fading');
                        pMvd.cgFading = false;
                    }
                    const pos = util_1.key2pos(k);
                    if (s.addPieceZIndex)
                        pMvd.style.zIndex = posZIndex(pos, asWhite);
                    if (anim) {
                        pMvd.cgAnimating = true;
                        pMvd.classList.add('anim');
                        pos[0] += anim[2];
                        pos[1] += anim[3];
                    }
                    translate(pMvd, posToTranslate(pos, asWhite));
                }
                else {
                    const pieceName = pieceNameOf(p), pieceNode = util_1.createEl('piece', pieceName), pos = util_1.key2pos(k);
                    pieceNode.cgPiece = pieceName;
                    pieceNode.cgKey = k;
                    if (anim) {
                        pieceNode.cgAnimating = true;
                        pos[0] += anim[2];
                        pos[1] += anim[3];
                    }
                    translate(pieceNode, posToTranslate(pos, asWhite));
                    if (s.addPieceZIndex)
                        pieceNode.style.zIndex = posZIndex(pos, asWhite);
                    boardEl.appendChild(pieceNode);
                }
            }
        }
        for (const nodes of movedPieces.values())
            removeNodes(s, nodes);
        for (const nodes of movedSquares.values())
            removeNodes(s, nodes);
    }
    exports.render = render;
    function updateBounds(s) {
        if (s.dom.relative)
            return;
        const asWhite = board_1.whitePov(s), posToTranslate = util.posToTranslateAbs(s.dom.bounds());
        let el = s.dom.elements.board.firstChild;
        while (el) {
            if ((isPieceNode(el) && !el.cgAnimating) || isSquareNode(el)) {
                util.translateAbs(el, posToTranslate(util_1.key2pos(el.cgKey), asWhite));
            }
            el = el.nextSibling;
        }
    }
    exports.updateBounds = updateBounds;
    function isPieceNode(el) {
        return el.tagName === 'PIECE';
    }
    function isSquareNode(el) {
        return el.tagName === 'SQUARE';
    }
    function removeNodes(s, nodes) {
        for (const node of nodes)
            s.dom.elements.board.removeChild(node);
    }
    function posZIndex(pos, asWhite) {
        let z = 2 + pos[1] * 8 + (7 - pos[0]);
        if (asWhite)
            z = 67 - z;
        return z + '';
    }
    function pieceNameOf(piece) {
        return `${piece.color} ${piece.role}`;
    }
    function computeSquareClasses(s) {
        var _a;
        const squares = new Map();
        if (s.lastMove && s.highlight.lastMove)
            for (const k of s.lastMove) {
                addSquare(squares, k, 'last-move');
            }
        if (s.check && s.highlight.check)
            addSquare(squares, s.check, 'check');
        if (s.selected) {
            addSquare(squares, s.selected, 'selected');
            if (s.movable.showDests) {
                const dests = (_a = s.movable.dests) === null || _a === void 0 ? void 0 : _a.get(s.selected);
                if (dests)
                    for (const k of dests) {
                        addSquare(squares, k, 'move-dest' + (s.pieces.has(k) ? ' oc' : ''));
                    }
                const pDests = s.premovable.dests;
                if (pDests)
                    for (const k of pDests) {
                        addSquare(squares, k, 'premove-dest' + (s.pieces.has(k) ? ' oc' : ''));
                    }
            }
        }
        const premove = s.premovable.current;
        if (premove)
            for (const k of premove)
                addSquare(squares, k, 'current-premove');
        else if (s.predroppable.current)
            addSquare(squares, s.predroppable.current.key, 'current-premove');
        const o = s.exploding;
        if (o)
            for (const k of o.keys)
                addSquare(squares, k, 'exploding' + o.stage);
        return squares;
    }
    function addSquare(squares, key, klass) {
        const classes = squares.get(key);
        if (classes)
            squares.set(key, `${classes} ${klass}`);
        else
            squares.set(key, klass);
    }
    function appendValue(map, key, value) {
        const arr = map.get(key);
        if (arr)
            arr.push(value);
        else
            map.set(key, [value]);
    }

    },{"./board":4,"./util":18}],15:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaults = void 0;
    const fen = require("./fen");
    const util_1 = require("./util");
    function defaults() {
        return {
            pieces: fen.read(fen.initial),
            orientation: 'white',
            turnColor: 'white',
            coordinates: false,
            autoCastle: true,
            viewOnly: false,
            disableContextMenu: false,
            resizable: true,
            addPieceZIndex: false,
            pieceKey: false,
            highlight: {
                lastMove: true,
                check: true,
            },
            animation: {
                enabled: true,
                duration: 200,
            },
            movable: {
                free: true,
                color: 'both',
                showDests: true,
                events: {},
                rookCastle: true,
            },
            premovable: {
                enabled: true,
                showDests: true,
                castle: true,
                events: {},
            },
            predroppable: {
                enabled: false,
                events: {},
            },
            draggable: {
                enabled: true,
                distance: 3,
                autoDistance: true,
                showGhost: true,
                deleteOnDropOff: false,
            },
            dropmode: {
                active: false,
            },
            selectable: {
                enabled: true,
            },
            stats: {
                dragged: !('ontouchstart' in window),
            },
            events: {},
            drawable: {
                enabled: true,
                visible: true,
                defaultSnapToValidMove: true,
                eraseOnClick: true,
                shapes: [],
                autoShapes: [],
                brushes: {
                    green: { key: 'g', color: '#15781B', opacity: 1, lineWidth: 10 },
                    red: { key: 'r', color: '#882020', opacity: 1, lineWidth: 10 },
                    blue: { key: 'b', color: '#003088', opacity: 1, lineWidth: 10 },
                    yellow: { key: 'y', color: '#e68f00', opacity: 1, lineWidth: 10 },
                    paleBlue: { key: 'pb', color: '#003088', opacity: 0.4, lineWidth: 15 },
                    paleGreen: { key: 'pg', color: '#15781B', opacity: 0.4, lineWidth: 15 },
                    paleRed: { key: 'pr', color: '#882020', opacity: 0.4, lineWidth: 15 },
                    paleGrey: {
                        key: 'pgr',
                        color: '#4a4a4a',
                        opacity: 0.35,
                        lineWidth: 15,
                    },
                },
                pieces: {
                    baseUrl: 'https://lichess1.org/assets/piece/cburnett/',
                },
                prevSvgHash: '',
            },
            hold: util_1.timer(),
        };
    }
    exports.defaults = defaults;

    },{"./fen":12,"./util":18}],16:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setAttributes = exports.renderSvg = exports.createElement = void 0;
    const util_1 = require("./util");
    function createElement(tagName) {
        return document.createElementNS('http://www.w3.org/2000/svg', tagName);
    }
    exports.createElement = createElement;
    function renderSvg(state, svg, customSvg) {
        const d = state.drawable, curD = d.current, cur = curD && curD.mouseSq ? curD : undefined, arrowDests = new Map(), bounds = state.dom.bounds();
        for (const s of d.shapes.concat(d.autoShapes).concat(cur ? [cur] : [])) {
            if (s.dest)
                arrowDests.set(s.dest, (arrowDests.get(s.dest) || 0) + 1);
        }
        const shapes = d.shapes.concat(d.autoShapes).map((s) => {
            return {
                shape: s,
                current: false,
                hash: shapeHash(s, arrowDests, false, bounds),
            };
        });
        if (cur)
            shapes.push({
                shape: cur,
                current: true,
                hash: shapeHash(cur, arrowDests, true, bounds),
            });
        const fullHash = shapes.map(sc => sc.hash).join(';');
        if (fullHash === state.drawable.prevSvgHash)
            return;
        state.drawable.prevSvgHash = fullHash;
        const defsEl = svg.querySelector('defs');
        const shapesEl = svg.querySelector('g');
        const customSvgsEl = customSvg.querySelector('g');
        syncDefs(d, shapes, defsEl);
        syncShapes(state, shapes.filter(s => !s.shape.customSvg), d.brushes, arrowDests, shapesEl);
        syncShapes(state, shapes.filter(s => s.shape.customSvg), d.brushes, arrowDests, customSvgsEl);
    }
    exports.renderSvg = renderSvg;
    function syncDefs(d, shapes, defsEl) {
        const brushes = new Map();
        let brush;
        for (const s of shapes) {
            if (s.shape.dest) {
                brush = d.brushes[s.shape.brush];
                if (s.shape.modifiers)
                    brush = makeCustomBrush(brush, s.shape.modifiers);
                brushes.set(brush.key, brush);
            }
        }
        const keysInDom = new Set();
        let el = defsEl.firstChild;
        while (el) {
            keysInDom.add(el.getAttribute('cgKey'));
            el = el.nextSibling;
        }
        for (const [key, brush] of brushes.entries()) {
            if (!keysInDom.has(key))
                defsEl.appendChild(renderMarker(brush));
        }
    }
    function syncShapes(state, shapes, brushes, arrowDests, root) {
        const bounds = state.dom.bounds(), hashesInDom = new Map(), toRemove = [];
        for (const sc of shapes)
            hashesInDom.set(sc.hash, false);
        let el = root.firstChild, elHash;
        while (el) {
            elHash = el.getAttribute('cgHash');
            if (hashesInDom.has(elHash))
                hashesInDom.set(elHash, true);
            else
                toRemove.push(el);
            el = el.nextSibling;
        }
        for (const el of toRemove)
            root.removeChild(el);
        for (const sc of shapes) {
            if (!hashesInDom.get(sc.hash))
                root.appendChild(renderShape(state, sc, brushes, arrowDests, bounds));
        }
    }
    function shapeHash({ orig, dest, brush, piece, modifiers, customSvg }, arrowDests, current, bounds) {
        return [
            bounds.width,
            bounds.height,
            current,
            orig,
            dest,
            brush,
            dest && (arrowDests.get(dest) || 0) > 1,
            piece && pieceHash(piece),
            modifiers && modifiersHash(modifiers),
            customSvg && customSvgHash(customSvg),
        ]
            .filter(x => x)
            .join(',');
    }
    function pieceHash(piece) {
        return [piece.color, piece.role, piece.scale].filter(x => x).join(',');
    }
    function modifiersHash(m) {
        return '' + (m.lineWidth || '');
    }
    function customSvgHash(s) {
        let h = 0;
        for (let i = 0; i < s.length; i++) {
            h = (((h << 5) - h) + s.charCodeAt(i)) >>> 0;
        }
        return 'custom-' + h.toString();
    }
    function renderShape(state, { shape, current, hash }, brushes, arrowDests, bounds) {
        let el;
        if (shape.customSvg) {
            const orig = orient(util_1.key2pos(shape.orig), state.orientation);
            el = renderCustomSvg(shape.customSvg, orig, bounds);
        }
        else if (shape.piece)
            el = renderPiece(state.drawable.pieces.baseUrl, orient(util_1.key2pos(shape.orig), state.orientation), shape.piece, bounds);
        else {
            const orig = orient(util_1.key2pos(shape.orig), state.orientation);
            if (shape.dest) {
                let brush = brushes[shape.brush];
                if (shape.modifiers)
                    brush = makeCustomBrush(brush, shape.modifiers);
                el = renderArrow(brush, orig, orient(util_1.key2pos(shape.dest), state.orientation), current, (arrowDests.get(shape.dest) || 0) > 1, bounds);
            }
            else
                el = renderCircle(brushes[shape.brush], orig, current, bounds);
        }
        el.setAttribute('cgHash', hash);
        return el;
    }
    function renderCustomSvg(customSvg, pos, bounds) {
        const { width, height } = bounds;
        const w = width / 8;
        const h = height / 8;
        const x = pos[0] * w;
        const y = (7 - pos[1]) * h;
        const g = setAttributes(createElement('g'), { transform: `translate(${x},${y})` });
        const svg = setAttributes(createElement('svg'), { width: w, height: h, viewBox: '0 0 100 100' });
        g.appendChild(svg);
        svg.innerHTML = customSvg;
        return g;
    }
    function renderCircle(brush, pos, current, bounds) {
        const o = pos2px(pos, bounds), widths = circleWidth(bounds), radius = (bounds.width + bounds.height) / 32;
        return setAttributes(createElement('circle'), {
            stroke: brush.color,
            'stroke-width': widths[current ? 0 : 1],
            fill: 'none',
            opacity: opacity(brush, current),
            cx: o[0],
            cy: o[1],
            r: radius - widths[1] / 2,
        });
    }
    function renderArrow(brush, orig, dest, current, shorten, bounds) {
        const m = arrowMargin(bounds, shorten && !current), a = pos2px(orig, bounds), b = pos2px(dest, bounds), dx = b[0] - a[0], dy = b[1] - a[1], angle = Math.atan2(dy, dx), xo = Math.cos(angle) * m, yo = Math.sin(angle) * m;
        return setAttributes(createElement('line'), {
            stroke: brush.color,
            'stroke-width': lineWidth(brush, current, bounds),
            'stroke-linecap': 'round',
            'marker-end': 'url(#arrowhead-' + brush.key + ')',
            opacity: opacity(brush, current),
            x1: a[0],
            y1: a[1],
            x2: b[0] - xo,
            y2: b[1] - yo,
        });
    }
    function renderPiece(baseUrl, pos, piece, bounds) {
        const o = pos2px(pos, bounds), size = (bounds.width / 8) * (piece.scale || 1), name = piece.color[0] + (piece.role === 'knight' ? 'n' : piece.role[0]).toUpperCase();
        return setAttributes(createElement('image'), {
            className: `${piece.role} ${piece.color}`,
            x: o[0] - size / 2,
            y: o[1] - size / 2,
            width: size,
            height: size,
            href: baseUrl + name + '.svg',
        });
    }
    function renderMarker(brush) {
        const marker = setAttributes(createElement('marker'), {
            id: 'arrowhead-' + brush.key,
            orient: 'auto',
            markerWidth: 4,
            markerHeight: 8,
            refX: 2.05,
            refY: 2.01,
        });
        marker.appendChild(setAttributes(createElement('path'), {
            d: 'M0,0 V4 L3,2 Z',
            fill: brush.color,
        }));
        marker.setAttribute('cgKey', brush.key);
        return marker;
    }
    function setAttributes(el, attrs) {
        for (const key in attrs)
            el.setAttribute(key, attrs[key]);
        return el;
    }
    exports.setAttributes = setAttributes;
    function orient(pos, color) {
        return color === 'white' ? pos : [7 - pos[0], 7 - pos[1]];
    }
    function makeCustomBrush(base, modifiers) {
        return {
            color: base.color,
            opacity: Math.round(base.opacity * 10) / 10,
            lineWidth: Math.round(modifiers.lineWidth || base.lineWidth),
            key: [base.key, modifiers.lineWidth].filter(x => x).join(''),
        };
    }
    function circleWidth(bounds) {
        const base = bounds.width / 512;
        return [3 * base, 4 * base];
    }
    function lineWidth(brush, current, bounds) {
        return (((brush.lineWidth || 10) * (current ? 0.85 : 1)) / 512) * bounds.width;
    }
    function opacity(brush, current) {
        return (brush.opacity || 1) * (current ? 0.9 : 1);
    }
    function arrowMargin(bounds, shorten) {
        return ((shorten ? 20 : 10) / 512) * bounds.width;
    }
    function pos2px(pos, bounds) {
        return [((pos[0] + 0.5) * bounds.width) / 8, ((7.5 - pos[1]) * bounds.height) / 8];
    }

    },{"./util":18}],17:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ranks = exports.files = exports.colors = void 0;
    exports.colors = ['white', 'black'];
    exports.files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
    exports.ranks = ['1', '2', '3', '4', '5', '6', '7', '8'];

    },{}],18:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.computeSquareCenter = exports.createEl = exports.isRightButton = exports.eventPosition = exports.setVisible = exports.translateRel = exports.translateAbs = exports.posToTranslateRel = exports.posToTranslateAbs = exports.samePiece = exports.distanceSq = exports.opposite = exports.timer = exports.memo = exports.allPos = exports.key2pos = exports.pos2key = exports.allKeys = exports.invRanks = void 0;
    const cg = require("./types");
    exports.invRanks = [...cg.ranks].reverse();
    exports.allKeys = Array.prototype.concat(...cg.files.map(c => cg.ranks.map(r => c + r)));
    const pos2key = (pos) => exports.allKeys[8 * pos[0] + pos[1]];
    exports.pos2key = pos2key;
    const key2pos = (k) => [k.charCodeAt(0) - 97, k.charCodeAt(1) - 49];
    exports.key2pos = key2pos;
    exports.allPos = exports.allKeys.map(exports.key2pos);
    function memo(f) {
        let v;
        const ret = () => {
            if (v === undefined)
                v = f();
            return v;
        };
        ret.clear = () => {
            v = undefined;
        };
        return ret;
    }
    exports.memo = memo;
    const timer = () => {
        let startAt;
        return {
            start() {
                startAt = performance.now();
            },
            cancel() {
                startAt = undefined;
            },
            stop() {
                if (!startAt)
                    return 0;
                const time = performance.now() - startAt;
                startAt = undefined;
                return time;
            },
        };
    };
    exports.timer = timer;
    const opposite = (c) => (c === 'white' ? 'black' : 'white');
    exports.opposite = opposite;
    const distanceSq = (pos1, pos2) => {
        const dx = pos1[0] - pos2[0], dy = pos1[1] - pos2[1];
        return dx * dx + dy * dy;
    };
    exports.distanceSq = distanceSq;
    const samePiece = (p1, p2) => p1.role === p2.role && p1.color === p2.color;
    exports.samePiece = samePiece;
    const posToTranslateBase = (pos, asWhite, xFactor, yFactor) => [
        (asWhite ? pos[0] : 7 - pos[0]) * xFactor,
        (asWhite ? 7 - pos[1] : pos[1]) * yFactor,
    ];
    const posToTranslateAbs = (bounds) => {
        const xFactor = bounds.width / 8, yFactor = bounds.height / 8;
        return (pos, asWhite) => posToTranslateBase(pos, asWhite, xFactor, yFactor);
    };
    exports.posToTranslateAbs = posToTranslateAbs;
    const posToTranslateRel = (pos, asWhite) => posToTranslateBase(pos, asWhite, 100, 100);
    exports.posToTranslateRel = posToTranslateRel;
    const translateAbs = (el, pos) => {
        el.style.transform = `translate(${pos[0]}px,${pos[1]}px)`;
    };
    exports.translateAbs = translateAbs;
    const translateRel = (el, percents) => {
        el.style.transform = `translate(${percents[0]}%,${percents[1]}%)`;
    };
    exports.translateRel = translateRel;
    const setVisible = (el, v) => {
        el.style.visibility = v ? 'visible' : 'hidden';
    };
    exports.setVisible = setVisible;
    const eventPosition = (e) => {
        var _a;
        if (e.clientX || e.clientX === 0)
            return [e.clientX, e.clientY];
        if ((_a = e.targetTouches) === null || _a === void 0 ? void 0 : _a[0])
            return [e.targetTouches[0].clientX, e.targetTouches[0].clientY];
        return;
    };
    exports.eventPosition = eventPosition;
    const isRightButton = (e) => e.buttons === 2 || e.button === 2;
    exports.isRightButton = isRightButton;
    const createEl = (tagName, className) => {
        const el = document.createElement(tagName);
        if (className)
            el.className = className;
        return el;
    };
    exports.createEl = createEl;
    function computeSquareCenter(key, asWhite, bounds) {
        const pos = exports.key2pos(key);
        if (!asWhite) {
            pos[0] = 7 - pos[0];
            pos[1] = 7 - pos[1];
        }
        return [
            bounds.left + (bounds.width * pos[0]) / 8 + bounds.width / 16,
            bounds.top + (bounds.height * (7 - pos[1])) / 8 + bounds.height / 16,
        ];
    }
    exports.computeSquareCenter = computeSquareCenter;

    },{"./types":17}],19:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.renderWrap = void 0;
    const util_1 = require("./util");
    const types_1 = require("./types");
    const svg_1 = require("./svg");
    function renderWrap(element, s, relative) {
        element.innerHTML = '';
        element.classList.add('cg-wrap');
        for (const c of types_1.colors)
            element.classList.toggle('orientation-' + c, s.orientation === c);
        element.classList.toggle('manipulable', !s.viewOnly);
        const helper = util_1.createEl('cg-helper');
        element.appendChild(helper);
        const container = util_1.createEl('cg-container');
        helper.appendChild(container);
        const board = util_1.createEl('cg-board');
        container.appendChild(board);
        let svg;
        let customSvg;
        if (s.drawable.visible && !relative) {
            svg = svg_1.setAttributes(svg_1.createElement('svg'), { 'class': 'cg-shapes' });
            svg.appendChild(svg_1.createElement('defs'));
            svg.appendChild(svg_1.createElement('g'));
            customSvg = svg_1.setAttributes(svg_1.createElement('svg'), { 'class': 'cg-custom-svgs' });
            customSvg.appendChild(svg_1.createElement('g'));
            container.appendChild(svg);
            container.appendChild(customSvg);
        }
        if (s.coordinates) {
            const orientClass = s.orientation === 'black' ? ' black' : '';
            container.appendChild(renderCoords(types_1.ranks, 'ranks' + orientClass));
            container.appendChild(renderCoords(types_1.files, 'files' + orientClass));
        }
        let ghost;
        if (s.draggable.showGhost && !relative) {
            ghost = util_1.createEl('piece', 'ghost');
            util_1.setVisible(ghost, false);
            container.appendChild(ghost);
        }
        return {
            board,
            container,
            ghost,
            svg,
            customSvg,
        };
    }
    exports.renderWrap = renderWrap;
    function renderCoords(elems, className) {
        const el = util_1.createEl('coords', className);
        let f;
        for (const elem of elems) {
            f = util_1.createEl('coord');
            f.textContent = elem;
            el.appendChild(f);
        }
        return el;
    }

    },{"./svg":16,"./types":17,"./util":18}],20:[function(require,module,exports){
    (function (process){
    (function (global, factory) {
    	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    	typeof define === 'function' && define.amd ? define(factory) :
    	(global.page = factory());
    }(this, (function () { 'use strict';

    var isarray = Array.isArray || function (arr) {
      return Object.prototype.toString.call(arr) == '[object Array]';
    };

    /**
     * Expose `pathToRegexp`.
     */
    var pathToRegexp_1 = pathToRegexp;
    var parse_1 = parse;
    var compile_1 = compile;
    var tokensToFunction_1 = tokensToFunction;
    var tokensToRegExp_1 = tokensToRegExp;

    /**
     * The main path matching regexp utility.
     *
     * @type {RegExp}
     */
    var PATH_REGEXP = new RegExp([
      // Match escaped characters that would otherwise appear in future matches.
      // This allows the user to escape special characters that won't transform.
      '(\\\\.)',
      // Match Express-style parameters and un-named parameters with a prefix
      // and optional suffixes. Matches appear as:
      //
      // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
      // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
      // "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
      '([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^()])+)\\))?|\\(((?:\\\\.|[^()])+)\\))([+*?])?|(\\*))'
    ].join('|'), 'g');

    /**
     * Parse a string for the raw tokens.
     *
     * @param  {String} str
     * @return {Array}
     */
    function parse (str) {
      var tokens = [];
      var key = 0;
      var index = 0;
      var path = '';
      var res;

      while ((res = PATH_REGEXP.exec(str)) != null) {
        var m = res[0];
        var escaped = res[1];
        var offset = res.index;
        path += str.slice(index, offset);
        index = offset + m.length;

        // Ignore already escaped sequences.
        if (escaped) {
          path += escaped[1];
          continue
        }

        // Push the current path onto the tokens.
        if (path) {
          tokens.push(path);
          path = '';
        }

        var prefix = res[2];
        var name = res[3];
        var capture = res[4];
        var group = res[5];
        var suffix = res[6];
        var asterisk = res[7];

        var repeat = suffix === '+' || suffix === '*';
        var optional = suffix === '?' || suffix === '*';
        var delimiter = prefix || '/';
        var pattern = capture || group || (asterisk ? '.*' : '[^' + delimiter + ']+?');

        tokens.push({
          name: name || key++,
          prefix: prefix || '',
          delimiter: delimiter,
          optional: optional,
          repeat: repeat,
          pattern: escapeGroup(pattern)
        });
      }

      // Match any characters still remaining.
      if (index < str.length) {
        path += str.substr(index);
      }

      // If the path exists, push it onto the end.
      if (path) {
        tokens.push(path);
      }

      return tokens
    }

    /**
     * Compile a string to a template function for the path.
     *
     * @param  {String}   str
     * @return {Function}
     */
    function compile (str) {
      return tokensToFunction(parse(str))
    }

    /**
     * Expose a method for transforming tokens into the path function.
     */
    function tokensToFunction (tokens) {
      // Compile all the tokens into regexps.
      var matches = new Array(tokens.length);

      // Compile all the patterns before compilation.
      for (var i = 0; i < tokens.length; i++) {
        if (typeof tokens[i] === 'object') {
          matches[i] = new RegExp('^' + tokens[i].pattern + '$');
        }
      }

      return function (obj) {
        var path = '';
        var data = obj || {};

        for (var i = 0; i < tokens.length; i++) {
          var token = tokens[i];

          if (typeof token === 'string') {
            path += token;

            continue
          }

          var value = data[token.name];
          var segment;

          if (value == null) {
            if (token.optional) {
              continue
            } else {
              throw new TypeError('Expected "' + token.name + '" to be defined')
            }
          }

          if (isarray(value)) {
            if (!token.repeat) {
              throw new TypeError('Expected "' + token.name + '" to not repeat, but received "' + value + '"')
            }

            if (value.length === 0) {
              if (token.optional) {
                continue
              } else {
                throw new TypeError('Expected "' + token.name + '" to not be empty')
              }
            }

            for (var j = 0; j < value.length; j++) {
              segment = encodeURIComponent(value[j]);

              if (!matches[i].test(segment)) {
                throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"')
              }

              path += (j === 0 ? token.prefix : token.delimiter) + segment;
            }

            continue
          }

          segment = encodeURIComponent(value);

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"')
          }

          path += token.prefix + segment;
        }

        return path
      }
    }

    /**
     * Escape a regular expression string.
     *
     * @param  {String} str
     * @return {String}
     */
    function escapeString (str) {
      return str.replace(/([.+*?=^!:${}()[\]|\/])/g, '\\$1')
    }

    /**
     * Escape the capturing group by escaping special characters and meaning.
     *
     * @param  {String} group
     * @return {String}
     */
    function escapeGroup (group) {
      return group.replace(/([=!:$\/()])/g, '\\$1')
    }

    /**
     * Attach the keys as a property of the regexp.
     *
     * @param  {RegExp} re
     * @param  {Array}  keys
     * @return {RegExp}
     */
    function attachKeys (re, keys) {
      re.keys = keys;
      return re
    }

    /**
     * Get the flags for a regexp from the options.
     *
     * @param  {Object} options
     * @return {String}
     */
    function flags (options) {
      return options.sensitive ? '' : 'i'
    }

    /**
     * Pull out keys from a regexp.
     *
     * @param  {RegExp} path
     * @param  {Array}  keys
     * @return {RegExp}
     */
    function regexpToRegexp (path, keys) {
      // Use a negative lookahead to match only capturing groups.
      var groups = path.source.match(/\((?!\?)/g);

      if (groups) {
        for (var i = 0; i < groups.length; i++) {
          keys.push({
            name: i,
            prefix: null,
            delimiter: null,
            optional: false,
            repeat: false,
            pattern: null
          });
        }
      }

      return attachKeys(path, keys)
    }

    /**
     * Transform an array into a regexp.
     *
     * @param  {Array}  path
     * @param  {Array}  keys
     * @param  {Object} options
     * @return {RegExp}
     */
    function arrayToRegexp (path, keys, options) {
      var parts = [];

      for (var i = 0; i < path.length; i++) {
        parts.push(pathToRegexp(path[i], keys, options).source);
      }

      var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));

      return attachKeys(regexp, keys)
    }

    /**
     * Create a path regexp from string input.
     *
     * @param  {String} path
     * @param  {Array}  keys
     * @param  {Object} options
     * @return {RegExp}
     */
    function stringToRegexp (path, keys, options) {
      var tokens = parse(path);
      var re = tokensToRegExp(tokens, options);

      // Attach keys back to the regexp.
      for (var i = 0; i < tokens.length; i++) {
        if (typeof tokens[i] !== 'string') {
          keys.push(tokens[i]);
        }
      }

      return attachKeys(re, keys)
    }

    /**
     * Expose a function for taking tokens and returning a RegExp.
     *
     * @param  {Array}  tokens
     * @param  {Array}  keys
     * @param  {Object} options
     * @return {RegExp}
     */
    function tokensToRegExp (tokens, options) {
      options = options || {};

      var strict = options.strict;
      var end = options.end !== false;
      var route = '';
      var lastToken = tokens[tokens.length - 1];
      var endsWithSlash = typeof lastToken === 'string' && /\/$/.test(lastToken);

      // Iterate over the tokens and create our regexp string.
      for (var i = 0; i < tokens.length; i++) {
        var token = tokens[i];

        if (typeof token === 'string') {
          route += escapeString(token);
        } else {
          var prefix = escapeString(token.prefix);
          var capture = token.pattern;

          if (token.repeat) {
            capture += '(?:' + prefix + capture + ')*';
          }

          if (token.optional) {
            if (prefix) {
              capture = '(?:' + prefix + '(' + capture + '))?';
            } else {
              capture = '(' + capture + ')?';
            }
          } else {
            capture = prefix + '(' + capture + ')';
          }

          route += capture;
        }
      }

      // In non-strict mode we allow a slash at the end of match. If the path to
      // match already ends with a slash, we remove it for consistency. The slash
      // is valid at the end of a path match, not in the middle. This is important
      // in non-ending mode, where "/test/" shouldn't match "/test//route".
      if (!strict) {
        route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\/(?=$))?';
      }

      if (end) {
        route += '$';
      } else {
        // In non-ending mode, we need the capturing groups to match as much as
        // possible by using a positive lookahead to the end or next path segment.
        route += strict && endsWithSlash ? '' : '(?=\\/|$)';
      }

      return new RegExp('^' + route, flags(options))
    }

    /**
     * Normalize the given path string, returning a regular expression.
     *
     * An empty array can be passed in for the keys, which will hold the
     * placeholder key descriptions. For example, using `/user/:id`, `keys` will
     * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
     *
     * @param  {(String|RegExp|Array)} path
     * @param  {Array}                 [keys]
     * @param  {Object}                [options]
     * @return {RegExp}
     */
    function pathToRegexp (path, keys, options) {
      keys = keys || [];

      if (!isarray(keys)) {
        options = keys;
        keys = [];
      } else if (!options) {
        options = {};
      }

      if (path instanceof RegExp) {
        return regexpToRegexp(path, keys, options)
      }

      if (isarray(path)) {
        return arrayToRegexp(path, keys, options)
      }

      return stringToRegexp(path, keys, options)
    }

    pathToRegexp_1.parse = parse_1;
    pathToRegexp_1.compile = compile_1;
    pathToRegexp_1.tokensToFunction = tokensToFunction_1;
    pathToRegexp_1.tokensToRegExp = tokensToRegExp_1;

    /**
       * Module dependencies.
       */



      /**
       * Short-cuts for global-object checks
       */

      var hasDocument = ('undefined' !== typeof document);
      var hasWindow = ('undefined' !== typeof window);
      var hasHistory = ('undefined' !== typeof history);
      var hasProcess = typeof process !== 'undefined';

      /**
       * Detect click event
       */
      var clickEvent = hasDocument && document.ontouchstart ? 'touchstart' : 'click';

      /**
       * To work properly with the URL
       * history.location generated polyfill in https://github.com/devote/HTML5-History-API
       */

      var isLocation = hasWindow && !!(window.history.location || window.location);

      /**
       * The page instance
       * @api private
       */
      function Page() {
        // public things
        this.callbacks = [];
        this.exits = [];
        this.current = '';
        this.len = 0;

        // private things
        this._decodeURLComponents = true;
        this._base = '';
        this._strict = false;
        this._running = false;
        this._hashbang = false;

        // bound functions
        this.clickHandler = this.clickHandler.bind(this);
        this._onpopstate = this._onpopstate.bind(this);
      }

      /**
       * Configure the instance of page. This can be called multiple times.
       *
       * @param {Object} options
       * @api public
       */

      Page.prototype.configure = function(options) {
        var opts = options || {};

        this._window = opts.window || (hasWindow && window);
        this._decodeURLComponents = opts.decodeURLComponents !== false;
        this._popstate = opts.popstate !== false && hasWindow;
        this._click = opts.click !== false && hasDocument;
        this._hashbang = !!opts.hashbang;

        var _window = this._window;
        if(this._popstate) {
          _window.addEventListener('popstate', this._onpopstate, false);
        } else if(hasWindow) {
          _window.removeEventListener('popstate', this._onpopstate, false);
        }

        if (this._click) {
          _window.document.addEventListener(clickEvent, this.clickHandler, false);
        } else if(hasDocument) {
          _window.document.removeEventListener(clickEvent, this.clickHandler, false);
        }

        if(this._hashbang && hasWindow && !hasHistory) {
          _window.addEventListener('hashchange', this._onpopstate, false);
        } else if(hasWindow) {
          _window.removeEventListener('hashchange', this._onpopstate, false);
        }
      };

      /**
       * Get or set basepath to `path`.
       *
       * @param {string} path
       * @api public
       */

      Page.prototype.base = function(path) {
        if (0 === arguments.length) return this._base;
        this._base = path;
      };

      /**
       * Gets the `base`, which depends on whether we are using History or
       * hashbang routing.

       * @api private
       */
      Page.prototype._getBase = function() {
        var base = this._base;
        if(!!base) return base;
        var loc = hasWindow && this._window && this._window.location;

        if(hasWindow && this._hashbang && loc && loc.protocol === 'file:') {
          base = loc.pathname;
        }

        return base;
      };

      /**
       * Get or set strict path matching to `enable`
       *
       * @param {boolean} enable
       * @api public
       */

      Page.prototype.strict = function(enable) {
        if (0 === arguments.length) return this._strict;
        this._strict = enable;
      };


      /**
       * Bind with the given `options`.
       *
       * Options:
       *
       *    - `click` bind to click events [true]
       *    - `popstate` bind to popstate [true]
       *    - `dispatch` perform initial dispatch [true]
       *
       * @param {Object} options
       * @api public
       */

      Page.prototype.start = function(options) {
        var opts = options || {};
        this.configure(opts);

        if (false === opts.dispatch) return;
        this._running = true;

        var url;
        if(isLocation) {
          var window = this._window;
          var loc = window.location;

          if(this._hashbang && ~loc.hash.indexOf('#!')) {
            url = loc.hash.substr(2) + loc.search;
          } else if (this._hashbang) {
            url = loc.search + loc.hash;
          } else {
            url = loc.pathname + loc.search + loc.hash;
          }
        }

        this.replace(url, null, true, opts.dispatch);
      };

      /**
       * Unbind click and popstate event handlers.
       *
       * @api public
       */

      Page.prototype.stop = function() {
        if (!this._running) return;
        this.current = '';
        this.len = 0;
        this._running = false;

        var window = this._window;
        this._click && window.document.removeEventListener(clickEvent, this.clickHandler, false);
        hasWindow && window.removeEventListener('popstate', this._onpopstate, false);
        hasWindow && window.removeEventListener('hashchange', this._onpopstate, false);
      };

      /**
       * Show `path` with optional `state` object.
       *
       * @param {string} path
       * @param {Object=} state
       * @param {boolean=} dispatch
       * @param {boolean=} push
       * @return {!Context}
       * @api public
       */

      Page.prototype.show = function(path, state, dispatch, push) {
        var ctx = new Context(path, state, this),
          prev = this.prevContext;
        this.prevContext = ctx;
        this.current = ctx.path;
        if (false !== dispatch) this.dispatch(ctx, prev);
        if (false !== ctx.handled && false !== push) ctx.pushState();
        return ctx;
      };

      /**
       * Goes back in the history
       * Back should always let the current route push state and then go back.
       *
       * @param {string} path - fallback path to go back if no more history exists, if undefined defaults to page.base
       * @param {Object=} state
       * @api public
       */

      Page.prototype.back = function(path, state) {
        var page = this;
        if (this.len > 0) {
          var window = this._window;
          // this may need more testing to see if all browsers
          // wait for the next tick to go back in history
          hasHistory && window.history.back();
          this.len--;
        } else if (path) {
          setTimeout(function() {
            page.show(path, state);
          });
        } else {
          setTimeout(function() {
            page.show(page._getBase(), state);
          });
        }
      };

      /**
       * Register route to redirect from one path to other
       * or just redirect to another route
       *
       * @param {string} from - if param 'to' is undefined redirects to 'from'
       * @param {string=} to
       * @api public
       */
      Page.prototype.redirect = function(from, to) {
        var inst = this;

        // Define route from a path to another
        if ('string' === typeof from && 'string' === typeof to) {
          page.call(this, from, function(e) {
            setTimeout(function() {
              inst.replace(/** @type {!string} */ (to));
            }, 0);
          });
        }

        // Wait for the push state and replace it with another
        if ('string' === typeof from && 'undefined' === typeof to) {
          setTimeout(function() {
            inst.replace(from);
          }, 0);
        }
      };

      /**
       * Replace `path` with optional `state` object.
       *
       * @param {string} path
       * @param {Object=} state
       * @param {boolean=} init
       * @param {boolean=} dispatch
       * @return {!Context}
       * @api public
       */


      Page.prototype.replace = function(path, state, init, dispatch) {
        var ctx = new Context(path, state, this),
          prev = this.prevContext;
        this.prevContext = ctx;
        this.current = ctx.path;
        ctx.init = init;
        ctx.save(); // save before dispatching, which may redirect
        if (false !== dispatch) this.dispatch(ctx, prev);
        return ctx;
      };

      /**
       * Dispatch the given `ctx`.
       *
       * @param {Context} ctx
       * @api private
       */

      Page.prototype.dispatch = function(ctx, prev) {
        var i = 0, j = 0, page = this;

        function nextExit() {
          var fn = page.exits[j++];
          if (!fn) return nextEnter();
          fn(prev, nextExit);
        }

        function nextEnter() {
          var fn = page.callbacks[i++];

          if (ctx.path !== page.current) {
            ctx.handled = false;
            return;
          }
          if (!fn) return unhandled.call(page, ctx);
          fn(ctx, nextEnter);
        }

        if (prev) {
          nextExit();
        } else {
          nextEnter();
        }
      };

      /**
       * Register an exit route on `path` with
       * callback `fn()`, which will be called
       * on the previous context when a new
       * page is visited.
       */
      Page.prototype.exit = function(path, fn) {
        if (typeof path === 'function') {
          return this.exit('*', path);
        }

        var route = new Route(path, null, this);
        for (var i = 1; i < arguments.length; ++i) {
          this.exits.push(route.middleware(arguments[i]));
        }
      };

      /**
       * Handle "click" events.
       */

      /* jshint +W054 */
      Page.prototype.clickHandler = function(e) {
        if (1 !== this._which(e)) return;

        if (e.metaKey || e.ctrlKey || e.shiftKey) return;
        if (e.defaultPrevented) return;

        // ensure link
        // use shadow dom when available if not, fall back to composedPath()
        // for browsers that only have shady
        var el = e.target;
        var eventPath = e.path || (e.composedPath ? e.composedPath() : null);

        if(eventPath) {
          for (var i = 0; i < eventPath.length; i++) {
            if (!eventPath[i].nodeName) continue;
            if (eventPath[i].nodeName.toUpperCase() !== 'A') continue;
            if (!eventPath[i].href) continue;

            el = eventPath[i];
            break;
          }
        }

        // continue ensure link
        // el.nodeName for svg links are 'a' instead of 'A'
        while (el && 'A' !== el.nodeName.toUpperCase()) el = el.parentNode;
        if (!el || 'A' !== el.nodeName.toUpperCase()) return;

        // check if link is inside an svg
        // in this case, both href and target are always inside an object
        var svg = (typeof el.href === 'object') && el.href.constructor.name === 'SVGAnimatedString';

        // Ignore if tag has
        // 1. "download" attribute
        // 2. rel="external" attribute
        if (el.hasAttribute('download') || el.getAttribute('rel') === 'external') return;

        // ensure non-hash for the same path
        var link = el.getAttribute('href');
        if(!this._hashbang && this._samePath(el) && (el.hash || '#' === link)) return;

        // Check for mailto: in the href
        if (link && link.indexOf('mailto:') > -1) return;

        // check target
        // svg target is an object and its desired value is in .baseVal property
        if (svg ? el.target.baseVal : el.target) return;

        // x-origin
        // note: svg links that are not relative don't call click events (and skip page.js)
        // consequently, all svg links tested inside page.js are relative and in the same origin
        if (!svg && !this.sameOrigin(el.href)) return;

        // rebuild path
        // There aren't .pathname and .search properties in svg links, so we use href
        // Also, svg href is an object and its desired value is in .baseVal property
        var path = svg ? el.href.baseVal : (el.pathname + el.search + (el.hash || ''));

        path = path[0] !== '/' ? '/' + path : path;

        // strip leading "/[drive letter]:" on NW.js on Windows
        if (hasProcess && path.match(/^\/[a-zA-Z]:\//)) {
          path = path.replace(/^\/[a-zA-Z]:\//, '/');
        }

        // same page
        var orig = path;
        var pageBase = this._getBase();

        if (path.indexOf(pageBase) === 0) {
          path = path.substr(pageBase.length);
        }

        if (this._hashbang) path = path.replace('#!', '');

        if (pageBase && orig === path && (!isLocation || this._window.location.protocol !== 'file:')) {
          return;
        }

        e.preventDefault();
        this.show(orig);
      };

      /**
       * Handle "populate" events.
       * @api private
       */

      Page.prototype._onpopstate = (function () {
        var loaded = false;
        if ( ! hasWindow ) {
          return function () {};
        }
        if (hasDocument && document.readyState === 'complete') {
          loaded = true;
        } else {
          window.addEventListener('load', function() {
            setTimeout(function() {
              loaded = true;
            }, 0);
          });
        }
        return function onpopstate(e) {
          if (!loaded) return;
          var page = this;
          if (e.state) {
            var path = e.state.path;
            page.replace(path, e.state);
          } else if (isLocation) {
            var loc = page._window.location;
            page.show(loc.pathname + loc.search + loc.hash, undefined, undefined, false);
          }
        };
      })();

      /**
       * Event button.
       */
      Page.prototype._which = function(e) {
        e = e || (hasWindow && this._window.event);
        return null == e.which ? e.button : e.which;
      };

      /**
       * Convert to a URL object
       * @api private
       */
      Page.prototype._toURL = function(href) {
        var window = this._window;
        if(typeof URL === 'function' && isLocation) {
          return new URL(href, window.location.toString());
        } else if (hasDocument) {
          var anc = window.document.createElement('a');
          anc.href = href;
          return anc;
        }
      };

      /**
       * Check if `href` is the same origin.
       * @param {string} href
       * @api public
       */

      Page.prototype.sameOrigin = function(href) {
        if(!href || !isLocation) return false;

        var url = this._toURL(href);
        var window = this._window;

        var loc = window.location;
        return loc.protocol === url.protocol &&
          loc.hostname === url.hostname &&
          loc.port === url.port;
      };

      /**
       * @api private
       */
      Page.prototype._samePath = function(url) {
        if(!isLocation) return false;
        var window = this._window;
        var loc = window.location;
        return url.pathname === loc.pathname &&
          url.search === loc.search;
      };

      /**
       * Remove URL encoding from the given `str`.
       * Accommodates whitespace in both x-www-form-urlencoded
       * and regular percent-encoded form.
       *
       * @param {string} val - URL component to decode
       * @api private
       */
      Page.prototype._decodeURLEncodedURIComponent = function(val) {
        if (typeof val !== 'string') { return val; }
        return this._decodeURLComponents ? decodeURIComponent(val.replace(/\+/g, ' ')) : val;
      };

      /**
       * Create a new `page` instance and function
       */
      function createPage() {
        var pageInstance = new Page();

        function pageFn(/* args */) {
          return page.apply(pageInstance, arguments);
        }

        // Copy all of the things over. In 2.0 maybe we use setPrototypeOf
        pageFn.callbacks = pageInstance.callbacks;
        pageFn.exits = pageInstance.exits;
        pageFn.base = pageInstance.base.bind(pageInstance);
        pageFn.strict = pageInstance.strict.bind(pageInstance);
        pageFn.start = pageInstance.start.bind(pageInstance);
        pageFn.stop = pageInstance.stop.bind(pageInstance);
        pageFn.show = pageInstance.show.bind(pageInstance);
        pageFn.back = pageInstance.back.bind(pageInstance);
        pageFn.redirect = pageInstance.redirect.bind(pageInstance);
        pageFn.replace = pageInstance.replace.bind(pageInstance);
        pageFn.dispatch = pageInstance.dispatch.bind(pageInstance);
        pageFn.exit = pageInstance.exit.bind(pageInstance);
        pageFn.configure = pageInstance.configure.bind(pageInstance);
        pageFn.sameOrigin = pageInstance.sameOrigin.bind(pageInstance);
        pageFn.clickHandler = pageInstance.clickHandler.bind(pageInstance);

        pageFn.create = createPage;

        Object.defineProperty(pageFn, 'len', {
          get: function(){
            return pageInstance.len;
          },
          set: function(val) {
            pageInstance.len = val;
          }
        });

        Object.defineProperty(pageFn, 'current', {
          get: function(){
            return pageInstance.current;
          },
          set: function(val) {
            pageInstance.current = val;
          }
        });

        // In 2.0 these can be named exports
        pageFn.Context = Context;
        pageFn.Route = Route;

        return pageFn;
      }

      /**
       * Register `path` with callback `fn()`,
       * or route `path`, or redirection,
       * or `page.start()`.
       *
       *   page(fn);
       *   page('*', fn);
       *   page('/user/:id', load, user);
       *   page('/user/' + user.id, { some: 'thing' });
       *   page('/user/' + user.id);
       *   page('/from', '/to')
       *   page();
       *
       * @param {string|!Function|!Object} path
       * @param {Function=} fn
       * @api public
       */

      function page(path, fn) {
        // <callback>
        if ('function' === typeof path) {
          return page.call(this, '*', path);
        }

        // route <path> to <callback ...>
        if ('function' === typeof fn) {
          var route = new Route(/** @type {string} */ (path), null, this);
          for (var i = 1; i < arguments.length; ++i) {
            this.callbacks.push(route.middleware(arguments[i]));
          }
          // show <path> with [state]
        } else if ('string' === typeof path) {
          this['string' === typeof fn ? 'redirect' : 'show'](path, fn);
          // start [options]
        } else {
          this.start(path);
        }
      }

      /**
       * Unhandled `ctx`. When it's not the initial
       * popstate then redirect. If you wish to handle
       * 404s on your own use `page('*', callback)`.
       *
       * @param {Context} ctx
       * @api private
       */
      function unhandled(ctx) {
        if (ctx.handled) return;
        var current;
        var page = this;
        var window = page._window;

        if (page._hashbang) {
          current = isLocation && this._getBase() + window.location.hash.replace('#!', '');
        } else {
          current = isLocation && window.location.pathname + window.location.search;
        }

        if (current === ctx.canonicalPath) return;
        page.stop();
        ctx.handled = false;
        isLocation && (window.location.href = ctx.canonicalPath);
      }

      /**
       * Escapes RegExp characters in the given string.
       *
       * @param {string} s
       * @api private
       */
      function escapeRegExp(s) {
        return s.replace(/([.+*?=^!:${}()[\]|/\\])/g, '\\$1');
      }

      /**
       * Initialize a new "request" `Context`
       * with the given `path` and optional initial `state`.
       *
       * @constructor
       * @param {string} path
       * @param {Object=} state
       * @api public
       */

      function Context(path, state, pageInstance) {
        var _page = this.page = pageInstance || page;
        var window = _page._window;
        var hashbang = _page._hashbang;

        var pageBase = _page._getBase();
        if ('/' === path[0] && 0 !== path.indexOf(pageBase)) path = pageBase + (hashbang ? '#!' : '') + path;
        var i = path.indexOf('?');

        this.canonicalPath = path;
        var re = new RegExp('^' + escapeRegExp(pageBase));
        this.path = path.replace(re, '') || '/';
        if (hashbang) this.path = this.path.replace('#!', '') || '/';

        this.title = (hasDocument && window.document.title);
        this.state = state || {};
        this.state.path = path;
        this.querystring = ~i ? _page._decodeURLEncodedURIComponent(path.slice(i + 1)) : '';
        this.pathname = _page._decodeURLEncodedURIComponent(~i ? path.slice(0, i) : path);
        this.params = {};

        // fragment
        this.hash = '';
        if (!hashbang) {
          if (!~this.path.indexOf('#')) return;
          var parts = this.path.split('#');
          this.path = this.pathname = parts[0];
          this.hash = _page._decodeURLEncodedURIComponent(parts[1]) || '';
          this.querystring = this.querystring.split('#')[0];
        }
      }

      /**
       * Push state.
       *
       * @api private
       */

      Context.prototype.pushState = function() {
        var page = this.page;
        var window = page._window;
        var hashbang = page._hashbang;

        page.len++;
        if (hasHistory) {
            window.history.pushState(this.state, this.title,
              hashbang && this.path !== '/' ? '#!' + this.path : this.canonicalPath);
        }
      };

      /**
       * Save the context state.
       *
       * @api public
       */

      Context.prototype.save = function() {
        var page = this.page;
        if (hasHistory) {
            page._window.history.replaceState(this.state, this.title,
              page._hashbang && this.path !== '/' ? '#!' + this.path : this.canonicalPath);
        }
      };

      /**
       * Initialize `Route` with the given HTTP `path`,
       * and an array of `callbacks` and `options`.
       *
       * Options:
       *
       *   - `sensitive`    enable case-sensitive routes
       *   - `strict`       enable strict matching for trailing slashes
       *
       * @constructor
       * @param {string} path
       * @param {Object=} options
       * @api private
       */

      function Route(path, options, page) {
        var _page = this.page = page || globalPage;
        var opts = options || {};
        opts.strict = opts.strict || page._strict;
        this.path = (path === '*') ? '(.*)' : path;
        this.method = 'GET';
        this.regexp = pathToRegexp_1(this.path, this.keys = [], opts);
      }

      /**
       * Return route middleware with
       * the given callback `fn()`.
       *
       * @param {Function} fn
       * @return {Function}
       * @api public
       */

      Route.prototype.middleware = function(fn) {
        var self = this;
        return function(ctx, next) {
          if (self.match(ctx.path, ctx.params)) return fn(ctx, next);
          next();
        };
      };

      /**
       * Check if this route matches `path`, if so
       * populate `params`.
       *
       * @param {string} path
       * @param {Object} params
       * @return {boolean}
       * @api private
       */

      Route.prototype.match = function(path, params) {
        var keys = this.keys,
          qsIndex = path.indexOf('?'),
          pathname = ~qsIndex ? path.slice(0, qsIndex) : path,
          m = this.regexp.exec(decodeURIComponent(pathname));

        if (!m) return false;

        for (var i = 1, len = m.length; i < len; ++i) {
          var key = keys[i - 1];
          var val = this.page._decodeURLEncodedURIComponent(m[i]);
          if (val !== undefined || !(hasOwnProperty.call(params, key.name))) {
            params[key.name] = val;
          }
        }

        return true;
      };


      /**
       * Module exports.
       */

      var globalPage = createPage();
      var page_js = globalPage;
      var default_1 = globalPage;

    page_js.default = default_1;

    return page_js;

    })));

    }).call(this,require('_process'))

    },{"_process":21}],21:[function(require,module,exports){
    // shim for using process in browser
    var process = module.exports = {};

    // cached from whatever global is present so that test runners that stub it
    // don't break things.  But we need to wrap it in a try catch in case it is
    // wrapped in strict mode code which doesn't define any globals.  It's inside a
    // function because try/catches deoptimize in certain engines.

    var cachedSetTimeout;
    var cachedClearTimeout;

    function defaultSetTimout() {
        throw new Error('setTimeout has not been defined');
    }
    function defaultClearTimeout () {
        throw new Error('clearTimeout has not been defined');
    }
    (function () {
        try {
            if (typeof setTimeout === 'function') {
                cachedSetTimeout = setTimeout;
            } else {
                cachedSetTimeout = defaultSetTimout;
            }
        } catch (e) {
            cachedSetTimeout = defaultSetTimout;
        }
        try {
            if (typeof clearTimeout === 'function') {
                cachedClearTimeout = clearTimeout;
            } else {
                cachedClearTimeout = defaultClearTimeout;
            }
        } catch (e) {
            cachedClearTimeout = defaultClearTimeout;
        }
    } ())
    function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
            //normal enviroments in sane situations
            return setTimeout(fun, 0);
        }
        // if setTimeout wasn't available but was latter defined
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedSetTimeout(fun, 0);
        } catch(e){
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                return cachedSetTimeout.call(null, fun, 0);
            } catch(e){
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                return cachedSetTimeout.call(this, fun, 0);
            }
        }


    }
    function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
            //normal enviroments in sane situations
            return clearTimeout(marker);
        }
        // if clearTimeout wasn't available but was latter defined
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedClearTimeout(marker);
        } catch (e){
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                return cachedClearTimeout.call(null, marker);
            } catch (e){
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                return cachedClearTimeout.call(this, marker);
            }
        }



    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;

    function cleanUpNextTick() {
        if (!draining || !currentQueue) {
            return;
        }
        draining = false;
        if (currentQueue.length) {
            queue = currentQueue.concat(queue);
        } else {
            queueIndex = -1;
        }
        if (queue.length) {
            drainQueue();
        }
    }

    function drainQueue() {
        if (draining) {
            return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;

        var len = queue.length;
        while(len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
                if (currentQueue) {
                    currentQueue[queueIndex].run();
                }
            }
            queueIndex = -1;
            len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
    }

    process.nextTick = function (fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
            }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
            runTimeout(drainQueue);
        }
    };

    // v8 likes predictible objects
    function Item(fun, array) {
        this.fun = fun;
        this.array = array;
    }
    Item.prototype.run = function () {
        this.fun.apply(null, this.array);
    };
    process.title = 'browser';
    process.browser = true;
    process.env = {};
    process.argv = [];
    process.version = ''; // empty string to avoid regexp issues
    process.versions = {};

    function noop() {}

    process.on = noop;
    process.addListener = noop;
    process.once = noop;
    process.off = noop;
    process.removeListener = noop;
    process.removeAllListeners = noop;
    process.emit = noop;
    process.prependListener = noop;
    process.prependOnceListener = noop;

    process.listeners = function (name) { return [] }

    process.binding = function (name) {
        throw new Error('process.binding is not supported');
    };

    process.cwd = function () { return '/' };
    process.chdir = function (dir) {
        throw new Error('process.chdir is not supported');
    };
    process.umask = function() { return 0; };

    },{}],22:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vnode_1 = require("./vnode");
    var is = require("./is");
    function addNS(data, children, sel) {
        data.ns = 'http://www.w3.org/2000/svg';
        if (sel !== 'foreignObject' && children !== undefined) {
            for (var i = 0; i < children.length; ++i) {
                var childData = children[i].data;
                if (childData !== undefined) {
                    addNS(childData, children[i].children, children[i].sel);
                }
            }
        }
    }
    function h(sel, b, c) {
        var data = {}, children, text, i;
        if (c !== undefined) {
            data = b;
            if (is.array(c)) {
                children = c;
            }
            else if (is.primitive(c)) {
                text = c;
            }
            else if (c && c.sel) {
                children = [c];
            }
        }
        else if (b !== undefined) {
            if (is.array(b)) {
                children = b;
            }
            else if (is.primitive(b)) {
                text = b;
            }
            else if (b && b.sel) {
                children = [b];
            }
            else {
                data = b;
            }
        }
        if (children !== undefined) {
            for (i = 0; i < children.length; ++i) {
                if (is.primitive(children[i]))
                    children[i] = vnode_1.vnode(undefined, undefined, undefined, children[i], undefined);
            }
        }
        if (sel[0] === 's' && sel[1] === 'v' && sel[2] === 'g' &&
            (sel.length === 3 || sel[3] === '.' || sel[3] === '#')) {
            addNS(data, children, sel);
        }
        return vnode_1.vnode(sel, data, children, text, undefined);
    }
    exports.h = h;
    ;
    exports.default = h;

    },{"./is":24,"./vnode":30}],23:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function createElement(tagName) {
        return document.createElement(tagName);
    }
    function createElementNS(namespaceURI, qualifiedName) {
        return document.createElementNS(namespaceURI, qualifiedName);
    }
    function createTextNode(text) {
        return document.createTextNode(text);
    }
    function createComment(text) {
        return document.createComment(text);
    }
    function insertBefore(parentNode, newNode, referenceNode) {
        parentNode.insertBefore(newNode, referenceNode);
    }
    function removeChild(node, child) {
        node.removeChild(child);
    }
    function appendChild(node, child) {
        node.appendChild(child);
    }
    function parentNode(node) {
        return node.parentNode;
    }
    function nextSibling(node) {
        return node.nextSibling;
    }
    function tagName(elm) {
        return elm.tagName;
    }
    function setTextContent(node, text) {
        node.textContent = text;
    }
    function getTextContent(node) {
        return node.textContent;
    }
    function isElement(node) {
        return node.nodeType === 1;
    }
    function isText(node) {
        return node.nodeType === 3;
    }
    function isComment(node) {
        return node.nodeType === 8;
    }
    exports.htmlDomApi = {
        createElement: createElement,
        createElementNS: createElementNS,
        createTextNode: createTextNode,
        createComment: createComment,
        insertBefore: insertBefore,
        removeChild: removeChild,
        appendChild: appendChild,
        parentNode: parentNode,
        nextSibling: nextSibling,
        tagName: tagName,
        setTextContent: setTextContent,
        getTextContent: getTextContent,
        isElement: isElement,
        isText: isText,
        isComment: isComment,
    };
    exports.default = exports.htmlDomApi;

    },{}],24:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.array = Array.isArray;
    function primitive(s) {
        return typeof s === 'string' || typeof s === 'number';
    }
    exports.primitive = primitive;

    },{}],25:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var xlinkNS = 'http://www.w3.org/1999/xlink';
    var xmlNS = 'http://www.w3.org/XML/1998/namespace';
    var colonChar = 58;
    var xChar = 120;
    function updateAttrs(oldVnode, vnode) {
        var key, elm = vnode.elm, oldAttrs = oldVnode.data.attrs, attrs = vnode.data.attrs;
        if (!oldAttrs && !attrs)
            return;
        if (oldAttrs === attrs)
            return;
        oldAttrs = oldAttrs || {};
        attrs = attrs || {};
        // update modified attributes, add new attributes
        for (key in attrs) {
            var cur = attrs[key];
            var old = oldAttrs[key];
            if (old !== cur) {
                if (cur === true) {
                    elm.setAttribute(key, "");
                }
                else if (cur === false) {
                    elm.removeAttribute(key);
                }
                else {
                    if (key.charCodeAt(0) !== xChar) {
                        elm.setAttribute(key, cur);
                    }
                    else if (key.charCodeAt(3) === colonChar) {
                        // Assume xml namespace
                        elm.setAttributeNS(xmlNS, key, cur);
                    }
                    else if (key.charCodeAt(5) === colonChar) {
                        // Assume xlink namespace
                        elm.setAttributeNS(xlinkNS, key, cur);
                    }
                    else {
                        elm.setAttribute(key, cur);
                    }
                }
            }
        }
        // remove removed attributes
        // use `in` operator since the previous `for` iteration uses it (.i.e. add even attributes with undefined value)
        // the other option is to remove all attributes with value == undefined
        for (key in oldAttrs) {
            if (!(key in attrs)) {
                elm.removeAttribute(key);
            }
        }
    }
    exports.attributesModule = { create: updateAttrs, update: updateAttrs };
    exports.default = exports.attributesModule;

    },{}],26:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function updateClass(oldVnode, vnode) {
        var cur, name, elm = vnode.elm, oldClass = oldVnode.data.class, klass = vnode.data.class;
        if (!oldClass && !klass)
            return;
        if (oldClass === klass)
            return;
        oldClass = oldClass || {};
        klass = klass || {};
        for (name in oldClass) {
            if (!klass[name]) {
                elm.classList.remove(name);
            }
        }
        for (name in klass) {
            cur = klass[name];
            if (cur !== oldClass[name]) {
                elm.classList[cur ? 'add' : 'remove'](name);
            }
        }
    }
    exports.classModule = { create: updateClass, update: updateClass };
    exports.default = exports.classModule;

    },{}],27:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function invokeHandler(handler, vnode, event) {
        if (typeof handler === "function") {
            // call function handler
            handler.call(vnode, event, vnode);
        }
        else if (typeof handler === "object") {
            // call handler with arguments
            if (typeof handler[0] === "function") {
                // special case for single argument for performance
                if (handler.length === 2) {
                    handler[0].call(vnode, handler[1], event, vnode);
                }
                else {
                    var args = handler.slice(1);
                    args.push(event);
                    args.push(vnode);
                    handler[0].apply(vnode, args);
                }
            }
            else {
                // call multiple handlers
                for (var i = 0; i < handler.length; i++) {
                    invokeHandler(handler[i], vnode, event);
                }
            }
        }
    }
    function handleEvent(event, vnode) {
        var name = event.type, on = vnode.data.on;
        // call event handler(s) if exists
        if (on && on[name]) {
            invokeHandler(on[name], vnode, event);
        }
    }
    function createListener() {
        return function handler(event) {
            handleEvent(event, handler.vnode);
        };
    }
    function updateEventListeners(oldVnode, vnode) {
        var oldOn = oldVnode.data.on, oldListener = oldVnode.listener, oldElm = oldVnode.elm, on = vnode && vnode.data.on, elm = (vnode && vnode.elm), name;
        // optimization for reused immutable handlers
        if (oldOn === on) {
            return;
        }
        // remove existing listeners which no longer used
        if (oldOn && oldListener) {
            // if element changed or deleted we remove all existing listeners unconditionally
            if (!on) {
                for (name in oldOn) {
                    // remove listener if element was changed or existing listeners removed
                    oldElm.removeEventListener(name, oldListener, false);
                }
            }
            else {
                for (name in oldOn) {
                    // remove listener if existing listener removed
                    if (!on[name]) {
                        oldElm.removeEventListener(name, oldListener, false);
                    }
                }
            }
        }
        // add new listeners which has not already attached
        if (on) {
            // reuse existing listener or create new
            var listener = vnode.listener = oldVnode.listener || createListener();
            // update vnode for listener
            listener.vnode = vnode;
            // if element changed or added we add all needed listeners unconditionally
            if (!oldOn) {
                for (name in on) {
                    // add listener if element was changed or new listeners added
                    elm.addEventListener(name, listener, false);
                }
            }
            else {
                for (name in on) {
                    // add listener if new listener added
                    if (!oldOn[name]) {
                        elm.addEventListener(name, listener, false);
                    }
                }
            }
        }
    }
    exports.eventListenersModule = {
        create: updateEventListeners,
        update: updateEventListeners,
        destroy: updateEventListeners
    };
    exports.default = exports.eventListenersModule;

    },{}],28:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vnode_1 = require("./vnode");
    var is = require("./is");
    var htmldomapi_1 = require("./htmldomapi");
    function isUndef(s) { return s === undefined; }
    function isDef(s) { return s !== undefined; }
    var emptyNode = vnode_1.default('', {}, [], undefined, undefined);
    function sameVnode(vnode1, vnode2) {
        return vnode1.key === vnode2.key && vnode1.sel === vnode2.sel;
    }
    function isVnode(vnode) {
        return vnode.sel !== undefined;
    }
    function createKeyToOldIdx(children, beginIdx, endIdx) {
        var i, map = {}, key, ch;
        for (i = beginIdx; i <= endIdx; ++i) {
            ch = children[i];
            if (ch != null) {
                key = ch.key;
                if (key !== undefined)
                    map[key] = i;
            }
        }
        return map;
    }
    var hooks = ['create', 'update', 'remove', 'destroy', 'pre', 'post'];
    var h_1 = require("./h");
    exports.h = h_1.h;
    var thunk_1 = require("./thunk");
    exports.thunk = thunk_1.thunk;
    function init(modules, domApi) {
        var i, j, cbs = {};
        var api = domApi !== undefined ? domApi : htmldomapi_1.default;
        for (i = 0; i < hooks.length; ++i) {
            cbs[hooks[i]] = [];
            for (j = 0; j < modules.length; ++j) {
                var hook = modules[j][hooks[i]];
                if (hook !== undefined) {
                    cbs[hooks[i]].push(hook);
                }
            }
        }
        function emptyNodeAt(elm) {
            var id = elm.id ? '#' + elm.id : '';
            var c = elm.className ? '.' + elm.className.split(' ').join('.') : '';
            return vnode_1.default(api.tagName(elm).toLowerCase() + id + c, {}, [], undefined, elm);
        }
        function createRmCb(childElm, listeners) {
            return function rmCb() {
                if (--listeners === 0) {
                    var parent_1 = api.parentNode(childElm);
                    api.removeChild(parent_1, childElm);
                }
            };
        }
        function createElm(vnode, insertedVnodeQueue) {
            var i, data = vnode.data;
            if (data !== undefined) {
                if (isDef(i = data.hook) && isDef(i = i.init)) {
                    i(vnode);
                    data = vnode.data;
                }
            }
            var children = vnode.children, sel = vnode.sel;
            if (sel === '!') {
                if (isUndef(vnode.text)) {
                    vnode.text = '';
                }
                vnode.elm = api.createComment(vnode.text);
            }
            else if (sel !== undefined) {
                // Parse selector
                var hashIdx = sel.indexOf('#');
                var dotIdx = sel.indexOf('.', hashIdx);
                var hash = hashIdx > 0 ? hashIdx : sel.length;
                var dot = dotIdx > 0 ? dotIdx : sel.length;
                var tag = hashIdx !== -1 || dotIdx !== -1 ? sel.slice(0, Math.min(hash, dot)) : sel;
                var elm = vnode.elm = isDef(data) && isDef(i = data.ns) ? api.createElementNS(i, tag)
                    : api.createElement(tag);
                if (hash < dot)
                    elm.setAttribute('id', sel.slice(hash + 1, dot));
                if (dotIdx > 0)
                    elm.setAttribute('class', sel.slice(dot + 1).replace(/\./g, ' '));
                for (i = 0; i < cbs.create.length; ++i)
                    cbs.create[i](emptyNode, vnode);
                if (is.array(children)) {
                    for (i = 0; i < children.length; ++i) {
                        var ch = children[i];
                        if (ch != null) {
                            api.appendChild(elm, createElm(ch, insertedVnodeQueue));
                        }
                    }
                }
                else if (is.primitive(vnode.text)) {
                    api.appendChild(elm, api.createTextNode(vnode.text));
                }
                i = vnode.data.hook; // Reuse variable
                if (isDef(i)) {
                    if (i.create)
                        i.create(emptyNode, vnode);
                    if (i.insert)
                        insertedVnodeQueue.push(vnode);
                }
            }
            else {
                vnode.elm = api.createTextNode(vnode.text);
            }
            return vnode.elm;
        }
        function addVnodes(parentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue) {
            for (; startIdx <= endIdx; ++startIdx) {
                var ch = vnodes[startIdx];
                if (ch != null) {
                    api.insertBefore(parentElm, createElm(ch, insertedVnodeQueue), before);
                }
            }
        }
        function invokeDestroyHook(vnode) {
            var i, j, data = vnode.data;
            if (data !== undefined) {
                if (isDef(i = data.hook) && isDef(i = i.destroy))
                    i(vnode);
                for (i = 0; i < cbs.destroy.length; ++i)
                    cbs.destroy[i](vnode);
                if (vnode.children !== undefined) {
                    for (j = 0; j < vnode.children.length; ++j) {
                        i = vnode.children[j];
                        if (i != null && typeof i !== "string") {
                            invokeDestroyHook(i);
                        }
                    }
                }
            }
        }
        function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
            for (; startIdx <= endIdx; ++startIdx) {
                var i_1 = void 0, listeners = void 0, rm = void 0, ch = vnodes[startIdx];
                if (ch != null) {
                    if (isDef(ch.sel)) {
                        invokeDestroyHook(ch);
                        listeners = cbs.remove.length + 1;
                        rm = createRmCb(ch.elm, listeners);
                        for (i_1 = 0; i_1 < cbs.remove.length; ++i_1)
                            cbs.remove[i_1](ch, rm);
                        if (isDef(i_1 = ch.data) && isDef(i_1 = i_1.hook) && isDef(i_1 = i_1.remove)) {
                            i_1(ch, rm);
                        }
                        else {
                            rm();
                        }
                    }
                    else {
                        api.removeChild(parentElm, ch.elm);
                    }
                }
            }
        }
        function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue) {
            var oldStartIdx = 0, newStartIdx = 0;
            var oldEndIdx = oldCh.length - 1;
            var oldStartVnode = oldCh[0];
            var oldEndVnode = oldCh[oldEndIdx];
            var newEndIdx = newCh.length - 1;
            var newStartVnode = newCh[0];
            var newEndVnode = newCh[newEndIdx];
            var oldKeyToIdx;
            var idxInOld;
            var elmToMove;
            var before;
            while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
                if (oldStartVnode == null) {
                    oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left
                }
                else if (oldEndVnode == null) {
                    oldEndVnode = oldCh[--oldEndIdx];
                }
                else if (newStartVnode == null) {
                    newStartVnode = newCh[++newStartIdx];
                }
                else if (newEndVnode == null) {
                    newEndVnode = newCh[--newEndIdx];
                }
                else if (sameVnode(oldStartVnode, newStartVnode)) {
                    patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
                    oldStartVnode = oldCh[++oldStartIdx];
                    newStartVnode = newCh[++newStartIdx];
                }
                else if (sameVnode(oldEndVnode, newEndVnode)) {
                    patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
                    oldEndVnode = oldCh[--oldEndIdx];
                    newEndVnode = newCh[--newEndIdx];
                }
                else if (sameVnode(oldStartVnode, newEndVnode)) {
                    patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
                    api.insertBefore(parentElm, oldStartVnode.elm, api.nextSibling(oldEndVnode.elm));
                    oldStartVnode = oldCh[++oldStartIdx];
                    newEndVnode = newCh[--newEndIdx];
                }
                else if (sameVnode(oldEndVnode, newStartVnode)) {
                    patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
                    api.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
                    oldEndVnode = oldCh[--oldEndIdx];
                    newStartVnode = newCh[++newStartIdx];
                }
                else {
                    if (oldKeyToIdx === undefined) {
                        oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
                    }
                    idxInOld = oldKeyToIdx[newStartVnode.key];
                    if (isUndef(idxInOld)) {
                        api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
                        newStartVnode = newCh[++newStartIdx];
                    }
                    else {
                        elmToMove = oldCh[idxInOld];
                        if (elmToMove.sel !== newStartVnode.sel) {
                            api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
                        }
                        else {
                            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
                            oldCh[idxInOld] = undefined;
                            api.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);
                        }
                        newStartVnode = newCh[++newStartIdx];
                    }
                }
            }
            if (oldStartIdx <= oldEndIdx || newStartIdx <= newEndIdx) {
                if (oldStartIdx > oldEndIdx) {
                    before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm;
                    addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
                }
                else {
                    removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
                }
            }
        }
        function patchVnode(oldVnode, vnode, insertedVnodeQueue) {
            var i, hook;
            if (isDef(i = vnode.data) && isDef(hook = i.hook) && isDef(i = hook.prepatch)) {
                i(oldVnode, vnode);
            }
            var elm = vnode.elm = oldVnode.elm;
            var oldCh = oldVnode.children;
            var ch = vnode.children;
            if (oldVnode === vnode)
                return;
            if (vnode.data !== undefined) {
                for (i = 0; i < cbs.update.length; ++i)
                    cbs.update[i](oldVnode, vnode);
                i = vnode.data.hook;
                if (isDef(i) && isDef(i = i.update))
                    i(oldVnode, vnode);
            }
            if (isUndef(vnode.text)) {
                if (isDef(oldCh) && isDef(ch)) {
                    if (oldCh !== ch)
                        updateChildren(elm, oldCh, ch, insertedVnodeQueue);
                }
                else if (isDef(ch)) {
                    if (isDef(oldVnode.text))
                        api.setTextContent(elm, '');
                    addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
                }
                else if (isDef(oldCh)) {
                    removeVnodes(elm, oldCh, 0, oldCh.length - 1);
                }
                else if (isDef(oldVnode.text)) {
                    api.setTextContent(elm, '');
                }
            }
            else if (oldVnode.text !== vnode.text) {
                if (isDef(oldCh)) {
                    removeVnodes(elm, oldCh, 0, oldCh.length - 1);
                }
                api.setTextContent(elm, vnode.text);
            }
            if (isDef(hook) && isDef(i = hook.postpatch)) {
                i(oldVnode, vnode);
            }
        }
        return function patch(oldVnode, vnode) {
            var i, elm, parent;
            var insertedVnodeQueue = [];
            for (i = 0; i < cbs.pre.length; ++i)
                cbs.pre[i]();
            if (!isVnode(oldVnode)) {
                oldVnode = emptyNodeAt(oldVnode);
            }
            if (sameVnode(oldVnode, vnode)) {
                patchVnode(oldVnode, vnode, insertedVnodeQueue);
            }
            else {
                elm = oldVnode.elm;
                parent = api.parentNode(elm);
                createElm(vnode, insertedVnodeQueue);
                if (parent !== null) {
                    api.insertBefore(parent, vnode.elm, api.nextSibling(elm));
                    removeVnodes(parent, [oldVnode], 0, 0);
                }
            }
            for (i = 0; i < insertedVnodeQueue.length; ++i) {
                insertedVnodeQueue[i].data.hook.insert(insertedVnodeQueue[i]);
            }
            for (i = 0; i < cbs.post.length; ++i)
                cbs.post[i]();
            return vnode;
        };
    }
    exports.init = init;

    },{"./h":22,"./htmldomapi":23,"./is":24,"./thunk":29,"./vnode":30}],29:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var h_1 = require("./h");
    function copyToThunk(vnode, thunk) {
        thunk.elm = vnode.elm;
        vnode.data.fn = thunk.data.fn;
        vnode.data.args = thunk.data.args;
        thunk.data = vnode.data;
        thunk.children = vnode.children;
        thunk.text = vnode.text;
        thunk.elm = vnode.elm;
    }
    function init(thunk) {
        var cur = thunk.data;
        var vnode = cur.fn.apply(undefined, cur.args);
        copyToThunk(vnode, thunk);
    }
    function prepatch(oldVnode, thunk) {
        var i, old = oldVnode.data, cur = thunk.data;
        var oldArgs = old.args, args = cur.args;
        if (old.fn !== cur.fn || oldArgs.length !== args.length) {
            copyToThunk(cur.fn.apply(undefined, args), thunk);
            return;
        }
        for (i = 0; i < args.length; ++i) {
            if (oldArgs[i] !== args[i]) {
                copyToThunk(cur.fn.apply(undefined, args), thunk);
                return;
            }
        }
        copyToThunk(oldVnode, thunk);
    }
    exports.thunk = function thunk(sel, key, fn, args) {
        if (args === undefined) {
            args = fn;
            fn = key;
            key = undefined;
        }
        return h_1.h(sel, {
            key: key,
            hook: { init: init, prepatch: prepatch },
            fn: fn,
            args: args
        });
    };
    exports.default = exports.thunk;

    },{"./h":22}],30:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function vnode(sel, data, children, text, elm) {
        var key = data === undefined ? undefined : data.key;
        return { sel: sel, data: data, children: children,
            text: text, elm: elm, key: key };
    }
    exports.vnode = vnode;
    exports.default = vnode;

    },{}],31:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.run = void 0;
    const snabbdom_1 = require("snabbdom");
    const class_1 = require("snabbdom/modules/class");
    const attributes_1 = require("snabbdom/modules/attributes");
    const eventlisteners_1 = require("snabbdom/modules/eventlisteners");
    const page = require("page");
    const unit_1 = require("./units/unit");
    function run(element) {
        const patch = snabbdom_1.init([class_1.default, attributes_1.default, eventlisteners_1.default]);
        const lastZoom = 100;
        let unit, cg, vnode;
        function redraw() {
            vnode = patch(vnode || element, render());
        }
        function runUnit(vnode) {
            const el = vnode.elm;
            el.className = 'cg-wrap';
            cg = unit.run(el);
            window['cg'] = cg; // for messing up with it from the browser console
            if (lastZoom !== 100)
                setZoom(lastZoom);
        }
        function setZoom(zoom) {
            const el = document.querySelector('.cg-wrap');
            if (el) {
                const px = `${zoom / 100 * 320}px`;
                el.style.width = px;
                el.style.height = px;
                document.body.dispatchEvent(new Event('chessground.resize'));
            }
        }
        function render() {
            return snabbdom_1.h('div#chessground-examples', [
                snabbdom_1.h('section.blue.merida', [
                    snabbdom_1.h('div.cg-wrap', {
                        hook: {
                            insert: runUnit,
                            postpatch: runUnit
                        }
                    }),
                    snabbdom_1.h('p', unit.name)
                ]),
            ]);
        }
        page({ click: false, popstate: false, dispatch: false, hashbang: true });
        page('/:id', ctx => {
            unit = unit_1.list[parseInt(ctx.params.id) || 0];
            redraw();
        });
        page(location.hash.slice(2) || '/0');
    }
    exports.run = run;

    },{"./units/unit":39,"page":20,"snabbdom":28,"snabbdom/modules/attributes":25,"snabbdom/modules/class":26,"snabbdom/modules/eventlisteners":27}],32:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.whileHolding = exports.notSameRole = exports.withSameRole = exports.conflictingAnim = void 0;
    const chessground_1 = require("chessground");
    exports.conflictingAnim = {
        name: 'Animation: conflict',
        run(el) {
            const cg = chessground_1.Chessground(el, {
                animation: {
                    duration: 500
                },
                fen: '8/8/5p2/4P3/4K3/8/8/8',
                turnColor: 'black',
                movable: {
                    color: 'white',
                    free: false
                }
            });
            setTimeout(() => {
                cg.move('f6', 'e5');
                cg.set({
                    turnColor: 'white',
                    movable: {
                        dests: new Map([
                            ['e4', ['e5', 'd5', 'f5']]
                        ])
                    }
                });
                cg.playPremove();
            }, 2000);
            return cg;
        }
    };
    exports.withSameRole = {
        name: 'Animation: same role',
        run(el) {
            const cg = chessground_1.Chessground(el, {
                animation: {
                    duration: 2000
                },
                highlight: {
                    lastMove: false
                },
                fen: '8/8/4p3/5p2/4B3/8/8/8',
                turnColor: 'white',
            });
            setTimeout(() => {
                cg.move('e4', 'f5');
                setTimeout(() => {
                    cg.move('e6', 'f5');
                }, 500);
            }, 200);
            return cg;
        }
    };
    exports.notSameRole = {
        name: 'Animation: different role',
        run(el) {
            const cg = chessground_1.Chessground(el, {
                animation: {
                    duration: 2000
                },
                highlight: {
                    lastMove: false
                },
                fen: '8/8/4n3/5p2/4P3/8/8/8',
                turnColor: 'white',
            });
            setTimeout(() => {
                cg.move('e4', 'f5');
                setTimeout(() => {
                    cg.move('e6', 'f5');
                }, 500);
            }, 200);
            return cg;
        }
    };
    exports.whileHolding = {
        name: 'Animation: while holding',
        run(el) {
            const cg = chessground_1.Chessground(el, {
                fen: '8/8/5p2/4P3/4K3/8/8/8',
                turnColor: 'black',
                animation: {
                    duration: 5000
                },
                movable: {
                    color: 'white',
                    free: false,
                    showDests: false
                }
            });
            setTimeout(() => {
                cg.move('f6', 'e5');
                cg.set({
                    turnColor: 'white',
                    movable: {
                        dests: new Map([
                            ['e4', ['e5', 'd5', 'f5']]
                        ])
                    }
                });
                cg.playPremove();
            }, 3000);
            return cg;
        }
    };

    },{"chessground":5}],33:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.checkHighlight = exports.lastMoveCrazyhouse = exports.fromFen = exports.defaults = void 0;
    const chessground_1 = require("chessground");
    exports.defaults = {
        name: 'Default configuration',
        run(el) {
            return chessground_1.Chessground(el);
        }
    };
    exports.fromFen = {
        name: 'From FEN, from black POV',
        run(el) {
            return chessground_1.Chessground(el, {
                fen: '2r3k1/pp2Qpbp/4b1p1/3p4/3n1PP1/2N4P/Pq6/R2K1B1R w -',
                orientation: 'black'
            });
        }
    };
    exports.lastMoveCrazyhouse = {
        name: 'Last move: crazyhouse',
        run(el) {
            const cg = chessground_1.Chessground(el);
            setTimeout(() => {
                cg.set({ lastMove: ['e2', 'e4'] });
                setTimeout(() => cg.set({ lastMove: ['g6'] }), 1000);
                setTimeout(() => cg.set({ lastMove: ['e1'] }), 2000);
            });
            return cg;
        }
    };
    exports.checkHighlight = {
        name: 'Highlight king in check',
        run(el) {
            const fen = 'r1bqkbnr/1ppppBpp/p1n5/8/4P3/8/PPPP1PPP/RNBQK1NR b KQkq - 0 1';
            const cg = chessground_1.Chessground(el, {
                fen: fen,
                turnColor: 'black',
                highlight: {
                    check: true
                }
            });
            cg.set({
                check: true
            });
            return cg;
        }
    };

    },{"chessground":5}],34:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.autoSwitch = void 0;
    const chessground_1 = require("chessground");
    exports.autoSwitch = {
        name: 'FEN: switch (puzzle bug)',
        run(cont) {
            const configs = [() => {
                    return {
                        orientation: 'black',
                        fen: 'rnbqkb1r/pp1ppppp/5n2/8/3N1B2/8/PPP1PPPP/RN1QKB1R b KQkq - 0 4',
                        lastMove: ['f3', 'd4']
                    };
                }, () => {
                    return {
                        orientation: 'white',
                        fen: 'rnbqkbnr/ppppppPp/8/8/4P3/8/PPPP1PP1/RNBQKBNR w KQkq - 0 1',
                        lastMove: ['b4', 'b3']
                    };
                }];
            const cg = chessground_1.Chessground(cont, configs[0]());
            const delay = 2000;
            let it = 0;
            function run() {
                if (!cg.state.dom.elements.board.offsetParent)
                    return;
                cg.set(configs[++it % configs.length]());
                setTimeout(run, delay);
            }
            setTimeout(run, delay);
            return cg;
        }
    };

    },{"chessground":5}],35:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fullRandom = exports.vsRandom = exports.defaults = void 0;
    const chessground_1 = require("chessground");
    const chess_js_1 = require("chess.js");
    const util_1 = require("../util");
    exports.defaults = {
        name: '3D theme',
        run(cont) {
            const el = wrapped(cont);
            const cg = chessground_1.Chessground(el, {
                addPieceZIndex: true,
            });
            cg.redrawAll();
            return cg;
        }
    };
    exports.vsRandom = {
        name: '3D theme: play vs random AI',
        run(cont) {
            const el = wrapped(cont);
            const chess = new chess_js_1.Chess();
            const cg = chessground_1.Chessground(el, {
                orientation: 'black',
                addPieceZIndex: true,
                movable: {
                    color: 'white',
                    free: false,
                    dests: util_1.toDests(chess)
                }
            });
            cg.redrawAll();
            cg.set({
                movable: {
                    events: {
                        after: util_1.aiPlay(cg, chess, 1000, false)
                    }
                }
            });
            return cg;
        }
    };
    exports.fullRandom = {
        name: '3D theme: watch 2 random AIs',
        run(cont) {
            const el = wrapped(cont);
            const chess = new chess_js_1.Chess();
            const delay = 300;
            const cg = chessground_1.Chessground(el, {
                orientation: 'black',
                addPieceZIndex: true,
                movable: {
                    free: false
                }
            });
            cg.redrawAll();
            function makeMove() {
                if (!cg.state.dom.elements.board.offsetParent)
                    return;
                const moves = chess.moves({ verbose: true });
                const move = moves[Math.floor(Math.random() * moves.length)];
                chess.move(move.san);
                cg.move(move.from, move.to);
                setTimeout(makeMove, delay);
            }
            setTimeout(makeMove, delay);
            return cg;
        }
    };
    function wrapped(cont) {
        const el = document.createElement('div');
        cont.className = 'in3d staunton';
        cont.innerHTML = '';
        cont.appendChild(el);
        return el;
    }

    },{"../util":42,"chess.js":1,"chessground":5}],36:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.select = exports.move = void 0;
    const chessground_1 = require("chessground");
    exports.move = {
        name: 'Perf: piece move',
        run(cont) {
            const cg = chessground_1.Chessground(cont, {
                animation: { duration: 500 }
            });
            const delay = 400;
            function run() {
                if (!cg.state.dom.elements.board.offsetParent)
                    return;
                cg.move('e2', 'a8');
                setTimeout(() => {
                    cg.move('a8', 'e2');
                    setTimeout(run, delay);
                }, delay);
            }
            setTimeout(run, delay);
            return cg;
        }
    };
    exports.select = {
        name: 'Perf: square select',
        run(cont) {
            const cg = chessground_1.Chessground(cont, {
                movable: {
                    free: false,
                    dests: new Map([
                        ['e2', ['e3', 'e4', 'd3', 'f3']]
                    ])
                }
            });
            const delay = 500;
            function run() {
                if (!cg.state.dom.elements.board.offsetParent)
                    return;
                cg.selectSquare('e2');
                setTimeout(() => {
                    cg.selectSquare('d4');
                    setTimeout(run, delay);
                }, delay);
            }
            setTimeout(run, delay);
            return cg;
        }
    };

    },{"chessground":5}],37:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.conflictingHold = exports.slowAnim = exports.fullRandom = exports.vsRandom = exports.castling = exports.initial = void 0;
    const chess_js_1 = require("chess.js");
    const chessground_1 = require("chessground");
    const util_1 = require("../util");
    exports.initial = {
        name: 'Play legal moves from initial position',
        run(el) {
            const chess = new chess_js_1.Chess();
            const cg = chessground_1.Chessground(el, {
                movable: {
                    color: 'white',
                    free: false,
                    dests: util_1.toDests(chess),
                },
                draggable: {
                    showGhost: true
                }
            });
            cg.set({
                movable: { events: { after: util_1.playOtherSide(cg, chess) } }
            });
            return cg;
        }
    };
    exports.castling = {
        name: 'Castling',
        run(el) {
            const fen = 'rnbqk2r/pppp1ppp/5n2/2b1p3/2B1P3/5N2/PPPP1PPP/RNBQK2R w KQkq - 4 4';
            const chess = new chess_js_1.Chess(fen);
            const cg = chessground_1.Chessground(el, {
                fen: fen,
                turnColor: util_1.toColor(chess),
                movable: {
                    color: 'white',
                    free: false,
                    dests: util_1.toDests(chess)
                }
            });
            cg.set({
                movable: { events: { after: util_1.playOtherSide(cg, chess) } }
            });
            return cg;
        }
    };
    exports.vsRandom = {
        name: '',
        run(el) {
          const fen = FEN;
          const chess = new chess_js_1.Chess(fen);
            const cg = chessground_1.Chessground(el, {
              fen: FEN,
              turnColor: boardRotation,
              orientation: boardRotation,
                movable: {
                  color: boardRotation,
                    free: false,
                    dests: util_1.toDests(chess),
                },
                highlight: {
                  check: true,
                }
            });
            cg.set({
                movable: {
                    events: {
                        after: util_1.aiPlay(cg, chess, 200, false)
                    },
                    color: boardRotation,
                }
            });
            if (chess.in_check() == true) {
              if (flipBoard == 'true') {
                cg.set({
                  turnColor: opponentColour,
                });
              }

              cg.set({
                  check: true,
              });
            }
            if (chess.game_over() == false && flipBoard == 'true') {
              setTimeout(() => {

                    if (expectedMove.variations.length > 0) {
                    const moveVar = Math.floor(Math.random() * (expectedMove.variations.length + 1));
                    if (moveVar == expectedMove.variations.length) {
                    } else {
                      count = 0;
                      expectedLine = expectedMove.variations[moveVar];
                      expectedMove = expectedLine[0];
                    }
                  }

                    chess.move(expectedMove.notation.notation);
                    const lastMoveAi = chess.undo();
                    chess.move(expectedMove.notation.notation);
                    cg.move(expectedMove.notation.notation);;
                    cg.set({
                        fen: chess.fen(),
                        movable: {
                            dests: util_1.toDests(chess),
                        }
                    });

                      cg.set({
                        turnColor: boardRotation,
                          check: chess.in_check()
                      });
                      cg.set({ lastMove: [lastMoveAi.from, lastMoveAi.to] });
                    count++;
                    expectedMove = expectedLine[count];
                    cg.playPremove();
              }, 100);
            }
            return cg;
        }
    };
    exports.fullRandom = {
        name: 'Watch 2 random AIs',
        run(el) {
            const chess = new chess_js_1.Chess();
            const cg = chessground_1.Chessground(el, {
                animation: {
                    duration: 1000
                },
                movable: {
                    free: false
                }
            });
            function makeMove() {
                if (!cg.state.dom.elements.board.offsetParent)
                    return;
                const moves = chess.moves({ verbose: true });
                const move = moves[Math.floor(Math.random() * moves.length)];
                chess.move(move.san);
                cg.move(move.from, move.to);
                setTimeout(makeMove, 700);
            }
            setTimeout(makeMove, 700);
            return cg;
        }
    };
    exports.slowAnim = {
        name: 'Play vs random AI; slow animations',
        run(el) {
            const chess = new chess_js_1.Chess();
            const cg = chessground_1.Chessground(el, {
                animation: {
                    duration: 5000
                },
                movable: {
                    color: 'white',
                    free: false,
                    dests: util_1.toDests(chess)
                }
            });
            cg.set({
                movable: {
                    events: {
                        after: util_1.aiPlay(cg, chess, 1000, false)
                    }
                }
            });
            return cg;
        }
    };
    exports.conflictingHold = {
        name: 'Conflicting hold/premove',
        run(el) {
            const cg = chessground_1.Chessground(el, {
                fen: '8/8/5p2/4P3/8/8/8/8',
                turnColor: 'black',
                movable: {
                    color: 'white',
                    free: false,
                    dests: new Map([
                        ['e5', ['f6']]
                    ])
                }
            });
            setTimeout(() => {
                cg.move('f6', 'e5');
                cg.playPremove();
                cg.set({
                    turnColor: 'white',
                    movable: {
                        dests: undefined
                    }
                });
            }, 1000);
            return cg;
        }
    };

    },{"../util":42,"chess.js":1,"chessground":5}],38:[function(require,module,exports){
    "use strict";
    var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.customSvg = exports.enabledFalse = exports.visibleFalse = exports.autoShapes = exports.brushModifiers = exports.changingShapesLow = exports.changingShapesHigh = exports.presetUserShapes = void 0;
    const chessground_1 = require("chessground");
    exports.presetUserShapes = {
        name: 'Preset user shapes',
        run: el => chessground_1.Chessground(el, { drawable: { shapes: shapeSet1 } })
    };
    exports.changingShapesHigh = {
        name: 'Automatically changing shapes (high diff)',
        run(el) {
            const cg = chessground_1.Chessground(el, { drawable: { shapes: shapeSet1 } });
            const delay = 1000;
            const sets = [shapeSet1, shapeSet2, shapeSet3];
            let i = 0;
            function run() {
                if (!cg.state.dom.elements.board.offsetParent)
                    return;
                cg.setShapes(sets[++i % sets.length]);
                setTimeout(run, delay);
            }
            setTimeout(run, delay);
            return cg;
        }
    };
    exports.changingShapesLow = {
        name: 'Automatically changing shapes (low diff)',
        run(el) {
            const cg = chessground_1.Chessground(el, { drawable: { shapes: shapeSet1 } });
            const delay = 1000;
            const sets = [shapeSet1, shapeSet1b, shapeSet1c];
            let i = 0;
            function run() {
                if (!cg.state.dom.elements.board.offsetParent)
                    return;
                cg.setShapes(sets[++i % sets.length]);
                setTimeout(run, delay);
            }
            setTimeout(run, delay);
            return cg;
        }
    };
    exports.brushModifiers = {
        name: 'Brush modifiers',
        run(el) {
            function sets() {
                return [shapeSet1, shapeSet1b, shapeSet1c].map(set => set.map(shape => {
                    shape.modifiers = Math.round(Math.random()) ? undefined : {
                        lineWidth: 2 + Math.round(Math.random() * 3) * 4
                    };
                    return shape;
                }));
            }
            ;
            const cg = chessground_1.Chessground(el, { drawable: { shapes: sets()[0] } });
            const delay = 1000;
            let i = 0;
            function run() {
                if (!cg.state.dom.elements.board.offsetParent)
                    return;
                cg.setShapes(sets()[++i % sets().length]);
                setTimeout(run, delay);
            }
            setTimeout(run, delay);
            return cg;
        }
    };
    exports.autoShapes = {
        name: 'Autoshapes',
        run(el) {
            function sets() {
                return [shapeSet1, shapeSet1b, shapeSet1c].map(set => set.map(shape => {
                    shape.modifiers = Math.round(Math.random()) ? undefined : {
                        lineWidth: 2 + Math.round(Math.random() * 3) * 4
                    };
                    return shape;
                }));
            }
            ;
            const cg = chessground_1.Chessground(el);
            const delay = 1000;
            let i = 0;
            function run() {
                if (!cg.state.dom.elements.board.offsetParent)
                    return;
                cg.setAutoShapes(sets()[++i % sets().length]);
                setTimeout(run, delay);
            }
            setTimeout(run, delay);
            return cg;
        }
    };
    exports.visibleFalse = {
        name: 'Shapes not visible',
        run: el => chessground_1.Chessground(el, {
            drawable: {
                visible: false,
                shapes: shapeSet1
            }
        })
    };
    exports.enabledFalse = {
        name: 'Shapes not enabled, but visible',
        run: el => chessground_1.Chessground(el, {
            drawable: {
                enabled: false,
                shapes: shapeSet1
            }
        })
    };
    exports.customSvg = {
        name: 'Custom SVG',
        run(el) {
            const cg = chessground_1.Chessground(el, { animation: { duration: 300 } });
            const sleep = (msec) => new Promise(resolve => setTimeout(resolve, msec));
            const loop = () => __awaiter(this, void 0, void 0, function* () {
                if (!cg.state.dom.elements.board.offsetParent)
                    return;
                cg.set({ fen: 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1' });
                cg.setAutoShapes([]);
                yield sleep(1000);
                cg.move('e2', 'e4');
                cg.setAutoShapes([{ orig: 'e4', customSvg: glyphToSvg['??'] }]);
                yield sleep(1000);
                cg.move('e7', 'e5');
                cg.setAutoShapes([{ orig: 'e5', customSvg: glyphToSvg['?!'] }]);
                yield sleep(1000);
                cg.move('d1', 'e2');
                cg.setAutoShapes([{ orig: 'e2', customSvg: glyphToSvg['?'] }]);
                yield sleep(1000);
                setTimeout(loop);
            });
            loop();
            return cg;
        }
    };
    const shapeSet1 = [
        { orig: 'a3', brush: 'green' },
        { orig: 'a4', brush: 'blue' },
        { orig: 'a5', brush: 'yellow' },
        { orig: 'a6', brush: 'red' },
        { orig: 'e2', dest: 'e4', brush: 'green' },
        { orig: 'a6', dest: 'c8', brush: 'blue' },
        { orig: 'f8', dest: 'f4', brush: 'yellow' },
        { orig: 'h5', brush: 'green', piece: {
                color: 'white',
                role: 'knight'
            } },
        { orig: 'h6', brush: 'red', piece: {
                color: 'black',
                role: 'queen',
                scale: 0.6
            } }
    ];
    const shapeSet2 = [
        { orig: 'c1', brush: 'green' },
        { orig: 'd1', brush: 'blue' },
        { orig: 'e1', brush: 'yellow' },
        { orig: 'e2', dest: 'e4', brush: 'green' },
        { orig: 'h6', dest: 'h8', brush: 'blue' },
        { orig: 'b3', dest: 'd6', brush: 'red' },
        { orig: 'a1', dest: 'e1', brush: 'red' },
        { orig: 'f5', brush: 'green', piece: {
                color: 'black',
                role: 'bishop'
            } }
    ];
    const shapeSet3 = [
        { orig: 'e5', brush: 'blue' }
    ];
    const shapeSet1b = [
        { orig: 'a3', brush: 'green' },
        { orig: 'a5', brush: 'yellow' },
        { orig: 'a6', brush: 'red' },
        { orig: 'e2', dest: 'e4', brush: 'green' },
        { orig: 'a6', dest: 'c8', brush: 'blue' },
        { orig: 'f8', dest: 'f4', brush: 'yellow' },
        { orig: 'h5', brush: 'green', piece: {
                color: 'white',
                role: 'knight'
            } },
        { orig: 'h6', brush: 'red', piece: {
                color: 'black',
                role: 'queen',
                scale: 0.6
            } }
    ];
    const shapeSet1c = [
        { orig: 'a3', brush: 'green' },
        { orig: 'a5', brush: 'yellow' },
        { orig: 'a6', brush: 'red' },
        { orig: 'e2', dest: 'e4', brush: 'green' },
        { orig: 'a6', dest: 'c8', brush: 'blue' },
        { orig: 'b6', dest: 'd8', brush: 'blue' },
        { orig: 'f8', dest: 'f4', brush: 'yellow' },
        { orig: 'h5', brush: 'green', piece: {
                color: 'white',
                role: 'knight'
            } },
        { orig: 'h6', brush: 'red', piece: {
                color: 'black',
                role: 'queen',
                scale: 0.6
            } }
    ];
    const glyphToSvg = {
        // Inaccuracy
        '?!': `
    <g transform="translate(68 2) scale(0.3)">
      <circle style="fill:#56b4e9" cx="50" cy="50" r="50" />
      <path style="fill:#ffffff;stroke-width:0.81934" d="m 37.734375,21.947266 c -3.714341,0 -7.128696,0.463992 -10.242187,1.392578 -3.113493,0.928585 -6.009037,2.130656 -8.685547,3.605468 l 4.34375,8.765626 c 2.348774,-1.201699 4.643283,-2.157093 6.882812,-2.867188 2.239529,-0.710095 4.504676,-1.064453 6.798828,-1.064453 2.294152,0 4.069851,0.463993 5.326172,1.392578 1.310944,0.873963 1.966797,2.185668 1.966797,3.933594 0,1.747925 -0.546219,3.276946 -1.638672,4.58789 -1.037831,1.256322 -2.786121,2.757934 -5.24414,4.50586 -2.785757,2.021038 -4.751362,3.961188 -5.898438,5.818359 -1.147076,1.857171 -1.720703,4.149726 -1.720703,6.88086 v 2.951171 h 10.568359 v -2.376953 c 0,-1.147076 0.137043,-2.10247 0.410156,-2.867187 0.327737,-0.764718 0.928772,-1.557613 1.802735,-2.376953 0.873963,-0.81934 2.103443,-1.802143 3.6875,-2.949219 2.130284,-1.584057 3.905982,-3.058262 5.326172,-4.423828 1.420189,-1.42019 2.485218,-2.951164 3.195312,-4.589844 0.710095,-1.63868 1.064453,-3.576877 1.064453,-5.816406 0,-4.205946 -1.583838,-7.675117 -4.751953,-10.40625 -3.113492,-2.731134 -7.510649,-4.095703 -13.191406,-4.095703 z m 24.744141,0.818359 2.048828,39.083984 h 9.75 L 76.324219,22.765625 Z M 35.357422,68.730469 c -1.966416,0 -3.63248,0.51881 -4.998047,1.55664 -1.365567,0.983208 -2.046875,2.731498 -2.046875,5.244141 0,2.403397 0.681308,4.151687 2.046875,5.244141 1.365567,1.03783 3.031631,1.55664 4.998047,1.55664 1.911793,0 3.550449,-0.51881 4.916016,-1.55664 1.365566,-1.092454 2.048828,-2.840744 2.048828,-5.244141 0,-2.512643 -0.683262,-4.260933 -2.048828,-5.244141 -1.365567,-1.03783 -3.004223,-1.55664 -4.916016,-1.55664 z m 34.003906,0 c -1.966416,0 -3.63248,0.51881 -4.998047,1.55664 -1.365566,0.983208 -2.048828,2.731498 -2.048828,5.244141 0,2.403397 0.683262,4.151687 2.048828,5.244141 1.365567,1.03783 3.031631,1.55664 4.998047,1.55664 1.911793,0 3.550449,-0.51881 4.916016,-1.55664 1.365566,-1.092454 2.046875,-2.840744 2.046875,-5.244141 0,-2.512643 -0.681309,-4.260933 -2.046875,-5.244141 -1.365567,-1.03783 -3.004223,-1.55664 -4.916016,-1.55664 z" />
    </g>
    `,
        // Mistake
        '?': `
    <g transform="translate(68 2) scale(0.3)">
      <circle style="fill:#e69f00" cx="50" cy="50" r="50" />
      <path style="fill:#ffffff;stroke-width:0.932208" d="m 40.435856,60.851495 q 0,-4.661041 1.957637,-7.830548 1.957637,-3.169507 6.711897,-6.618677 4.194937,-2.983065 5.966132,-5.127144 1.864416,-2.237299 1.864416,-5.220365 0,-2.983065 -2.237299,-4.474598 -2.144079,-1.584754 -6.059353,-1.584754 -3.915273,0 -7.737326,1.21187 -3.822053,1.211871 -7.830548,3.262729 L 28.13071,24.495382 q 4.567819,-2.516962 9.881405,-4.101716 5.313586,-1.584753 11.6526,-1.584753 9.694964,0 15.008549,4.66104 5.406807,4.66104 5.406807,11.839042 0,3.822053 -1.21187,6.618677 -1.211871,2.796624 -3.635612,5.220365 -2.423741,2.33052 -6.059352,5.033923 -2.703403,1.957637 -4.194936,3.355949 -1.491533,1.398312 -2.050858,2.703403 -0.466104,1.305091 -0.466104,3.262728 v 2.703403 H 40.435856 Z m -1.491533,18.923822 q 0,-4.288156 2.33052,-5.966131 2.33052,-1.771195 5.686469,-1.771195 3.262728,0 5.593248,1.771195 2.33052,1.677975 2.33052,5.966131 0,4.101716 -2.33052,5.966132 -2.33052,1.771195 -5.593248,1.771195 -3.355949,0 -5.686469,-1.771195 -2.33052,-1.864416 -2.33052,-5.966132 z" />
    </g>
    `,
        // Blunder
        '??': `
    <g transform="translate(68 2) scale(0.3)">
      <circle style="fill:#df5353" cx="50" cy="50" r="50" />
      <path style="fill:#ffffff;stroke-width:0.810558" d="m 31.799294,22.220598 c -3.67453,-10e-7 -7.050841,0.460303 -10.130961,1.378935 -3.08012,0.918633 -5.945403,2.106934 -8.593226,3.565938 l 4.297618,8.67363 c 2.3236,-1.188818 4.592722,-2.135794 6.808247,-2.838277 2.215525,-0.702483 4.45828,-1.053299 6.727842,-1.053299 2.269562,0 4.025646,0.460305 5.268502,1.378937 1.296893,0.864596 1.945788,2.160375 1.945788,3.889565 0,1.72919 -0.541416,3.241939 -1.62216,4.538831 -1.026707,1.242856 -2.756423,2.729237 -5.188097,4.458428 -2.755898,1.999376 -4.700572,3.917682 -5.835354,5.754947 -1.13478,1.837266 -1.702564,4.106388 -1.702564,6.808248 v 2.918681 h 10.4566 v -2.34982 c 0,-1.134781 0.135856,-2.081756 0.406042,-2.838277 0.324222,-0.756521 0.918373,-1.539262 1.782969,-2.349819 0.864595,-0.810559 2.079262,-1.783901 3.646342,-2.918683 2.10745,-1.567078 3.863533,-3.025082 5.268501,-4.376012 1.404967,-1.404967 2.459422,-2.919725 3.161905,-4.540841 0.702483,-1.621116 1.053298,-3.539423 1.053298,-5.754948 0,-4.160865 -1.567492,-7.591921 -4.70165,-10.29378 -3.080121,-2.70186 -7.429774,-4.052384 -13.049642,-4.052384 z m 38.66449,0 c -3.67453,-10e-7 -7.05285,0.460303 -10.132971,1.378935 -3.08012,0.918633 -5.943393,2.106934 -8.591215,3.565938 l 4.295608,8.67363 c 2.323599,-1.188818 4.592721,-2.135794 6.808246,-2.838277 2.215526,-0.702483 4.458281,-1.053299 6.727842,-1.053299 2.269563,0 4.025647,0.460305 5.268502,1.378937 1.296893,0.864596 1.945788,2.160375 1.945788,3.889565 0,1.72919 -0.539406,3.241939 -1.62015,4.538831 -1.026707,1.242856 -2.756423,2.729237 -5.188097,4.458428 -2.755897,1.999376 -4.700572,3.917682 -5.835353,5.754947 -1.134782,1.837266 -1.702564,4.106388 -1.702564,6.808248 v 2.918681 h 10.456599 v -2.34982 c 0,-1.134781 0.133846,-2.081756 0.404032,-2.838277 0.324223,-0.756521 0.918374,-1.539262 1.782969,-2.349819 0.864596,-0.810559 2.081273,-1.783901 3.648352,-2.918683 2.107451,-1.567078 3.863534,-3.025082 5.268502,-4.376012 1.404966,-1.404967 2.45942,-2.919725 3.161904,-4.540841 0.702483,-1.621116 1.053299,-3.539423 1.053299,-5.754948 0,-4.160865 -1.567493,-7.591921 -4.701651,-10.29378 -3.08012,-2.70186 -7.429774,-4.052384 -13.049642,-4.052384 z M 29.449473,68.50341 c -1.945339,0 -3.593943,0.513038 -4.944873,1.539744 -1.350931,0.97267 -2.026192,2.702386 -2.026192,5.188098 0,2.377636 0.675261,4.107352 2.026192,5.188097 1.35093,1.026707 2.999534,1.539745 4.944873,1.539745 1.891302,0 3.51153,-0.513038 4.86246,-1.539745 1.35093,-1.080745 2.026192,-2.810461 2.026192,-5.188097 0,-2.485712 -0.675262,-4.215428 -2.026192,-5.188098 -1.35093,-1.026706 -2.971158,-1.539744 -4.86246,-1.539744 z m 38.662481,0 c -1.945339,0 -3.591933,0.513038 -4.942864,1.539744 -1.35093,0.97267 -2.026192,2.702386 -2.026192,5.188098 0,2.377636 0.675262,4.107352 2.026192,5.188097 1.350931,1.026707 2.997525,1.539745 4.942864,1.539745 1.891302,0 3.513539,-0.513038 4.864469,-1.539745 1.350931,-1.080745 2.026192,-2.810461 2.026192,-5.188097 0,-2.485712 -0.675261,-4.215428 -2.026192,-5.188098 -1.35093,-1.026706 -2.973167,-1.539744 -4.864469,-1.539744 z" />
    </g>
    `,
    };

    },{"chessground":5}],39:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.list = void 0;
    const basics = require("./basics");
    const play = require("./play");
    const perf = require("./perf");
    const zh = require("./zh");
    const anim = require("./anim");
    const svg = require("./svg");
    const in3d = require("./in3d");
    const fen = require("./fen");
    const viewOnly = require("./viewOnly");
    exports.list = [
        play.vsRandom,

    ];

    },{"./anim":32,"./basics":33,"./fen":34,"./in3d":35,"./perf":36,"./play":37,"./svg":38,"./viewOnly":40,"./zh":41}],40:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fullRandom = void 0;
    const chess_js_1 = require("chess.js");
    const chessground_1 = require("chessground");
    exports.fullRandom = {
        name: 'View only: 2 random AIs',
        run(el) {
            const chess = new chess_js_1.Chess();
            const cg = chessground_1.Chessground(el, {
                viewOnly: true,
                animation: {
                    duration: 1000
                },
                movable: {
                    free: false
                },
                drawable: {
                    visible: false
                }
            });
            function makeMove() {
                if (!cg.state.dom.elements.board.offsetParent)
                    return;
                const moves = chess.moves({ verbose: true });
                const move = moves[Math.floor(Math.random() * moves.length)];
                chess.move(move.san);
                cg.move(move.from, move.to);
                setTimeout(makeMove, 700);
            }
            setTimeout(makeMove, 700);
            return cg;
        }
    };

    },{"chess.js":1,"chessground":5}],41:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.lastMoveDrop = void 0;
    const chessground_1 = require("chessground");
    exports.lastMoveDrop = {
        name: 'Crazyhouse: lastMove = drop',
        run(cont) {
            const configs = [() => {
                    return {
                        fen: 'Bn2kb1r/p1p2ppp/4q3/2Pp4/3p1NP1/2B2n2/PPP2P1P/R2KqB1R/RNpp w k - 42 22',
                        lastMove: ['e5', 'd4']
                    };
                }, () => {
                    return {
                        fen: 'Bn2kb1r/p1p2ppp/4q3/2Pp4/3p1NP1/2B2n2/PPP2P1P/R2KqB1R/RNpp w k - 42 22',
                        lastMove: ['f4']
                    };
                }, () => {
                    return {
                        fen: 'Bn2kb1r/p1p2ppp/4q3/2Pp4/3p1NP1/2B2n2/PPP2P1P/R2KqB1R/RNpp w k - 42 22',
                        lastMove: ['e1']
                    };
                }];
            const cg = chessground_1.Chessground(cont, configs[0]());
            const delay = 2000;
            let it = 0;
            function run() {
                if (!cg.state.dom.elements.board.offsetParent)
                    return;
                const config = configs[++it % configs.length];
                cg.set(config());
                setTimeout(run, delay);
            }
            setTimeout(run, delay);
            return cg;
        }
    };

    },{"chessground":5}],42:[function(require,module,exports){
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.aiPlay = exports.playOtherSide = exports.toColor = exports.toDests = void 0;
    function toDests(chess) {
        const dests = new Map();
        chess.SQUARES.forEach(s => {
            const ms = chess.moves({ square: s, verbose: true });
            if (ms.length)
                dests.set(s, ms.map(m => m.to));
        });
        return dests;
    }
    exports.toDests = toDests;
    function toColor(chess) {
        return (chess.turn() === 'w') ? 'white' : 'black';
    }
    exports.toColor = toColor;
    function playOtherSide(cg, chess) {
        return (orig, dest) => {
            chess.move({ from: orig, to: dest });
            cg.set({
                turnColor: toColor(chess),
                movable: {
                    color: toColor(chess),
                    dests: toDests(chess)
                }
            });
        };
    }
    exports.playOtherSide = playOtherSide;
    function aiPlay(cg, chess, delay) {
        return (orig, dest) => {
          foundVariation = false;
            chess.move({ from: orig, to: dest, promotion: promoteChoice});
            const moveCheck = chess.undo().san;
          function moveChecker(moveCheck) {
            if (moveCheck.includes("=")) {
            cg.set({
                fen: chess.fen(),
                }
            );
            chess.move({ from: orig, to: dest, promotion: promoteChoice});
            cg.set({
                fen: chess.fen(),
                }
            );
            moveCheck = chess.undo().san;
          }

          if (expectedMove && typeof expectedMove !== 'string') {
            if (expectedMove.notation.notation == moveCheck) {
              foundVariation = true;
            } else if (expectedMove.notation.notation !== moveCheck) {
            if (expectedMove.variations.length > 0) {
              for (var i = 0; i < expectedMove.variations.length; i++) {
                if (moveCheck === expectedMove.variations[i][0].notation.notation) {

                  count = 0;
                  expectedLine = expectedMove.variations[i];
                  expectedMove = expectedLine[count];
                  foundVariation = true;
                  break
                }

              }
              // wrong move
              if (foundVariation === false) {
                cg.set({
                  check: chess.in_check(),
                    fen: chess.fen(),
                    turnColor: toColor(chess),
                    movable: {
                        color: toColor(chess),
                        dests: toDests(chess)
                    }
                    }
                );
              }

            } else {
              cg.set({
                check: chess.in_check(),
                  fen: chess.fen(),
                  turnColor: toColor(chess),
                  movable: {
                      color: toColor(chess),
                      dests: toDests(chess)
                  }
                  }
              );
            }

          }
        }

          if (foundVariation == true) {
            count++;
            expectedMove = expectedLine[count];
            chess.move({ from: orig, to: dest, promotion: promoteChoice});
            cg.set({
                check: chess.in_check()
            });
          if (expectedMove && typeof expectedMove !== 'string') {
            setTimeout(() => {
              errorCount = 0;
                if (expectedMove.variations.length > 0) {
                const moveVar = Math.floor(Math.random() * (expectedMove.variations.length + 1));
                if (moveVar == expectedMove.variations.length) {
                } else {
                  count = 0;
                  expectedLine = expectedMove.variations[moveVar];
                  expectedMove = expectedLine[0];
                }
              }

                chess.move(expectedMove.notation.notation);
                const lastMoveAi = chess.undo();
                chess.move(expectedMove.notation.notation);
                cg.move(expectedMove.notation.notation);
                cg.set({
                    fen: chess.fen(),
                    turnColor: toColor(chess),
                    movable: {
                        color: toColor(chess),
                        dests: toDests(chess)
                    }
                });
                cg.set({
                    check: chess.in_check()
                });
                cg.set({ lastMove: [lastMoveAi.from, lastMoveAi.to] });
                count++;
                expectedMove = expectedLine[count];
                cg.playPremove();

                if (!expectedMove || typeof expectedMove === 'string') {
                  const el = document.querySelector('.cg-wrap');
                  el.style.border = "0.7vmin solid limegreen";
                  el.style.boxShadow ="0px 0px 6px 0px limegreen"
                  cg.set({
        viewOnly: true,
        });
                }

            }, delay);
          } else {
            count++;
            expectedMove = expectedLine[count];
            if (!expectedMove || typeof expectedMove === 'string') {
              const el = document.querySelector('.cg-wrap');
              el.style.border = "0.7vmin solid limegreen";
              el.style.boxShadow ="0px 0px 6px 0px limegreen"
              cg.set({
              fen: chess.fen(),
    viewOnly: true
    });
            }
            count--;
            expectedMove = expectedLine[count];
          }
        } else {
          errorCount++;
          window.parent.postMessage('*', '*');
          console.log(errorCount);
          if (errorCount > handicap) {
            chess.move(expectedMove.notation.notation);
            const lastMoveAi = chess.undo();
            chess.move(expectedMove.notation.notation);
            cg.move(expectedMove.notation.notation);
            cg.set({
                fen: chess.fen(),
                turnColor: toColor(chess),
                movable: {
                    color: toColor(chess),
                    dests: toDests(chess)
                }
            });
            cg.set({
                check: chess.in_check()
            });
            cg.set({ lastMove: [lastMoveAi.from, lastMoveAi.to] });
            count++;
            expectedMove = expectedLine[count];
            setTimeout(() => {
              if (expectedMove && typeof expectedMove !== 'string') {
                setTimeout(() => {
                  errorCount = 0;
                    if (expectedMove.variations.length > 0) {
                    const moveVar = Math.floor(Math.random() * (expectedMove.variations.length + 1));
                    if (moveVar == expectedMove.variations.length) {
                    } else {
                      count = 0;
                      expectedLine = expectedMove.variations[moveVar];
                      expectedMove = expectedLine[0];
                    }
                  }

                    chess.move(expectedMove.notation.notation);
                    const lastMoveAi = chess.undo();
                    chess.move(expectedMove.notation.notation);
                    cg.move(expectedMove.notation.notation);
                    cg.set({
                        fen: chess.fen(),
                        turnColor: toColor(chess),
                        movable: {
                            color: toColor(chess),
                            dests: toDests(chess)
                        }
                    });
                    cg.set({
                        check: chess.in_check()
                    });
                    cg.set({ lastMove: [lastMoveAi.from, lastMoveAi.to] });
                    count++;
                    expectedMove = expectedLine[count];
                    cg.playPremove();

                    if (!expectedMove || typeof expectedMove === 'string') {
                      const el = document.querySelector('.cg-wrap');
                      el.style.border = "0.7vmin solid limegreen";
                      el.style.boxShadow ="0px 0px 6px 0px limegreen"
                      cg.set({
            viewOnly: true,
            });
                    }

                }, delay);
              } else {
                count++;
                expectedMove = expectedLine[count];
                if (!expectedMove || typeof expectedMove === 'string') {
                  const el = document.querySelector('.cg-wrap');
                  el.style.border = "0.7vmin solid limegreen";
                  el.style.boxShadow ="0px 0px 6px 0px limegreen"
                  cg.set({
        viewOnly: true,
        });
                }
                count--;
                expectedMove = expectedLine[count];
              }
            }, 300);
            errorCount = 0;
          }
        }
        }

            if (moveCheck.includes("=")) {
              const promoteButtons = document.querySelectorAll("#center > button");
              for (var i=0; i<promoteButtons.length; i++){
              	promoteButtons[i].onclick = function(){
              		promoteChoice=this.value;document.querySelector("#center").style.display = "none";
                  moveChecker(moveCheck);
                  document.querySelector(".cg-wrap").style.filter = 'none';
                  document.querySelector("cg-board").style.cursor = 'pointer';
              	}
              }
              document.querySelector("#center").style.display = 'block';
              document.querySelector(".cg-wrap").style.filter = 'brightness(50%)';
              document.querySelector("cg-board").style.cursor = 'default';
            } else {
              moveChecker(moveCheck)
            }
          };

    }
    exports.aiPlay = aiPlay;

    },{}]},{},[31])(31)
    cg.playPremove();
    });
    </script>
    <script>
    function reload() {
      count = 0; // Int so we can track on which move we are.
      expectedLine = parsedPGN.moves; // Set initially to the mainline of pgn but can change path with variations
      expectedMove = parsedPGN.moves[count]; // Set the expected move according to PGN
      ChessgroundExamples.run(document.getElementById('chessground-examples'));
      const el = document.querySelector('.cg-wrap');
      if (el) {
          const px = Math.min(600, document.documentElement.clientWidth * 0.97);;
          el.style.width = px;
          el.style.height = px;
          document.body.dispatchEvent(new Event('chessground.resize'));
      }
      el.style.border = "0.7vmin solid #670A0A";
    }
    reload();
    </script>
  </body>
</html>
